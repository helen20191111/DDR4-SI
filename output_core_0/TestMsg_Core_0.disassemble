
output_Core_0\TestMsg_Core_0.elf:     file format elf32-littlearm


Disassembly of section text_startup:

fffd0000 <_startup>:
// In order for the interrupts to work, this code section must be placed at interrupts vector table physical address or copy it to later on (from '_startup' to 'reset_handler').

.section .text.startup

_startup:
/*0x00*/    b reset_handler                 /* Note: start with SVC/SWI processor mode */
fffd0000:	ea000039 	b	fffd00ec <reset_handler>
/*0x04*/    b undefined_instruction_handler /* Undef processor mode */
fffd0004:	ea000014 	b	fffd005c <undefined_instruction_handler>
/*0x08*/    b svc_handler                   /* SVC/SWI processor mode */
fffd0008:	ea000025 	b	fffd00a4 <svc_handler>
/*0x0C*/    b prefetch_abort_handler        /* Abort processor mode */
fffd000c:	ea000018 	b	fffd0074 <prefetch_abort_handler>
/*0x10*/    b data_abort_handler            /* Abort processor mode */
fffd0010:	ea00001d 	b	fffd008c <data_abort_handler>
/*0x14*/    b error							/* reserved */
fffd0014:	ea00000e 	b	fffd0054 <error>
/*0x18*/    b irq_handler                   /* IRQ processor mode */
fffd0018:	ea000027 	b	fffd00bc <irq_handler>
/*0x1C*/    b fiq_handler                   /* FIQ processor mode */
fffd001c:	ea00002c 	b	fffd00d4 <fiq_handler>
fffd0020:	00000000 	.word	0x00000000

fffd0024 <pUndefinedInstructionRoutine>:
fffd0024:	fffd0054 	.word	0xfffd0054

fffd0028 <pSvcRoutine>:
fffd0028:	fffd0054 	.word	0xfffd0054

fffd002c <pPrefetchAbortRoutine>:
fffd002c:	fffd0054 	.word	0xfffd0054

fffd0030 <pDataAbortRoutine>:
fffd0030:	fffd0054 	.word	0xfffd0054
fffd0034:	00000000 	.word	0x00000000

fffd0038 <pIrqRoutine>:
fffd0038:	fffd0054 	.word	0xfffd0054

fffd003c <pFiqRoutine>:
fffd003c:	fffd0054 	.word	0xfffd0054

fffd0040 <TestMsg>:
fffd0040:	12345678 	.word	0x12345678
fffd0044:	10000001 	.word	0x10000001
fffd0048:	fffd0000 	.word	0xfffd0000
fffd004c:	fffd0000 	.word	0xfffd0000
fffd0050:	ffffffff 	.word	0xffffffff

fffd0054 <error>:
              
/*.skip 0x40*/
              
error:
    // BKPT 0xEEEE
	mov r0, #-1
fffd0054:	e3e00000 	mvn	r0, #0
	b _exit
fffd0058:	ea000052 	b	fffd01a8 <_exit>

fffd005c <undefined_instruction_handler>:
	//b reset_handler
    //b   .
    // MOVS pc, lr // typically there is nowhere to return to !!

undefined_instruction_handler:
    push {r0-r12,lr}
fffd005c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    mov  r0, lr			// r0 is the returning address while the undefined instruction address is at -4 in ARM state and -2 in Thumb state.
fffd0060:	e1a0000e 	mov	r0, lr
    
    // ldr r1, =pUndefinedInstructionRoutine   // set r1 with pUndefinedInstructionRoutine value  r1 = (UINT32)(&Addr)
    ldr r1, pUndefinedInstructionRoutine       // set r1 with the value point at pUndefinedInstructionRoutine address  r1 = Addr
fffd0064:	e51f1048 	ldr	r1, [pc, #-72]	; fffd0024 <pUndefinedInstructionRoutine>
    blx  r1
fffd0068:	e12fff31 	blx	r1
    pop {r0-r12,lr}
fffd006c:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    b reset_handler
fffd0070:	ea00001d 	b	fffd00ec <reset_handler>

fffd0074 <prefetch_abort_handler>:
    // MOVS pc,lr  // typically there is nowhere to return to !!

prefetch_abort_handler:
    push {r0-r12,lr}
fffd0074:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    sub  r0, lr, #4		// r0 is the address of the aborting prefetch 
fffd0078:	e24e0004 	sub	r0, lr, #4
    ldr r1, pPrefetchAbortRoutine
fffd007c:	e51f1058 	ldr	r1, [pc, #-88]	; fffd002c <pPrefetchAbortRoutine>
    blx r1
fffd0080:	e12fff31 	blx	r1
    pop {r0-r12,lr}
fffd0084:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    b reset_handler
fffd0088:	ea000017 	b	fffd00ec <reset_handler>

fffd008c <data_abort_handler>:
    // SUBS pc, lr , #4	// retuns to the aborting address; typically there is nowhere to return to !!

data_abort_handler:
    push {r0-r12,lr}
fffd008c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    sub  r0, lr, #8		// r0 is the address of the Load or Store instruction that generated the Data Abort.
fffd0090:	e24e0008 	sub	r0, lr, #8
    ldr r1, pDataAbortRoutine
fffd0094:	e51f106c 	ldr	r1, [pc, #-108]	; fffd0030 <pDataAbortRoutine>
    blx r1
fffd0098:	e12fff31 	blx	r1
    pop {r0-r12,lr}
fffd009c:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    SUBS pc, lr, #4		// retuns to the next command (assuming ARM state) after the aborting instruction;
fffd00a0:	e25ef004 	subs	pc, lr, #4

fffd00a4 <svc_handler>:

svc_handler: /*SWI*/
    push {r0-r12,lr}
fffd00a4:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    mov  r0, lr			// r0 is the returning address while the calling address (previous instruction) is -4 in ARM state and -2 in Thumb state.
fffd00a8:	e1a0000e 	mov	r0, lr
    ldr r1, pSvcRoutine
fffd00ac:	e51f108c 	ldr	r1, [pc, #-140]	; fffd0028 <pSvcRoutine>
    blx r1
fffd00b0:	e12fff31 	blx	r1
    pop {r0-r12,lr}
fffd00b4:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    MOVS pc,lr  // The S means restore CPSR from SPSR
fffd00b8:	e1b0f00e 	movs	pc, lr

fffd00bc <irq_handler>:

irq_handler:
	push {r0-r12,lr}
fffd00bc:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
	sub  r0, lr, #4		// r0 is the address of the instruction that was not executed because the IRQ took priority
fffd00c0:	e24e0004 	sub	r0, lr, #4
    ldr r1, pIrqRoutine
fffd00c4:	e51f1094 	ldr	r1, [pc, #-148]	; fffd0038 <pIrqRoutine>
    blx r1
fffd00c8:	e12fff31 	blx	r1
    pop {r0-r12,lr}
fffd00cc:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    SUBS pc, lr , #4
fffd00d0:	e25ef004 	subs	pc, lr, #4

fffd00d4 <fiq_handler>:

fiq_handler: // TBD: there is no need to push all registers.....
    push {r0-r12,lr}
fffd00d4:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    sub  r0, lr, #4		// r0 is the address of the instruction that was not executed because the FIQ took priority
fffd00d8:	e24e0004 	sub	r0, lr, #4
    ldr r1, pFiqRoutine
fffd00dc:	e51f10a8 	ldr	r1, [pc, #-168]	; fffd003c <pFiqRoutine>
    blx r1
fffd00e0:	e12fff31 	blx	r1
    pop {r0-r12,lr}
fffd00e4:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
    SUBS pc, lr , #4
fffd00e8:	e25ef004 	subs	pc, lr, #4

fffd00ec <reset_handler>:
reset_handler:

	// This code use it's own stack and not the caller stack (i.e, caller can be UBOOT or FUP).
	// the code push caller registers into caller stack (there is no need to push r0 since it is the return value)
	// If caller stack is not initialize or invalid address this code may stuck (e.g. when using JTAG to load a code. In this case init the stack via JTAG to some RAM address before run the code)
	push {r1-r12,lr}
fffd00ec:	e92d5ffe 	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
	
	// store caller sp register into top of the new stack
	ldr r0, =__StackTop // top of the stack
fffd00f0:	e59f00c4 	ldr	r0, [pc, #196]	; fffd01bc <_exit+0x14>
	sub r0, r0 ,#4
fffd00f4:	e2400004 	sub	r0, r0, #4
	str sp, [r0], #-4
fffd00f8:	e400d004 	str	sp, [r0], #-4

    /* Init the stacks pointers */
    MRS r2, CPSR        // MRS: Move the contents of special register CPSR to a general-purpose register
fffd00fc:	e10f2000 	mrs	r2, CPSR
    BIC r2, r2, #0x1f   // r2 = r2 & (~0x1F) ==> clear bits 0..4;
fffd0100:	e3c2201f 	bic	r2, r2, #31
    ORR r2, r2, #0x1C0  // r2 = r2 | 0x1C0 ==> disable FIQ, IRQ and Abort
fffd0104:	e3822d07 	orr	r2, r2, #448	; 0x1c0

    ORR r3, r2, #0x11 // enter FIQ mode
fffd0108:	e3823011 	orr	r3, r2, #17
    MSR CPSR_c, r3
fffd010c:	e121f003 	msr	CPSR_c, r3
    mov sp, r0
fffd0110:	e1a0d000 	mov	sp, r0
    sub r0, r0, #0x100  // will use 0x100 bytes for FIQ
fffd0114:	e2400c01 	sub	r0, r0, #256	; 0x100

    ORR r3, r2, #0x12 // enter IRQ mode
fffd0118:	e3823012 	orr	r3, r2, #18
    MSR CPSR_c, r3
fffd011c:	e121f003 	msr	CPSR_c, r3
    mov sp, r0
fffd0120:	e1a0d000 	mov	sp, r0
    sub r0, r0, #0x100  // will use 0x100 bytes for IRQ
fffd0124:	e2400c01 	sub	r0, r0, #256	; 0x100

    ORR r3, r2, #0x17 // enter Abort mode
fffd0128:	e3823017 	orr	r3, r2, #23
    MSR CPSR_c, r3
fffd012c:	e121f003 	msr	CPSR_c, r3
    mov sp, r0
fffd0130:	e1a0d000 	mov	sp, r0
    sub r0, r0, #0x100  // will use 0x100 bytes for Abort
fffd0134:	e2400c01 	sub	r0, r0, #256	; 0x100

    ORR r3, r2, #0x1B // enter Undef mode
fffd0138:	e382301b 	orr	r3, r2, #27
    MSR CPSR_c, r3
fffd013c:	e121f003 	msr	CPSR_c, r3
    mov sp, r0
fffd0140:	e1a0d000 	mov	sp, r0
    sub r0, r0, #0x100  // will use 0x100 bytes for Undef
fffd0144:	e2400c01 	sub	r0, r0, #256	; 0x100
    
    ORR r3, r2, #0x13 // enter SVC mode
fffd0148:	e3823013 	orr	r3, r2, #19
    MSR CPSR_c, r3
fffd014c:	e121f003 	msr	CPSR_c, r3
    mov sp, r0
fffd0150:	e1a0d000 	mov	sp, r0
    MSR CPSR_c, r3
    mov sp, r0         // will use up to  __StackLimit
    */
    
    /* Copy the data segment initializers from 'ROM' to 'RAM' */
    ldr     r0, =_sidata  /* Start address for the initialization values of the .data section */
fffd0154:	e59f0064 	ldr	r0, [pc, #100]	; fffd01c0 <_exit+0x18>
    ldr     r1, =_sdata   /* Start address for the .data section */
fffd0158:	e59f1064 	ldr	r1, [pc, #100]	; fffd01c4 <_exit+0x1c>
    ldr     r2, =_edata   /* End address for the .data section */
fffd015c:	e59f2064 	ldr	r2, [pc, #100]	; fffd01c8 <_exit+0x20>

fffd0160 <data_loop>:
 data_loop:
    cmp     r1, r2
fffd0160:	e1510002 	cmp	r1, r2
    itt     lt
    ldrlt   r3, [r0], #4
fffd0164:	b4903004 	ldrlt	r3, [r0], #4
    strlt   r3, [r1], #4
fffd0168:	b4813004 	strlt	r3, [r1], #4
    blt     data_loop
fffd016c:	bafffffb 	blt	fffd0160 <data_loop>

     /* Zero fill the stack  */
    ldr     r0, =__StackLimit   /* Start address for the stack  */
fffd0170:	e59f0054 	ldr	r0, [pc, #84]	; fffd01cc <_exit+0x24>
    ldr     r1, =__StackTop     /* End address for the stack */
fffd0174:	e59f1040 	ldr	r1, [pc, #64]	; fffd01bc <_exit+0x14>
    sub		r1, r1 ,#8
fffd0178:	e2411008 	sub	r1, r1, #8
    mov     r2, #0
fffd017c:	e3a02000 	mov	r2, #0

fffd0180 <stack_loop>:
 stack_loop:
    cmp     r0, r1
fffd0180:	e1500001 	cmp	r0, r1
    it      lt
    strlt   r2, [r0], #4
fffd0184:	b4802004 	strlt	r2, [r0], #4
    blt     stack_loop
fffd0188:	bafffffc 	blt	fffd0180 <stack_loop>

    /* Zero fill the bss segment  */
    ldr     r0, =__bss_start__      /* Start address for the .bss section */
fffd018c:	e59f003c 	ldr	r0, [pc, #60]	; fffd01d0 <_exit+0x28>
    ldr     r1, =__bss_end__        /* End address for the .bss section   */
fffd0190:	e59f103c 	ldr	r1, [pc, #60]	; fffd01d4 <_exit+0x2c>
    mov     r2, #0
fffd0194:	e3a02000 	mov	r2, #0

fffd0198 <bss_loop>:
 bss_loop:
    cmp     r0, r1
fffd0198:	e1500001 	cmp	r0, r1
    it      lt
    strlt   r2, [r0], #4
fffd019c:	b4802004 	strlt	r2, [r0], #4
    blt     bss_loop
fffd01a0:	bafffffc 	blt	fffd0198 <bss_loop>


	/* jump to main  */
    bl main
fffd01a4:	eb00017b 	bl	fffd0798 <main>

fffd01a8 <_exit>:
    /* return from main, r0 is update, all other are invalid */
 
_exit:

    // return caller sp and registers (except r0)
    ldr r1, =__StackTop // top of the stack
fffd01a8:	e59f100c 	ldr	r1, [pc, #12]	; fffd01bc <_exit+0x14>
    sub r1, r1 ,#4
fffd01ac:	e2411004 	sub	r1, r1, #4
	ldr sp, [r1]
fffd01b0:	e591d000 	ldr	sp, [r1]
    pop {r1-r12,pc}
fffd01b4:	e8bd9ffe 	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, pc}
	
    /* endless loop in case of a problem */
    b   .
fffd01b8:	eafffffe 	b	fffd01b8 <_exit+0x10>
	// the code push caller registers into caller stack (there is no need to push r0 since it is the return value)
	// If caller stack is not initialize or invalid address this code may stuck (e.g. when using JTAG to load a code. In this case init the stack via JTAG to some RAM address before run the code)
	push {r1-r12,lr}
	
	// store caller sp register into top of the new stack
	ldr r0, =__StackTop // top of the stack
fffd01bc:	c0009000 	.word	0xc0009000
    MSR CPSR_c, r3
    mov sp, r0         // will use up to  __StackLimit
    */
    
    /* Copy the data segment initializers from 'ROM' to 'RAM' */
    ldr     r0, =_sidata  /* Start address for the initialization values of the .data section */
fffd01c0:	fffd72e8 	.word	0xfffd72e8
    ldr     r1, =_sdata   /* Start address for the .data section */
fffd01c4:	fffd72e8 	.word	0xfffd72e8
    ldr     r2, =_edata   /* End address for the .data section */
fffd01c8:	fffd72ec 	.word	0xfffd72ec
    ldrlt   r3, [r0], #4
    strlt   r3, [r1], #4
    blt     data_loop

     /* Zero fill the stack  */
    ldr     r0, =__StackLimit   /* Start address for the stack  */
fffd01cc:	c0008000 	.word	0xc0008000
    it      lt
    strlt   r2, [r0], #4
    blt     stack_loop

    /* Zero fill the bss segment  */
    ldr     r0, =__bss_start__      /* Start address for the .bss section */
fffd01d0:	fffd72f0 	.word	0xfffd72f0
    ldr     r1, =__bss_end__        /* End address for the .bss section   */
fffd01d4:	fffd7a14 	.word	0xfffd7a14

Disassembly of section text_all_others:

fffd01d8 <IrqRoutine>:
extern INT_ROUTINE pFiqRoutine;

int g_SkipDataAbort;

void IrqRoutine (UINT32 Address)
{
fffd01d8:	e92d4010 	push	{r4, lr}
fffd01dc:	e1a04000 	mov	r4, r0
	LOG_ERROR (("'IRQ' event has been triggered at address 0x%08lX. \n",Address));
fffd01e0:	e59f1038 	ldr	r1, [pc, #56]	; fffd0220 <IrqRoutine+0x48>
fffd01e4:	e3a02021 	mov	r2, #33	; 0x21
fffd01e8:	e59f0034 	ldr	r0, [pc, #52]	; fffd0224 <IrqRoutine+0x4c>
fffd01ec:	e59f3034 	ldr	r3, [pc, #52]	; fffd0228 <IrqRoutine+0x50>
fffd01f0:	e08f1001 	add	r1, pc, r1
fffd01f4:	e08f0000 	add	r0, pc, r0
fffd01f8:	e08f3003 	add	r3, pc, r3
fffd01fc:	eb00116a 	bl	fffd47ac <LogError>
fffd0200:	e59f0024 	ldr	r0, [pc, #36]	; fffd022c <IrqRoutine+0x54>
fffd0204:	e1a01004 	mov	r1, r4
fffd0208:	e08f0000 	add	r0, pc, r0
fffd020c:	eb001166 	bl	fffd47ac <LogError>
fffd0210:	e59f0018 	ldr	r0, [pc, #24]	; fffd0230 <IrqRoutine+0x58>
	//exit (-1);
}
fffd0214:	e8bd4010 	pop	{r4, lr}

int g_SkipDataAbort;

void IrqRoutine (UINT32 Address)
{
	LOG_ERROR (("'IRQ' event has been triggered at address 0x%08lX. \n",Address));
fffd0218:	e08f0000 	add	r0, pc, r0
fffd021c:	ea001136 	b	fffd46fc <LogMessage>
fffd0220:	00005084 	.word	0x00005084
fffd0224:	0000505a 	.word	0x0000505a
fffd0228:	0000586d 	.word	0x0000586d
fffd022c:	00005073 	.word	0x00005073
fffd0230:	00005ab4 	.word	0x00005ab4

fffd0234 <FiqRoutine>:
	//exit (-1);
}
//-------------------------------------------------------------
void FiqRoutine (UINT32 Address)
{
fffd0234:	e92d4010 	push	{r4, lr}
fffd0238:	e1a04000 	mov	r4, r0
	LOG_ERROR (("'FIQ' event has been triggered at address 0x%08lX. \n",Address));
fffd023c:	e59f1038 	ldr	r1, [pc, #56]	; fffd027c <FiqRoutine+0x48>
fffd0240:	e3a02027 	mov	r2, #39	; 0x27
fffd0244:	e59f0034 	ldr	r0, [pc, #52]	; fffd0280 <FiqRoutine+0x4c>
fffd0248:	e59f3034 	ldr	r3, [pc, #52]	; fffd0284 <FiqRoutine+0x50>
fffd024c:	e08f1001 	add	r1, pc, r1
fffd0250:	e08f0000 	add	r0, pc, r0
fffd0254:	e08f3003 	add	r3, pc, r3
fffd0258:	eb001153 	bl	fffd47ac <LogError>
fffd025c:	e59f0024 	ldr	r0, [pc, #36]	; fffd0288 <FiqRoutine+0x54>
fffd0260:	e1a01004 	mov	r1, r4
fffd0264:	e08f0000 	add	r0, pc, r0
fffd0268:	eb00114f 	bl	fffd47ac <LogError>
fffd026c:	e59f0018 	ldr	r0, [pc, #24]	; fffd028c <FiqRoutine+0x58>
	//exit (-1);
}
fffd0270:	e8bd4010 	pop	{r4, lr}
	//exit (-1);
}
//-------------------------------------------------------------
void FiqRoutine (UINT32 Address)
{
	LOG_ERROR (("'FIQ' event has been triggered at address 0x%08lX. \n",Address));
fffd0274:	e08f0000 	add	r0, pc, r0
fffd0278:	ea00111f 	b	fffd46fc <LogMessage>
fffd027c:	00005028 	.word	0x00005028
fffd0280:	00004ffe 	.word	0x00004ffe
fffd0284:	00005806 	.word	0x00005806
fffd0288:	0000504c 	.word	0x0000504c
fffd028c:	00005a58 	.word	0x00005a58

fffd0290 <UndefinedInstructionRoutine>:
	LOG_ERROR (("'Data Abort' event has been triggered at address 0x%08lX. \n",Address));
	//exit (-1);
}
//-------------------------------------------------------------
void UndefinedInstructionRoutine (UINT32 Address)
{
fffd0290:	e92d4010 	push	{r4, lr}
fffd0294:	e1a04000 	mov	r4, r0
	LOG_ERROR (("'Undefined Instruction' event has been triggered at address 0x%08lX in ARM state or 0x%08lX in Thumb state. \n",Address-4,Address-2));
fffd0298:	e59f103c 	ldr	r1, [pc, #60]	; fffd02dc <UndefinedInstructionRoutine+0x4c>
fffd029c:	e3a02035 	mov	r2, #53	; 0x35
fffd02a0:	e59f0038 	ldr	r0, [pc, #56]	; fffd02e0 <UndefinedInstructionRoutine+0x50>
fffd02a4:	e59f3038 	ldr	r3, [pc, #56]	; fffd02e4 <UndefinedInstructionRoutine+0x54>
fffd02a8:	e08f1001 	add	r1, pc, r1
fffd02ac:	e08f0000 	add	r0, pc, r0
fffd02b0:	e08f3003 	add	r3, pc, r3
fffd02b4:	eb00113c 	bl	fffd47ac <LogError>
fffd02b8:	e59f0028 	ldr	r0, [pc, #40]	; fffd02e8 <UndefinedInstructionRoutine+0x58>
fffd02bc:	e2441004 	sub	r1, r4, #4
fffd02c0:	e2442002 	sub	r2, r4, #2
fffd02c4:	e08f0000 	add	r0, pc, r0
fffd02c8:	eb001137 	bl	fffd47ac <LogError>
fffd02cc:	e59f0018 	ldr	r0, [pc, #24]	; fffd02ec <UndefinedInstructionRoutine+0x5c>
	//exit (-1);
}
fffd02d0:	e8bd4010 	pop	{r4, lr}
	//exit (-1);
}
//-------------------------------------------------------------
void UndefinedInstructionRoutine (UINT32 Address)
{
	LOG_ERROR (("'Undefined Instruction' event has been triggered at address 0x%08lX in ARM state or 0x%08lX in Thumb state. \n",Address-4,Address-2));
fffd02d4:	e08f0000 	add	r0, pc, r0
fffd02d8:	ea001107 	b	fffd46fc <LogMessage>
fffd02dc:	00004fcc 	.word	0x00004fcc
fffd02e0:	00004fa2 	.word	0x00004fa2
fffd02e4:	00004f6d 	.word	0x00004f6d
fffd02e8:	00005021 	.word	0x00005021
fffd02ec:	000059f8 	.word	0x000059f8

fffd02f0 <PrefetchAbortRoutine>:
	//exit (-1);
}
//-------------------------------------------------------------
void PrefetchAbortRoutine (UINT32 Address)
{
fffd02f0:	e92d4010 	push	{r4, lr}
fffd02f4:	e1a04000 	mov	r4, r0
	LOG_ERROR (("'Pre-fetch Abort' event has been triggered at address 0x%08lX. \n",Address));
fffd02f8:	e59f1038 	ldr	r1, [pc, #56]	; fffd0338 <PrefetchAbortRoutine+0x48>
fffd02fc:	e3a0203b 	mov	r2, #59	; 0x3b
fffd0300:	e59f0034 	ldr	r0, [pc, #52]	; fffd033c <PrefetchAbortRoutine+0x4c>
fffd0304:	e59f3034 	ldr	r3, [pc, #52]	; fffd0340 <PrefetchAbortRoutine+0x50>
fffd0308:	e08f1001 	add	r1, pc, r1
fffd030c:	e08f0000 	add	r0, pc, r0
fffd0310:	e08f3003 	add	r3, pc, r3
fffd0314:	eb001124 	bl	fffd47ac <LogError>
fffd0318:	e59f0024 	ldr	r0, [pc, #36]	; fffd0344 <PrefetchAbortRoutine+0x54>
fffd031c:	e1a01004 	mov	r1, r4
fffd0320:	e08f0000 	add	r0, pc, r0
fffd0324:	eb001120 	bl	fffd47ac <LogError>
fffd0328:	e59f0018 	ldr	r0, [pc, #24]	; fffd0348 <PrefetchAbortRoutine+0x58>
	//exit (-1);
}
fffd032c:	e8bd4010 	pop	{r4, lr}
	//exit (-1);
}
//-------------------------------------------------------------
void PrefetchAbortRoutine (UINT32 Address)
{
	LOG_ERROR (("'Pre-fetch Abort' event has been triggered at address 0x%08lX. \n",Address));
fffd0330:	e08f0000 	add	r0, pc, r0
fffd0334:	ea0010f0 	b	fffd46fc <LogMessage>
fffd0338:	00004f6c 	.word	0x00004f6c
fffd033c:	00004f42 	.word	0x00004f42
fffd0340:	00004f29 	.word	0x00004f29
fffd0344:	00005033 	.word	0x00005033
fffd0348:	0000599c 	.word	0x0000599c

fffd034c <SvcRoutine>:
	//exit (-1);
}
//-------------------------------------------------------------
void SvcRoutine (UINT32 Address)
{
fffd034c:	e92d4010 	push	{r4, lr}
fffd0350:	e1a04000 	mov	r4, r0
	LOG_ERROR (("'SVC' event has been triggered from address 0x%08lX. \n",Address));
fffd0354:	e59f1038 	ldr	r1, [pc, #56]	; fffd0394 <SvcRoutine+0x48>
fffd0358:	e3a02041 	mov	r2, #65	; 0x41
fffd035c:	e59f0034 	ldr	r0, [pc, #52]	; fffd0398 <SvcRoutine+0x4c>
fffd0360:	e59f3034 	ldr	r3, [pc, #52]	; fffd039c <SvcRoutine+0x50>
fffd0364:	e08f1001 	add	r1, pc, r1
fffd0368:	e08f0000 	add	r0, pc, r0
fffd036c:	e08f3003 	add	r3, pc, r3
fffd0370:	eb00110d 	bl	fffd47ac <LogError>
fffd0374:	e59f0024 	ldr	r0, [pc, #36]	; fffd03a0 <SvcRoutine+0x54>
fffd0378:	e1a01004 	mov	r1, r4
fffd037c:	e08f0000 	add	r0, pc, r0
fffd0380:	eb001109 	bl	fffd47ac <LogError>
fffd0384:	e59f0018 	ldr	r0, [pc, #24]	; fffd03a4 <SvcRoutine+0x58>
	//exit (-1);
}
fffd0388:	e8bd4010 	pop	{r4, lr}
	//exit (-1);
}
//-------------------------------------------------------------
void SvcRoutine (UINT32 Address)
{
	LOG_ERROR (("'SVC' event has been triggered from address 0x%08lX. \n",Address));
fffd038c:	e08f0000 	add	r0, pc, r0
fffd0390:	ea0010d9 	b	fffd46fc <LogMessage>
fffd0394:	00004f10 	.word	0x00004f10
fffd0398:	00004ee6 	.word	0x00004ee6
fffd039c:	000056e3 	.word	0x000056e3
fffd03a0:	00005018 	.word	0x00005018
fffd03a4:	00005940 	.word	0x00005940

fffd03a8 <DataAbortRoutine>:
	LOG_ERROR (("'FIQ' event has been triggered at address 0x%08lX. \n",Address));
	//exit (-1);
}
//-------------------------------------------------------------
void DataAbortRoutine (UINT32 Address)
{
fffd03a8:	e59f305c 	ldr	r3, [pc, #92]	; fffd040c <DataAbortRoutine+0x64>
	if (g_SkipDataAbort==TRUE)
fffd03ac:	e59f205c 	ldr	r2, [pc, #92]	; fffd0410 <DataAbortRoutine+0x68>
	LOG_ERROR (("'FIQ' event has been triggered at address 0x%08lX. \n",Address));
	//exit (-1);
}
//-------------------------------------------------------------
void DataAbortRoutine (UINT32 Address)
{
fffd03b0:	e08f3003 	add	r3, pc, r3
	if (g_SkipDataAbort==TRUE)
fffd03b4:	e7933002 	ldr	r3, [r3, r2]
fffd03b8:	e5933000 	ldr	r3, [r3]
fffd03bc:	e3530001 	cmp	r3, #1
fffd03c0:	012fff1e 	bxeq	lr
	LOG_ERROR (("'FIQ' event has been triggered at address 0x%08lX. \n",Address));
	//exit (-1);
}
//-------------------------------------------------------------
void DataAbortRoutine (UINT32 Address)
{
fffd03c4:	e92d4010 	push	{r4, lr}
fffd03c8:	e1a04000 	mov	r4, r0
	if (g_SkipDataAbort==TRUE)
		return;
	LOG_ERROR (("'Data Abort' event has been triggered at address 0x%08lX. \n",Address));
fffd03cc:	e59f1040 	ldr	r1, [pc, #64]	; fffd0414 <DataAbortRoutine+0x6c>
fffd03d0:	e3a0202f 	mov	r2, #47	; 0x2f
fffd03d4:	e59f003c 	ldr	r0, [pc, #60]	; fffd0418 <DataAbortRoutine+0x70>
fffd03d8:	e59f303c 	ldr	r3, [pc, #60]	; fffd041c <DataAbortRoutine+0x74>
fffd03dc:	e08f1001 	add	r1, pc, r1
fffd03e0:	e08f0000 	add	r0, pc, r0
fffd03e4:	e08f3003 	add	r3, pc, r3
fffd03e8:	eb0010ef 	bl	fffd47ac <LogError>
fffd03ec:	e59f002c 	ldr	r0, [pc, #44]	; fffd0420 <DataAbortRoutine+0x78>
fffd03f0:	e1a01004 	mov	r1, r4
fffd03f4:	e08f0000 	add	r0, pc, r0
fffd03f8:	eb0010eb 	bl	fffd47ac <LogError>
fffd03fc:	e59f0020 	ldr	r0, [pc, #32]	; fffd0424 <DataAbortRoutine+0x7c>
	//exit (-1);
}
fffd0400:	e8bd4010 	pop	{r4, lr}
//-------------------------------------------------------------
void DataAbortRoutine (UINT32 Address)
{
	if (g_SkipDataAbort==TRUE)
		return;
	LOG_ERROR (("'Data Abort' event has been triggered at address 0x%08lX. \n",Address));
fffd0404:	e08f0000 	add	r0, pc, r0
fffd0408:	ea0010bb 	b	fffd46fc <LogMessage>
fffd040c:	00006ec8 	.word	0x00006ec8
fffd0410:	00000034 	.word	0x00000034
fffd0414:	00004e98 	.word	0x00004e98
fffd0418:	00004e6e 	.word	0x00004e6e
fffd041c:	00004e28 	.word	0x00004e28
fffd0420:	00004fd7 	.word	0x00004fd7
fffd0424:	000058c8 	.word	0x000058c8

fffd0428 <Check_BMC_PLL>:

//--------------------------------------------------------------------
// 16/02/2015: Fixed PLL function; the function always returned "PLL in reset"
// 08/04/2015: Fixed PLL_FOUT calculation so it will not overflow DWORD.
UINT32 Check_BMC_PLL (DWORD PllCon, DWORD PllIndex)
{
fffd0428:	e92d4070 	push	{r4, r5, r6, lr}
fffd042c:	e1a05000 	mov	r5, r0
	DWORD PLL_FBDV,PLL_OTDV1, PLL_OTDV2, PLL_INDV,PLL_FOUT;

	LogMessage ("  * PLLCON%u = 0x%08lX. ",PllIndex,PllCon);
fffd0430:	e59f00bc 	ldr	r0, [pc, #188]	; fffd04f4 <Check_BMC_PLL+0xcc>
fffd0434:	e1a02005 	mov	r2, r5

//--------------------------------------------------------------------
// 16/02/2015: Fixed PLL function; the function always returned "PLL in reset"
// 08/04/2015: Fixed PLL_FOUT calculation so it will not overflow DWORD.
UINT32 Check_BMC_PLL (DWORD PllCon, DWORD PllIndex)
{
fffd0438:	e1a06001 	mov	r6, r1
	DWORD PLL_FBDV,PLL_OTDV1, PLL_OTDV2, PLL_INDV,PLL_FOUT;

	LogMessage ("  * PLLCON%u = 0x%08lX. ",PllIndex,PllCon);
fffd043c:	e08f0000 	add	r0, pc, r0
fffd0440:	eb0010ad 	bl	fffd46fc <LogMessage>

	if ( ((PllCon>>12)&0x1) ==1 )
fffd0444:	e3150a01 	tst	r5, #4096	; 0x1000
fffd0448:	0a000004 	beq	fffd0460 <Check_BMC_PLL+0x38>
	{
		LogWarning (" (PLL is in Power-Down).\n");
fffd044c:	e59f00a4 	ldr	r0, [pc, #164]	; fffd04f8 <Check_BMC_PLL+0xd0>
fffd0450:	e08f0000 	add	r0, pc, r0
fffd0454:	eb0010e4 	bl	fffd47ec <LogWarning>
		return (0);
fffd0458:	e3a00000 	mov	r0, #0
fffd045c:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	PLL_FBDV = (PllCon >> 16) & 0xFFF; //  (bits 16..27, 12bit)
	PLL_OTDV1 = (PllCon >> 8) & 0x7; //  (bits 8..10, 3bit)
	PLL_OTDV2 = (PllCon >> 13) & 0x7; //  (bits 13..15, 3bit)
fffd0460:	e7e226d5 	ubfx	r2, r5, #13, #3
		LogWarning (" (PLL is in Power-Down).\n");
		return (0);
	}

	PLL_FBDV = (PllCon >> 16) & 0xFFF; //  (bits 16..27, 12bit)
	PLL_OTDV1 = (PllCon >> 8) & 0x7; //  (bits 8..10, 3bit)
fffd0464:	e7e23455 	ubfx	r3, r5, #8, #3
	PLL_OTDV2 = (PllCon >> 13) & 0x7; //  (bits 13..15, 3bit)
	PLL_INDV = (PllCon >> 0) & 0x3F; //  (bits 0..5, 6 bits)

	PLL_FOUT = 25000/*000*/ * (PLL_FBDV);
	PLL_FOUT = PLL_FOUT / ( (PLL_OTDV1) * (PLL_OTDV2) * (PLL_INDV) );
fffd0468:	e0030392 	mul	r3, r2, r3
	{
		LogWarning (" (PLL is in Power-Down).\n");
		return (0);
	}

	PLL_FBDV = (PllCon >> 16) & 0xFFF; //  (bits 16..27, 12bit)
fffd046c:	e7eb0855 	ubfx	r0, r5, #16, #12
	PLL_OTDV1 = (PllCon >> 8) & 0x7; //  (bits 8..10, 3bit)
	PLL_OTDV2 = (PllCon >> 13) & 0x7; //  (bits 13..15, 3bit)
	PLL_INDV = (PllCon >> 0) & 0x3F; //  (bits 0..5, 6 bits)

	PLL_FOUT = 25000/*000*/ * (PLL_FBDV);
	PLL_FOUT = PLL_FOUT / ( (PLL_OTDV1) * (PLL_OTDV2) * (PLL_INDV) );
fffd0470:	e30621a8 	movw	r2, #25000	; 0x61a8
	}

	PLL_FBDV = (PllCon >> 16) & 0xFFF; //  (bits 16..27, 12bit)
	PLL_OTDV1 = (PllCon >> 8) & 0x7; //  (bits 8..10, 3bit)
	PLL_OTDV2 = (PllCon >> 13) & 0x7; //  (bits 13..15, 3bit)
	PLL_INDV = (PllCon >> 0) & 0x3F; //  (bits 0..5, 6 bits)
fffd0474:	e205103f 	and	r1, r5, #63	; 0x3f

	PLL_FOUT = 25000/*000*/ * (PLL_FBDV);
	PLL_FOUT = PLL_FOUT / ( (PLL_OTDV1) * (PLL_OTDV2) * (PLL_INDV) );
fffd0478:	e0000092 	mul	r0, r2, r0
fffd047c:	e0010391 	mul	r1, r1, r3
fffd0480:	fa001218 	blx	fffd4ce8 <__aeabi_uidiv>
	if ((PllIndex==1) && (READ_REG(PDID)!=Poleg_ID_Z1))
fffd0484:	e3560001 	cmp	r6, #1
	PLL_OTDV1 = (PllCon >> 8) & 0x7; //  (bits 8..10, 3bit)
	PLL_OTDV2 = (PllCon >> 13) & 0x7; //  (bits 13..15, 3bit)
	PLL_INDV = (PllCon >> 0) & 0x3F; //  (bits 0..5, 6 bits)

	PLL_FOUT = 25000/*000*/ * (PLL_FBDV);
	PLL_FOUT = PLL_FOUT / ( (PLL_OTDV1) * (PLL_OTDV2) * (PLL_INDV) );
fffd0488:	e1a04000 	mov	r4, r0
	if ((PllIndex==1) && (READ_REG(PDID)!=Poleg_ID_Z1))
fffd048c:	1a000004 	bne	fffd04a4 <Check_BMC_PLL+0x7c>
fffd0490:	e59f3064 	ldr	r3, [pc, #100]	; fffd04fc <Check_BMC_PLL+0xd4>
fffd0494:	e5932000 	ldr	r2, [r3]
fffd0498:	e59f3060 	ldr	r3, [pc, #96]	; fffd0500 <Check_BMC_PLL+0xd8>
fffd049c:	e1520003 	cmp	r2, r3
		PLL_FOUT = PLL_FOUT /2;
fffd04a0:	11a040a0 	lsrne	r4, r0, #1
	LogMessage (" (%lu MHz; ",PLL_FOUT/1000/*000*/);
fffd04a4:	e59f2058 	ldr	r2, [pc, #88]	; fffd0504 <Check_BMC_PLL+0xdc>
fffd04a8:	e59f0058 	ldr	r0, [pc, #88]	; fffd0508 <Check_BMC_PLL+0xe0>
fffd04ac:	e0832294 	umull	r2, r3, r4, r2
fffd04b0:	e08f0000 	add	r0, pc, r0
fffd04b4:	e1a01323 	lsr	r1, r3, #6
fffd04b8:	eb00108f 	bl	fffd46fc <LogMessage>

	if ( ((PllCon>>31)&0x1) == 0 )
fffd04bc:	e3550000 	cmp	r5, #0
fffd04c0:	ba000003 	blt	fffd04d4 <Check_BMC_PLL+0xac>
		LogWarning ("PLL is not locked");
fffd04c4:	e59f0040 	ldr	r0, [pc, #64]	; fffd050c <Check_BMC_PLL+0xe4>
fffd04c8:	e08f0000 	add	r0, pc, r0
fffd04cc:	eb0010c6 	bl	fffd47ec <LogWarning>
fffd04d0:	ea000002 	b	fffd04e0 <Check_BMC_PLL+0xb8>
	else
		LogPass ("locked");
fffd04d4:	e59f0034 	ldr	r0, [pc, #52]	; fffd0510 <Check_BMC_PLL+0xe8>
fffd04d8:	e08f0000 	add	r0, pc, r0
fffd04dc:	eb0010d2 	bl	fffd482c <LogPass>

	LogMessage (")\n");
fffd04e0:	e59f002c 	ldr	r0, [pc, #44]	; fffd0514 <Check_BMC_PLL+0xec>
fffd04e4:	e08f0000 	add	r0, pc, r0
fffd04e8:	eb001083 	bl	fffd46fc <LogMessage>

	return (PLL_FOUT); // clock in KHz
fffd04ec:	e1a00004 	mov	r0, r4
}
fffd04f0:	e8bd8070 	pop	{r4, r5, r6, pc}
fffd04f4:	00004fcb 	.word	0x00004fcb
fffd04f8:	00004fd0 	.word	0x00004fd0
fffd04fc:	f0800000 	.word	0xf0800000
fffd0500:	00a92750 	.word	0x00a92750
fffd0504:	10624dd3 	.word	0x10624dd3
fffd0508:	00004f8a 	.word	0x00004f8a
fffd050c:	00004f7e 	.word	0x00004f7e
fffd0510:	00004f79 	.word	0x00004f79
fffd0514:	00006262 	.word	0x00006262

fffd0518 <Check_Clocks>:
//--------------------------------------------------------------------------
void Check_Clocks (void)
{
	UINT32 ClkSel,ClkDiv1,ClkDiv2,ClkDiv3;

	LogMessage ("> PLLs and Clocks: \n");
fffd0518:	e59f0200 	ldr	r0, [pc, #512]	; fffd0720 <Check_Clocks+0x208>

	return (PLL_FOUT); // clock in KHz
}
//--------------------------------------------------------------------------
void Check_Clocks (void)
{
fffd051c:	e92d4038 	push	{r3, r4, r5, lr}
	UINT32 ClkSel,ClkDiv1,ClkDiv2,ClkDiv3;

	LogMessage ("> PLLs and Clocks: \n");

	PLL0_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON0),0);
fffd0520:	e59f41fc 	ldr	r4, [pc, #508]	; fffd0724 <Check_Clocks+0x20c>
//--------------------------------------------------------------------------
void Check_Clocks (void)
{
	UINT32 ClkSel,ClkDiv1,ClkDiv2,ClkDiv3;

	LogMessage ("> PLLs and Clocks: \n");
fffd0524:	e08f0000 	add	r0, pc, r0
fffd0528:	eb001073 	bl	fffd46fc <LogMessage>

	return (PLL_FOUT); // clock in KHz
}
//--------------------------------------------------------------------------
void Check_Clocks (void)
{
fffd052c:	e59f51f4 	ldr	r5, [pc, #500]	; fffd0728 <Check_Clocks+0x210>
	UINT32 ClkSel,ClkDiv1,ClkDiv2,ClkDiv3;

	LogMessage ("> PLLs and Clocks: \n");

	PLL0_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON0),0);
fffd0530:	e3a01000 	mov	r1, #0
fffd0534:	e594000c 	ldr	r0, [r4, #12]
fffd0538:	ebffffba 	bl	fffd0428 <Check_BMC_PLL>
fffd053c:	e59f31e8 	ldr	r3, [pc, #488]	; fffd072c <Check_Clocks+0x214>

	return (PLL_FOUT); // clock in KHz
}
//--------------------------------------------------------------------------
void Check_Clocks (void)
{
fffd0540:	e08f5005 	add	r5, pc, r5
	UINT32 ClkSel,ClkDiv1,ClkDiv2,ClkDiv3;

	LogMessage ("> PLLs and Clocks: \n");

	PLL0_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON0),0);
	PLL1_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON1),1);
fffd0544:	e3a01001 	mov	r1, #1
{
	UINT32 ClkSel,ClkDiv1,ClkDiv2,ClkDiv3;

	LogMessage ("> PLLs and Clocks: \n");

	PLL0_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON0),0);
fffd0548:	e7953003 	ldr	r3, [r5, r3]
fffd054c:	e5830000 	str	r0, [r3]
	PLL1_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON1),1);
fffd0550:	e5940010 	ldr	r0, [r4, #16]
fffd0554:	ebffffb3 	bl	fffd0428 <Check_BMC_PLL>
fffd0558:	e59f31d0 	ldr	r3, [pc, #464]	; fffd0730 <Check_Clocks+0x218>
	PLL2_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON2),2);
fffd055c:	e3a01002 	mov	r1, #2
	UINT32 ClkSel,ClkDiv1,ClkDiv2,ClkDiv3;

	LogMessage ("> PLLs and Clocks: \n");

	PLL0_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON0),0);
	PLL1_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON1),1);
fffd0560:	e7953003 	ldr	r3, [r5, r3]
fffd0564:	e5830000 	str	r0, [r3]
	PLL2_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON2),2);
fffd0568:	e5940054 	ldr	r0, [r4, #84]	; 0x54
fffd056c:	ebffffad 	bl	fffd0428 <Check_BMC_PLL>
fffd0570:	e59f31bc 	ldr	r3, [pc, #444]	; fffd0734 <Check_Clocks+0x21c>
fffd0574:	e7953003 	ldr	r3, [r5, r3]
fffd0578:	e5830000 	str	r0, [r3]
	ClkSel = READ_REG (CLKSEL);
	LogMessage ("  * CLKSEL = 0x%08lX \n", ClkSel);
fffd057c:	e59f01b4 	ldr	r0, [pc, #436]	; fffd0738 <Check_Clocks+0x220>
	LogMessage ("> PLLs and Clocks: \n");

	PLL0_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON0),0);
	PLL1_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON1),1);
	PLL2_Freq_In_KHz = Check_BMC_PLL (READ_REG (PLLCON2),2);
	ClkSel = READ_REG (CLKSEL);
fffd0580:	e5945004 	ldr	r5, [r4, #4]
	LogMessage ("  * CLKSEL = 0x%08lX \n", ClkSel);
fffd0584:	e08f0000 	add	r0, pc, r0
fffd0588:	e1a01005 	mov	r1, r5
fffd058c:	eb00105a 	bl	fffd46fc <LogMessage>
	//----------------------------------------
	LogMessage ("    - CPU Clock Source (CPUCKSEL) => ");
fffd0590:	e59f01a4 	ldr	r0, [pc, #420]	; fffd073c <Check_Clocks+0x224>
fffd0594:	e08f0000 	add	r0, pc, r0
fffd0598:	eb001057 	bl	fffd46fc <LogMessage>
	switch ((ClkSel>>0)&0x03)
fffd059c:	e2053003 	and	r3, r5, #3
fffd05a0:	e3530002 	cmp	r3, #2
fffd05a4:	0a000008 	beq	fffd05cc <Check_Clocks+0xb4>
fffd05a8:	e3530003 	cmp	r3, #3
fffd05ac:	0a000009 	beq	fffd05d8 <Check_Clocks+0xc0>
fffd05b0:	e3530001 	cmp	r3, #1
	{
	case 0:
		LogPass ("PLL 0. \n");
fffd05b4:	159f0184 	ldrne	r0, [pc, #388]	; fffd0740 <Check_Clocks+0x228>
fffd05b8:	108f0000 	addne	r0, pc, r0
		break;
	case 1:
		LogPass ("PLL 1. \n");
fffd05bc:	059f0180 	ldreq	r0, [pc, #384]	; fffd0744 <Check_Clocks+0x22c>
fffd05c0:	008f0000 	addeq	r0, pc, r0
fffd05c4:	eb001098 	bl	fffd482c <LogPass>
		// 25-MAR-2017: move these code line to MC_Drv.c just before PLL1 configuration 
		//LogWarning (" -- Override setting and set CPU cock source to PLL0. \n");
		//Sleep (1000); // wait for all UART data to be send to console (in case CPU will stuck user will be able to see this note) 
		//WRITE_REG (CLKSEL,ClkSel&0xFFFFFFFC);
		break;
fffd05c8:	ea000005 	b	fffd05e4 <Check_Clocks+0xcc>
	case 2:
		LogWarning ("CLKREF clock (debug). \n");
fffd05cc:	e59f0174 	ldr	r0, [pc, #372]	; fffd0748 <Check_Clocks+0x230>
fffd05d0:	e08f0000 	add	r0, pc, r0
fffd05d4:	ea000001 	b	fffd05e0 <Check_Clocks+0xc8>
		break;
	case 3:
		LogWarning ("Bypass clock from pin SYSBPCK (debug). \n");
fffd05d8:	e59f016c 	ldr	r0, [pc, #364]	; fffd074c <Check_Clocks+0x234>
fffd05dc:	e08f0000 	add	r0, pc, r0
fffd05e0:	eb001081 	bl	fffd47ec <LogWarning>
	default :
		LOG_ERROR  (("Invalid source."));
		exit (-1);
	}
	//----------------------------------------
	LogMessage ("    - Memory Controller Clock Source (MCCKSEL) => ");
fffd05e4:	e59f0164 	ldr	r0, [pc, #356]	; fffd0750 <Check_Clocks+0x238>
	switch ((ClkSel>>12)&0x03)
fffd05e8:	e7e15655 	ubfx	r5, r5, #12, #2
	default :
		LOG_ERROR  (("Invalid source."));
		exit (-1);
	}
	//----------------------------------------
	LogMessage ("    - Memory Controller Clock Source (MCCKSEL) => ");
fffd05ec:	e08f0000 	add	r0, pc, r0
fffd05f0:	eb001041 	bl	fffd46fc <LogMessage>
	switch ((ClkSel>>12)&0x03)
fffd05f4:	e3550002 	cmp	r5, #2
fffd05f8:	0a000007 	beq	fffd061c <Check_Clocks+0x104>
fffd05fc:	e3550003 	cmp	r5, #3
fffd0600:	0a000008 	beq	fffd0628 <Check_Clocks+0x110>
fffd0604:	e3550000 	cmp	r5, #0
fffd0608:	1a00000a 	bne	fffd0638 <Check_Clocks+0x120>
	{
	case 0:
		LogPass ("PLL 1. \n");
fffd060c:	e59f0140 	ldr	r0, [pc, #320]	; fffd0754 <Check_Clocks+0x23c>
fffd0610:	e08f0000 	add	r0, pc, r0
fffd0614:	eb001084 	bl	fffd482c <LogPass>
		break;
fffd0618:	ea000016 	b	fffd0678 <Check_Clocks+0x160>
	case 2:
		LogWarning ("CLKREF Clock (debug). \n");
fffd061c:	e59f0134 	ldr	r0, [pc, #308]	; fffd0758 <Check_Clocks+0x240>
fffd0620:	e08f0000 	add	r0, pc, r0
fffd0624:	ea000001 	b	fffd0630 <Check_Clocks+0x118>
		break;
	case 3:
		LogWarning ("MCBPCK Clock (debug). \n");
fffd0628:	e59f012c 	ldr	r0, [pc, #300]	; fffd075c <Check_Clocks+0x244>
fffd062c:	e08f0000 	add	r0, pc, r0
fffd0630:	eb00106d 	bl	fffd47ec <LogWarning>
		break;
fffd0634:	ea00000f 	b	fffd0678 <Check_Clocks+0x160>
	default :
		LOG_ERROR  (("Invalid source."));
fffd0638:	e59f0120 	ldr	r0, [pc, #288]	; fffd0760 <Check_Clocks+0x248>
fffd063c:	e300211b 	movw	r2, #283	; 0x11b
fffd0640:	e59f111c 	ldr	r1, [pc, #284]	; fffd0764 <Check_Clocks+0x24c>
fffd0644:	e59f311c 	ldr	r3, [pc, #284]	; fffd0768 <Check_Clocks+0x250>
fffd0648:	e08f0000 	add	r0, pc, r0
fffd064c:	e08f1001 	add	r1, pc, r1
fffd0650:	e08f3003 	add	r3, pc, r3
fffd0654:	eb001054 	bl	fffd47ac <LogError>
fffd0658:	e59f010c 	ldr	r0, [pc, #268]	; fffd076c <Check_Clocks+0x254>
fffd065c:	e08f0000 	add	r0, pc, r0
fffd0660:	eb001051 	bl	fffd47ac <LogError>
fffd0664:	e59f0104 	ldr	r0, [pc, #260]	; fffd0770 <Check_Clocks+0x258>
fffd0668:	e08f0000 	add	r0, pc, r0
fffd066c:	eb001022 	bl	fffd46fc <LogMessage>
		exit (-1);
fffd0670:	e3e00000 	mvn	r0, #0
fffd0674:	eb000f7b 	bl	fffd4468 <exit>
	}
	//----------------------------------------

	//----------------------------------------
	ClkDiv1 = READ_REG (CLKDIV1);
fffd0678:	e5945008 	ldr	r5, [r4, #8]
	LogMessage ("  * CLKDIV1 = 0x%08lX \n",ClkDiv1);
fffd067c:	e59f00f0 	ldr	r0, [pc, #240]	; fffd0774 <Check_Clocks+0x25c>
fffd0680:	e1a01005 	mov	r1, r5
fffd0684:	e08f0000 	add	r0, pc, r0
fffd0688:	eb00101b 	bl	fffd46fc <LogMessage>
	if ((ClkDiv1&0x1)==0)
fffd068c:	e3150001 	tst	r5, #1
fffd0690:	1a000003 	bne	fffd06a4 <Check_Clocks+0x18c>
		LogWarning ("    - CLK2(AXI16) = CPU clock. \n");
fffd0694:	e59f00dc 	ldr	r0, [pc, #220]	; fffd0778 <Check_Clocks+0x260>
fffd0698:	e08f0000 	add	r0, pc, r0
fffd069c:	eb001052 	bl	fffd47ec <LogWarning>
fffd06a0:	ea000002 	b	fffd06b0 <Check_Clocks+0x198>
	else
		LogPass ("    - CLK2(AXI16) = CPU clock /2.  \n");
fffd06a4:	e59f00d0 	ldr	r0, [pc, #208]	; fffd077c <Check_Clocks+0x264>
fffd06a8:	e08f0000 	add	r0, pc, r0
fffd06ac:	eb00105e 	bl	fffd482c <LogPass>
	switch ((ClkDiv1>>26)&0x03)
fffd06b0:	e7e15d55 	ubfx	r5, r5, #26, #2
fffd06b4:	e3550002 	cmp	r5, #2
fffd06b8:	0a000009 	beq	fffd06e4 <Check_Clocks+0x1cc>
fffd06bc:	e3550003 	cmp	r5, #3
fffd06c0:	0a00000a 	beq	fffd06f0 <Check_Clocks+0x1d8>
fffd06c4:	e3550001 	cmp	r5, #1
	{
	case 0:
		LogWarning ("    - CLK4 = CLK2) \n");
fffd06c8:	159f00b0 	ldrne	r0, [pc, #176]	; fffd0780 <Check_Clocks+0x268>
fffd06cc:	108f0000 	addne	r0, pc, r0
fffd06d0:	1a000008 	bne	fffd06f8 <Check_Clocks+0x1e0>
		break;
	case 1:
		LogPass ("    - CLK4 = CLK2/2) \n");
fffd06d4:	e59f00a8 	ldr	r0, [pc, #168]	; fffd0784 <Check_Clocks+0x26c>
fffd06d8:	e08f0000 	add	r0, pc, r0
fffd06dc:	eb001052 	bl	fffd482c <LogPass>
		break;
fffd06e0:	ea000005 	b	fffd06fc <Check_Clocks+0x1e4>
	case 2:
		LogWarning ("    - CLK4 = CLK2/3) \n");
fffd06e4:	e59f009c 	ldr	r0, [pc, #156]	; fffd0788 <Check_Clocks+0x270>
fffd06e8:	e08f0000 	add	r0, pc, r0
fffd06ec:	ea000001 	b	fffd06f8 <Check_Clocks+0x1e0>
		break;
	case 3:
		LogWarning ("    - CLK4 = CLK2/4) \n");
fffd06f0:	e59f0094 	ldr	r0, [pc, #148]	; fffd078c <Check_Clocks+0x274>
fffd06f4:	e08f0000 	add	r0, pc, r0
fffd06f8:	eb00103b 	bl	fffd47ec <LogWarning>
		break;
	}
	ClkDiv2 = READ_REG (CLKDIV2);
	LogMessage ("  * CLKDIV2 = 0x%08lX \n",ClkDiv2);
fffd06fc:	e59f008c 	ldr	r0, [pc, #140]	; fffd0790 <Check_Clocks+0x278>
		break;
	case 3:
		LogWarning ("    - CLK4 = CLK2/4) \n");
		break;
	}
	ClkDiv2 = READ_REG (CLKDIV2);
fffd0700:	e594102c 	ldr	r1, [r4, #44]	; 0x2c
	LogMessage ("  * CLKDIV2 = 0x%08lX \n",ClkDiv2);
fffd0704:	e08f0000 	add	r0, pc, r0
fffd0708:	eb000ffb 	bl	fffd46fc <LogMessage>
	ClkDiv3 = READ_REG (CLKDIV3);
	LogMessage ("  * CLKDIV3 = 0x%08lX \n",ClkDiv3);
fffd070c:	e59f0080 	ldr	r0, [pc, #128]	; fffd0794 <Check_Clocks+0x27c>
		LogWarning ("    - CLK4 = CLK2/4) \n");
		break;
	}
	ClkDiv2 = READ_REG (CLKDIV2);
	LogMessage ("  * CLKDIV2 = 0x%08lX \n",ClkDiv2);
	ClkDiv3 = READ_REG (CLKDIV3);
fffd0710:	e5941058 	ldr	r1, [r4, #88]	; 0x58
	LogMessage ("  * CLKDIV3 = 0x%08lX \n",ClkDiv3);
	//----------------------------------------
} 
fffd0714:	e8bd4038 	pop	{r3, r4, r5, lr}
		break;
	}
	ClkDiv2 = READ_REG (CLKDIV2);
	LogMessage ("  * CLKDIV2 = 0x%08lX \n",ClkDiv2);
	ClkDiv3 = READ_REG (CLKDIV3);
	LogMessage ("  * CLKDIV3 = 0x%08lX \n",ClkDiv3);
fffd0718:	e08f0000 	add	r0, pc, r0
fffd071c:	ea000ff6 	b	fffd46fc <LogMessage>
fffd0720:	00004f34 	.word	0x00004f34
fffd0724:	f0801000 	.word	0xf0801000
fffd0728:	00006d38 	.word	0x00006d38
fffd072c:	00000030 	.word	0x00000030
fffd0730:	0000002c 	.word	0x0000002c
fffd0734:	00000048 	.word	0x00000048
fffd0738:	00004ee9 	.word	0x00004ee9
fffd073c:	00004ef0 	.word	0x00004ef0
fffd0740:	00004ef2 	.word	0x00004ef2
fffd0744:	00004ef3 	.word	0x00004ef3
fffd0748:	00004eec 	.word	0x00004eec
fffd074c:	00004ef8 	.word	0x00004ef8
fffd0750:	00004f11 	.word	0x00004f11
fffd0754:	00004ea3 	.word	0x00004ea3
fffd0758:	00004f10 	.word	0x00004f10
fffd075c:	00004f1c 	.word	0x00004f1c
fffd0760:	00004c06 	.word	0x00004c06
fffd0764:	00004c28 	.word	0x00004c28
fffd0768:	00005420 	.word	0x00005420
fffd076c:	00004f04 	.word	0x00004f04
fffd0770:	00005664 	.word	0x00005664
fffd0774:	00004eec 	.word	0x00004eec
fffd0778:	00004ef0 	.word	0x00004ef0
fffd077c:	00004f01 	.word	0x00004f01
fffd0780:	00004f02 	.word	0x00004f02
fffd0784:	00004f0b 	.word	0x00004f0b
fffd0788:	00004f12 	.word	0x00004f12
fffd078c:	00004f1d 	.word	0x00004f1d
fffd0790:	00004f24 	.word	0x00004f24
fffd0794:	00004f28 	.word	0x00004f28

fffd0798 <main>:

UINT32 PLL0_Freq_In_KHz, PLL1_Freq_In_KHz, PLL2_Freq_In_KHz;

//-------------------------------------------------------------
int main (void)
{
fffd0798:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
fffd079c:	e59f4298 	ldr	r4, [pc, #664]	; fffd0a3c <main+0x2a4>
		LogWarning ("start-up code failed to initialize data variables ! \n");
		exit (-1);
	}
	*/
	//-------------------------------------------------------------
	CP15_READ (SCTLR_reg, 0, c1, c0, 0);
fffd07a0:	ee115f10 	mrc	15, 0, r5, cr1, cr0, {0}
int main (void)
{
	UINT32 SCTLR_reg;
	int status;
	
	Uart_AutoDetect ();
fffd07a4:	eb001079 	bl	fffd4990 <Uart_AutoDetect>

	//---------------------------------
	// At start-up, all interrupts vectors are assign to error() function (this assuming code is loaded at 0x0000_0000 and core vectore table is at 0x0000_0000; or code is loaded at 0xFFFD_0000, core vectore table is at 0xFFFF_0000 and RAM2 first 256 bytes swap is enabled).
	pDataAbortRoutine = (INT_ROUTINE) DataAbortRoutine;
fffd07a8:	e59f3290 	ldr	r3, [pc, #656]	; fffd0a40 <main+0x2a8>

UINT32 PLL0_Freq_In_KHz, PLL1_Freq_In_KHz, PLL2_Freq_In_KHz;

//-------------------------------------------------------------
int main (void)
{
fffd07ac:	e08f4004 	add	r4, pc, r4
	
	Uart_AutoDetect ();

	//---------------------------------
	// At start-up, all interrupts vectors are assign to error() function (this assuming code is loaded at 0x0000_0000 and core vectore table is at 0x0000_0000; or code is loaded at 0xFFFD_0000, core vectore table is at 0xFFFF_0000 and RAM2 first 256 bytes swap is enabled).
	pDataAbortRoutine = (INT_ROUTINE) DataAbortRoutine;
fffd07b0:	e59f228c 	ldr	r2, [pc, #652]	; fffd0a44 <main+0x2ac>
	pFiqRoutine =  (INT_ROUTINE) FiqRoutine;
	pIrqRoutine =  (INT_ROUTINE) IrqRoutine;
	g_SkipDataAbort = FALSE;
	//---------------------------------

	LogMessage ("\n\n");
fffd07b4:	e59f028c 	ldr	r0, [pc, #652]	; fffd0a48 <main+0x2b0>
	
	Uart_AutoDetect ();

	//---------------------------------
	// At start-up, all interrupts vectors are assign to error() function (this assuming code is loaded at 0x0000_0000 and core vectore table is at 0x0000_0000; or code is loaded at 0xFFFD_0000, core vectore table is at 0xFFFF_0000 and RAM2 first 256 bytes swap is enabled).
	pDataAbortRoutine = (INT_ROUTINE) DataAbortRoutine;
fffd07b8:	e7943003 	ldr	r3, [r4, r3]
fffd07bc:	e08f2002 	add	r2, pc, r2
	pFiqRoutine =  (INT_ROUTINE) FiqRoutine;
	pIrqRoutine =  (INT_ROUTINE) IrqRoutine;
	g_SkipDataAbort = FALSE;
	//---------------------------------

	LogMessage ("\n\n");
fffd07c0:	e08f0000 	add	r0, pc, r0
	
	Uart_AutoDetect ();

	//---------------------------------
	// At start-up, all interrupts vectors are assign to error() function (this assuming code is loaded at 0x0000_0000 and core vectore table is at 0x0000_0000; or code is loaded at 0xFFFD_0000, core vectore table is at 0xFFFF_0000 and RAM2 first 256 bytes swap is enabled).
	pDataAbortRoutine = (INT_ROUTINE) DataAbortRoutine;
fffd07c4:	e5832000 	str	r2, [r3]
	pUndefinedInstructionRoutine = (INT_ROUTINE) UndefinedInstructionRoutine;
fffd07c8:	e59f327c 	ldr	r3, [pc, #636]	; fffd0a4c <main+0x2b4>
fffd07cc:	e59f227c 	ldr	r2, [pc, #636]	; fffd0a50 <main+0x2b8>
fffd07d0:	e7943003 	ldr	r3, [r4, r3]
fffd07d4:	e08f2002 	add	r2, pc, r2
fffd07d8:	e5832000 	str	r2, [r3]
	pPrefetchAbortRoutine = (INT_ROUTINE) PrefetchAbortRoutine;
fffd07dc:	e59f3270 	ldr	r3, [pc, #624]	; fffd0a54 <main+0x2bc>
fffd07e0:	e59f2270 	ldr	r2, [pc, #624]	; fffd0a58 <main+0x2c0>
fffd07e4:	e7943003 	ldr	r3, [r4, r3]
fffd07e8:	e08f2002 	add	r2, pc, r2
fffd07ec:	e5832000 	str	r2, [r3]
	pSvcRoutine =  (INT_ROUTINE) SvcRoutine;
fffd07f0:	e59f3264 	ldr	r3, [pc, #612]	; fffd0a5c <main+0x2c4>
fffd07f4:	e59f2264 	ldr	r2, [pc, #612]	; fffd0a60 <main+0x2c8>
fffd07f8:	e7943003 	ldr	r3, [r4, r3]
fffd07fc:	e08f2002 	add	r2, pc, r2
fffd0800:	e5832000 	str	r2, [r3]
	pFiqRoutine =  (INT_ROUTINE) FiqRoutine;
fffd0804:	e59f3258 	ldr	r3, [pc, #600]	; fffd0a64 <main+0x2cc>
fffd0808:	e59f2258 	ldr	r2, [pc, #600]	; fffd0a68 <main+0x2d0>
fffd080c:	e7943003 	ldr	r3, [r4, r3]
fffd0810:	e08f2002 	add	r2, pc, r2
fffd0814:	e5832000 	str	r2, [r3]
	pIrqRoutine =  (INT_ROUTINE) IrqRoutine;
fffd0818:	e59f324c 	ldr	r3, [pc, #588]	; fffd0a6c <main+0x2d4>
fffd081c:	e59f224c 	ldr	r2, [pc, #588]	; fffd0a70 <main+0x2d8>
fffd0820:	e7943003 	ldr	r3, [r4, r3]
fffd0824:	e08f2002 	add	r2, pc, r2
fffd0828:	e5832000 	str	r2, [r3]
	g_SkipDataAbort = FALSE;
fffd082c:	e3a02000 	mov	r2, #0
fffd0830:	e59f323c 	ldr	r3, [pc, #572]	; fffd0a74 <main+0x2dc>
fffd0834:	e7943003 	ldr	r3, [r4, r3]
fffd0838:	e5832000 	str	r2, [r3]
	//---------------------------------

	LogMessage ("\n\n");
fffd083c:	eb000fae 	bl	fffd46fc <LogMessage>
	LogHeader (" Build Date: %s,%s with GCC %u.%u.%u ",__DATE__,__TIME__,__GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__);
fffd0840:	e3a02009 	mov	r2, #9
fffd0844:	e3a03003 	mov	r3, #3
fffd0848:	e88d000c 	stm	sp, {r2, r3}
fffd084c:	e3a03004 	mov	r3, #4
fffd0850:	e59f0220 	ldr	r0, [pc, #544]	; fffd0a78 <main+0x2e0>
fffd0854:	e59f1220 	ldr	r1, [pc, #544]	; fffd0a7c <main+0x2e4>
fffd0858:	e59f2220 	ldr	r2, [pc, #544]	; fffd0a80 <main+0x2e8>
fffd085c:	e08f0000 	add	r0, pc, r0
fffd0860:	e08f1001 	add	r1, pc, r1
fffd0864:	e08f2002 	add	r2, pc, r2
fffd0868:	eb000fff 	bl	fffd486c <LogHeader>
	//CP15_READ (SCTLR_reg, 0, c1, c0, 0);
	//SCTLR_reg &= ~((UINT32)1<<12);
	//CP15_WRITE (SCTLR_reg ,0, c1, c0, 0);
	//-------------------------------------------------------------
	// Invalidate Instruction cache.
	InvalidateCache ();
fffd086c:	eb0010a1 	bl	fffd4af8 <InvalidateCache>
		exit (-1);
	}
	*/
	//-------------------------------------------------------------
	CP15_READ (SCTLR_reg, 0, c1, c0, 0);
	codestartup = (UINT32)&_startup; // !! codestartup Must be volatile and _startup extern !! otherwise compiler remove some code
fffd0870:	e59f320c 	ldr	r3, [pc, #524]	; fffd0a84 <main+0x2ec>
fffd0874:	e7942003 	ldr	r2, [r4, r3]
fffd0878:	e59f3208 	ldr	r3, [pc, #520]	; fffd0a88 <main+0x2f0>
fffd087c:	e7943003 	ldr	r3, [r4, r3]
fffd0880:	e59f4204 	ldr	r4, [pc, #516]	; fffd0a8c <main+0x2f4>
fffd0884:	e5832000 	str	r2, [r3]
	if (codestartup == 0)
fffd0888:	e5932000 	ldr	r2, [r3]
fffd088c:	e3520000 	cmp	r2, #0
fffd0890:	1a000009 	bne	fffd08bc <main+0x124>
	{
		if (((SCTLR_reg>>13)&0x1) != 0) 	
fffd0894:	e3150a02 	tst	r5, #8192	; 0x2000
fffd0898:	0a000022 	beq	fffd0928 <main+0x190>
		{
			LogWarning ("> Override vector table.\n");
fffd089c:	e59f01ec 	ldr	r0, [pc, #492]	; fffd0a90 <main+0x2f8>
			LogWarning ("  >> Set CPU vector table to address 0x0000_0000. \n");
			SCTLR_reg &= ~((UINT32)1<<13); // set vector table into address 0x0000_0000
fffd08a0:	e3c55a02 	bic	r5, r5, #8192	; 0x2000
	codestartup = (UINT32)&_startup; // !! codestartup Must be volatile and _startup extern !! otherwise compiler remove some code
	if (codestartup == 0)
	{
		if (((SCTLR_reg>>13)&0x1) != 0) 	
		{
			LogWarning ("> Override vector table.\n");
fffd08a4:	e08f0000 	add	r0, pc, r0
fffd08a8:	eb000fcf 	bl	fffd47ec <LogWarning>
			LogWarning ("  >> Set CPU vector table to address 0x0000_0000. \n");
fffd08ac:	e59f01e0 	ldr	r0, [pc, #480]	; fffd0a94 <main+0x2fc>
fffd08b0:	e08f0000 	add	r0, pc, r0
fffd08b4:	eb000fcc 	bl	fffd47ec <LogWarning>
fffd08b8:	ea000011 	b	fffd0904 <main+0x16c>
			SCTLR_reg &= ~((UINT32)1<<13); // set vector table into address 0x0000_0000
			CP15_WRITE (SCTLR_reg, 0, c1, c0, 0);
		}
	}
	else if (codestartup == 0xFFFD0000)
fffd08bc:	e5932000 	ldr	r2, [r3]
fffd08c0:	e3720803 	cmn	r2, #196608	; 0x30000
fffd08c4:	1a000010 	bne	fffd090c <main+0x174>
	{
		if (((SCTLR_reg>>13)&0x1) == 0) 	
fffd08c8:	e3150a02 	tst	r5, #8192	; 0x2000
fffd08cc:	1a000015 	bne	fffd0928 <main+0x190>
		{
			LogWarning ("> Override vector table.\n");
fffd08d0:	e59f01c0 	ldr	r0, [pc, #448]	; fffd0a98 <main+0x300>
			LogWarning ("  >> Mapped first 256 bytes of address 0xFFFF_0000 to address 0xFFFD_0000. \n");
			SET_BIT_REG (FLOCKR1,18); // RAM2 first 256 bytes are mapped to address range FFFF_0000h to FFFF_00FFh.
			LogWarning ("  >> Set CPU vector table to address 0xFFFF_0000. \n");
			SCTLR_reg |= ((UINT32)1<<13); // set vector table into address 0xFFFF_0000
fffd08d4:	e3855a02 	orr	r5, r5, #8192	; 0x2000
	}
	else if (codestartup == 0xFFFD0000)
	{
		if (((SCTLR_reg>>13)&0x1) == 0) 	
		{
			LogWarning ("> Override vector table.\n");
fffd08d8:	e08f0000 	add	r0, pc, r0
fffd08dc:	eb000fc2 	bl	fffd47ec <LogWarning>
			LogWarning ("  >> Mapped first 256 bytes of address 0xFFFF_0000 to address 0xFFFD_0000. \n");
fffd08e0:	e59f01b4 	ldr	r0, [pc, #436]	; fffd0a9c <main+0x304>
fffd08e4:	e08f0000 	add	r0, pc, r0
fffd08e8:	eb000fbf 	bl	fffd47ec <LogWarning>
			SET_BIT_REG (FLOCKR1,18); // RAM2 first 256 bytes are mapped to address range FFFF_0000h to FFFF_00FFh.
fffd08ec:	e5943074 	ldr	r3, [r4, #116]	; 0x74
			LogWarning ("  >> Set CPU vector table to address 0xFFFF_0000. \n");
fffd08f0:	e59f01a8 	ldr	r0, [pc, #424]	; fffd0aa0 <main+0x308>
	{
		if (((SCTLR_reg>>13)&0x1) == 0) 	
		{
			LogWarning ("> Override vector table.\n");
			LogWarning ("  >> Mapped first 256 bytes of address 0xFFFF_0000 to address 0xFFFD_0000. \n");
			SET_BIT_REG (FLOCKR1,18); // RAM2 first 256 bytes are mapped to address range FFFF_0000h to FFFF_00FFh.
fffd08f4:	e3833701 	orr	r3, r3, #262144	; 0x40000
fffd08f8:	e5843074 	str	r3, [r4, #116]	; 0x74
			LogWarning ("  >> Set CPU vector table to address 0xFFFF_0000. \n");
fffd08fc:	e08f0000 	add	r0, pc, r0
fffd0900:	eb000fb9 	bl	fffd47ec <LogWarning>
			SCTLR_reg |= ((UINT32)1<<13); // set vector table into address 0xFFFF_0000
			CP15_WRITE (SCTLR_reg, 0, c1, c0, 0);
fffd0904:	ee015f10 	mcr	15, 0, r5, cr1, cr0, {0}
fffd0908:	ea000006 	b	fffd0928 <main+0x190>
		}
	}
	else
	{
		LogWarning ("> Code start-up at address 0x%08lX. \n",codestartup);
fffd090c:	e59f0190 	ldr	r0, [pc, #400]	; fffd0aa4 <main+0x30c>
fffd0910:	e5931000 	ldr	r1, [r3]
fffd0914:	e08f0000 	add	r0, pc, r0
fffd0918:	eb000fb3 	bl	fffd47ec <LogWarning>
		LogWarning ("  Code was not compiled to address 0x00000000 or 0xFFFD0000; interrupts will not work unless code vector table are copied ! \n");
fffd091c:	e59f0184 	ldr	r0, [pc, #388]	; fffd0aa8 <main+0x310>
fffd0920:	e08f0000 	add	r0, pc, r0
fffd0924:	eb000fb0 	bl	fffd47ec <LogWarning>
	}
	//-------------------------------------------------------------
	LogMessage ("\n");
fffd0928:	e59f017c 	ldr	r0, [pc, #380]	; fffd0aac <main+0x314>
fffd092c:	e08f0000 	add	r0, pc, r0
fffd0930:	eb000f71 	bl	fffd46fc <LogMessage>
	LogHeader (" BMC Information ");
fffd0934:	e59f0174 	ldr	r0, [pc, #372]	; fffd0ab0 <main+0x318>
fffd0938:	e08f0000 	add	r0, pc, r0
fffd093c:	eb000fca 	bl	fffd486c <LogHeader>
	//-------------------------------------------------------------
	UINT32 PDID_reg = READ_REG(PDID);
fffd0940:	e5941000 	ldr	r1, [r4]
	switch (PDID_reg) 
fffd0944:	e59f3168 	ldr	r3, [pc, #360]	; fffd0ab4 <main+0x31c>
fffd0948:	e1510003 	cmp	r1, r3
fffd094c:	0a000003 	beq	fffd0960 <main+0x1c8>
fffd0950:	e2833301 	add	r3, r3, #67108864	; 0x4000000
fffd0954:	e1510003 	cmp	r1, r3
fffd0958:	0a000004 	beq	fffd0970 <main+0x1d8>
fffd095c:	ea000010 	b	fffd09a4 <main+0x20c>
	{
		case Poleg_ID_Z1:	LogError ("> Error: Found NPCM7mnx BMC chip version Z1.\n");	return (1); 
fffd0960:	e59f0150 	ldr	r0, [pc, #336]	; fffd0ab8 <main+0x320>
fffd0964:	e08f0000 	add	r0, pc, r0
fffd0968:	eb000f8f 	bl	fffd47ac <LogError>
fffd096c:	ea00002f 	b	fffd0a30 <main+0x298>
		case Poleg_ID_Z2:	LogPass ("> Found NPCM7mnx BMC chip version A1.\n");	break;
fffd0970:	e59f0144 	ldr	r0, [pc, #324]	; fffd0abc <main+0x324>
			LogError ("Error: Unknown NPCM7mnx BMC chip version. Found PDID=0x%08lX\n", PDID_reg); return (1);  
	}
	//-------------------------------------------------------------
	//--------------------------------------------------------------
	// read SCTLR register
	CP15_READ (SCTLR_reg, 0, c1, c0, 0);
fffd0974:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	//-------------------------------------------------------------
	UINT32 PDID_reg = READ_REG(PDID);
	switch (PDID_reg) 
	{
		case Poleg_ID_Z1:	LogError ("> Error: Found NPCM7mnx BMC chip version Z1.\n");	return (1); 
		case Poleg_ID_Z2:	LogPass ("> Found NPCM7mnx BMC chip version A1.\n");	break;
fffd0978:	e08f0000 	add	r0, pc, r0
fffd097c:	eb000faa 	bl	fffd482c <LogPass>
	}
	//-------------------------------------------------------------
	//--------------------------------------------------------------
	// read SCTLR register
	CP15_READ (SCTLR_reg, 0, c1, c0, 0);
	LogMessage ("> CPU CP15 SCTLR: 0x%08lX \n",SCTLR_reg);
fffd0980:	e59f0138 	ldr	r0, [pc, #312]	; fffd0ac0 <main+0x328>
fffd0984:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
fffd0988:	e08f0000 	add	r0, pc, r0
fffd098c:	eb000f5a 	bl	fffd46fc <LogMessage>
	if (((SCTLR_reg>>0)&0x1)== 1)
fffd0990:	e3140001 	tst	r4, #1
fffd0994:	0a000006 	beq	fffd09b4 <main+0x21c>
		LogMessage ("   >> MMU is enable.\n");
fffd0998:	e59f0124 	ldr	r0, [pc, #292]	; fffd0ac4 <main+0x32c>
fffd099c:	e08f0000 	add	r0, pc, r0
fffd09a0:	ea000005 	b	fffd09bc <main+0x224>
	switch (PDID_reg) 
	{
		case Poleg_ID_Z1:	LogError ("> Error: Found NPCM7mnx BMC chip version Z1.\n");	return (1); 
		case Poleg_ID_Z2:	LogPass ("> Found NPCM7mnx BMC chip version A1.\n");	break;
		default:
			LogError ("Error: Unknown NPCM7mnx BMC chip version. Found PDID=0x%08lX\n", PDID_reg); return (1);  
fffd09a4:	e59f011c 	ldr	r0, [pc, #284]	; fffd0ac8 <main+0x330>
fffd09a8:	e08f0000 	add	r0, pc, r0
fffd09ac:	eb000f7e 	bl	fffd47ac <LogError>
fffd09b0:	ea00001e 	b	fffd0a30 <main+0x298>
	CP15_READ (SCTLR_reg, 0, c1, c0, 0);
	LogMessage ("> CPU CP15 SCTLR: 0x%08lX \n",SCTLR_reg);
	if (((SCTLR_reg>>0)&0x1)== 1)
		LogMessage ("   >> MMU is enable.\n");
	else
		LogMessage ("   >> MMU is disable.\n");
fffd09b4:	e59f0110 	ldr	r0, [pc, #272]	; fffd0acc <main+0x334>
fffd09b8:	e08f0000 	add	r0, pc, r0
fffd09bc:	eb000f4e 	bl	fffd46fc <LogMessage>
	if (((SCTLR_reg>>2)&0x1)== 1)
fffd09c0:	e3140004 	tst	r4, #4
		LogMessage ("   >> Data caching is enable.\n");
fffd09c4:	159f0104 	ldrne	r0, [pc, #260]	; fffd0ad0 <main+0x338>
fffd09c8:	108f0000 	addne	r0, pc, r0
	else
		LogMessage ("   >> Data caching is disable.\n");
fffd09cc:	059f0100 	ldreq	r0, [pc, #256]	; fffd0ad4 <main+0x33c>
fffd09d0:	008f0000 	addeq	r0, pc, r0
fffd09d4:	eb000f48 	bl	fffd46fc <LogMessage>
	if (((SCTLR_reg>>11)&0x1)== 1)
fffd09d8:	e3140b02 	tst	r4, #2048	; 0x800
		LogMessage ("   >> Program flow prediction is enable.\n");
fffd09dc:	159f00f4 	ldrne	r0, [pc, #244]	; fffd0ad8 <main+0x340>
fffd09e0:	108f0000 	addne	r0, pc, r0
	else
		LogMessage ("   >> Program flow prediction is disable.\n");
fffd09e4:	059f00f0 	ldreq	r0, [pc, #240]	; fffd0adc <main+0x344>
fffd09e8:	008f0000 	addeq	r0, pc, r0
fffd09ec:	eb000f42 	bl	fffd46fc <LogMessage>
	if (((SCTLR_reg>>12)&0x1)== 1)
fffd09f0:	e3140a01 	tst	r4, #4096	; 0x1000
		LogMessage ("   >> Instruction caching is enable.\n");
fffd09f4:	159f00e4 	ldrne	r0, [pc, #228]	; fffd0ae0 <main+0x348>
fffd09f8:	108f0000 	addne	r0, pc, r0
	else
		LogMessage ("   >> Instruction caching is disable.\n");
fffd09fc:	059f00e0 	ldreq	r0, [pc, #224]	; fffd0ae4 <main+0x34c>
fffd0a00:	008f0000 	addeq	r0, pc, r0
fffd0a04:	eb000f3c 	bl	fffd46fc <LogMessage>
	if (((SCTLR_reg>>13)&0x1)== 1)
fffd0a08:	e3140a02 	tst	r4, #8192	; 0x2000
		LogMessage ("   >> High exception vectors, Hivecs, base address 0xFFFF0000.\n");
fffd0a0c:	159f00d4 	ldrne	r0, [pc, #212]	; fffd0ae8 <main+0x350>
fffd0a10:	108f0000 	addne	r0, pc, r0
	else
		LogMessage ("   >> Normal exception vectors, base address 0x00000000.\n");
fffd0a14:	059f00d0 	ldreq	r0, [pc, #208]	; fffd0aec <main+0x354>
fffd0a18:	008f0000 	addeq	r0, pc, r0
fffd0a1c:	eb000f36 	bl	fffd46fc <LogMessage>
	//-------------------------------------------------------------
	Check_Clocks ();
fffd0a20:	ebfffebc 	bl	fffd0518 <Check_Clocks>

	status = MainMenu();

	return (status);
	
} // *End of main*
fffd0a24:	e28dd00c 	add	sp, sp, #12
fffd0a28:	e8bd4030 	pop	{r4, r5, lr}
		LogMessage ("   >> Normal exception vectors, base address 0x00000000.\n");
	//-------------------------------------------------------------
	Check_Clocks ();
	//--------------------------------------------------------------

	status = MainMenu();
fffd0a2c:	ea000921 	b	fffd2eb8 <MainMenu>

	return (status);
	
} // *End of main*
fffd0a30:	e3a00001 	mov	r0, #1
fffd0a34:	e28dd00c 	add	sp, sp, #12
fffd0a38:	e8bd8030 	pop	{r4, r5, pc}
fffd0a3c:	00006acc 	.word	0x00006acc
fffd0a40:	00000044 	.word	0x00000044
fffd0a44:	fffffbe4 	.word	0xfffffbe4
fffd0a48:	0000550b 	.word	0x0000550b
fffd0a4c:	00000018 	.word	0x00000018
fffd0a50:	fffffab4 	.word	0xfffffab4
fffd0a54:	0000003c 	.word	0x0000003c
fffd0a58:	fffffb00 	.word	0xfffffb00
fffd0a5c:	0000004c 	.word	0x0000004c
fffd0a60:	fffffb48 	.word	0xfffffb48
fffd0a64:	00000020 	.word	0x00000020
fffd0a68:	fffffa1c 	.word	0xfffffa1c
fffd0a6c:	00000038 	.word	0x00000038
fffd0a70:	fffff9ac 	.word	0xfffff9ac
fffd0a74:	00000034 	.word	0x00000034
fffd0a78:	00004dfc 	.word	0x00004dfc
fffd0a7c:	00004e1e 	.word	0x00004e1e
fffd0a80:	00004e26 	.word	0x00004e26
fffd0a84:	00000024 	.word	0x00000024
fffd0a88:	00000040 	.word	0x00000040
fffd0a8c:	f0800000 	.word	0xf0800000
fffd0a90:	00004def 	.word	0x00004def
fffd0a94:	00004dfd 	.word	0x00004dfd
fffd0a98:	00004dbb 	.word	0x00004dbb
fffd0a9c:	00004dfd 	.word	0x00004dfd
fffd0aa0:	00004e32 	.word	0x00004e32
fffd0aa4:	00004e4e 	.word	0x00004e4e
fffd0aa8:	00004e68 	.word	0x00004e68
fffd0aac:	000053a0 	.word	0x000053a0
fffd0ab0:	00004ece 	.word	0x00004ece
fffd0ab4:	00a92750 	.word	0x00a92750
fffd0ab8:	00004eb4 	.word	0x00004eb4
fffd0abc:	00004ece 	.word	0x00004ece
fffd0ac0:	00004ee5 	.word	0x00004ee5
fffd0ac4:	00004f2b 	.word	0x00004f2b
fffd0ac8:	00004ee1 	.word	0x00004ee1
fffd0acc:	00004f25 	.word	0x00004f25
fffd0ad0:	00004f2c 	.word	0x00004f2c
fffd0ad4:	00004f43 	.word	0x00004f43
fffd0ad8:	00004f53 	.word	0x00004f53
fffd0adc:	00004f75 	.word	0x00004f75
fffd0ae0:	00004f90 	.word	0x00004f90
fffd0ae4:	00004fae 	.word	0x00004fae
fffd0ae8:	00004fc5 	.word	0x00004fc5
fffd0aec:	00004ffd 	.word	0x00004ffd

fffd0af0 <RelocateTlbs>:
//---------------------------------------------------------------------
// If MMU is enabled, relocate TLBs: 
// Mode = 0: to top 16K of the internal
// Mode = 1: back to previous location stored at g_TlbsOriginAddr (global variable)
int RelocateTlbs (int Mode)
{
fffd0af0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
fffd0af4:	e59f5154 	ldr	r5, [pc, #340]	; fffd0c50 <RelocateTlbs+0x160>
	UINT32 RelocateToAddr;
	UINT32 SCTLR, TTBR0, TTBR1, TTBCR; 
	UINT16 status; 

	CP15_READ (SCTLR, 0, c1, c0, 0);
fffd0af8:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
fffd0afc:	e59f2150 	ldr	r2, [pc, #336]	; fffd0c54 <RelocateTlbs+0x164>
	if (((SCTLR>>0)&0x1)!= 1)
fffd0b00:	e2133001 	ands	r3, r3, #1
//---------------------------------------------------------------------
// If MMU is enabled, relocate TLBs: 
// Mode = 0: to top 16K of the internal
// Mode = 1: back to previous location stored at g_TlbsOriginAddr (global variable)
int RelocateTlbs (int Mode)
{
fffd0b04:	e08f5005 	add	r5, pc, r5
fffd0b08:	e7952002 	ldr	r2, [r5, r2]
	UINT32 RelocateToAddr;
	UINT32 SCTLR, TTBR0, TTBR1, TTBCR; 
	UINT16 status; 

	CP15_READ (SCTLR, 0, c1, c0, 0);
	if (((SCTLR>>0)&0x1)!= 1)
fffd0b0c:	1a000002 	bne	fffd0b1c <RelocateTlbs+0x2c>
	{
		g_IsMMUenable = FALSE;
fffd0b10:	e5823000 	str	r3, [r2]
		return (0); // MMU is disabled, no need to relocate.
fffd0b14:	e1a00003 	mov	r0, r3
fffd0b18:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
fffd0b1c:	e1a06000 	mov	r6, r0
	g_IsMMUenable = TRUE;

	CP15_READ (TTBR0, 0, c2, c0, 0);  
	CP15_READ (TTBR1, 0, c2, c0, 1);
	CP15_READ (TTBCR, 0, c2, c0, 2);
	LogMessage ("\n> Found MMU is enable. TLBs must be relocated. \n");
fffd0b20:	e59f0130 	ldr	r0, [pc, #304]	; fffd0c58 <RelocateTlbs+0x168>
	{
		g_IsMMUenable = FALSE;
		return (0); // MMU is disabled, no need to relocate.
	}

	g_IsMMUenable = TRUE;
fffd0b24:	e3a03001 	mov	r3, #1
fffd0b28:	e5823000 	str	r3, [r2]

	CP15_READ (TTBR0, 0, c2, c0, 0);  
	CP15_READ (TTBR1, 0, c2, c0, 1);
	CP15_READ (TTBCR, 0, c2, c0, 2);
	LogMessage ("\n> Found MMU is enable. TLBs must be relocated. \n");
fffd0b2c:	e08f0000 	add	r0, pc, r0

	g_IsMMUenable = TRUE;

	CP15_READ (TTBR0, 0, c2, c0, 0);  
	CP15_READ (TTBR1, 0, c2, c0, 1);
	CP15_READ (TTBCR, 0, c2, c0, 2);
fffd0b30:	ee127f50 	mrc	15, 0, r7, cr2, cr0, {2}
	LogMessage ("\n> Found MMU is enable. TLBs must be relocated. \n");
fffd0b34:	eb000ef0 	bl	fffd46fc <LogMessage>

	if ((TTBCR&0x07)!= 0)
fffd0b38:	e3170007 	tst	r7, #7
		return (0); // MMU is disabled, no need to relocate.
	}

	g_IsMMUenable = TRUE;

	CP15_READ (TTBR0, 0, c2, c0, 0);  
fffd0b3c:	ee124f10 	mrc	15, 0, r4, cr2, cr0, {0}
	CP15_READ (TTBR1, 0, c2, c0, 1);
	CP15_READ (TTBCR, 0, c2, c0, 2);
	LogMessage ("\n> Found MMU is enable. TLBs must be relocated. \n");

	if ((TTBCR&0x07)!= 0)
fffd0b40:	0a00000d 	beq	fffd0b7c <RelocateTlbs+0x8c>
	{
		LOG_ERROR ((" TTBR0.N is not 0; don't know how to relocate TLBs. "));
fffd0b44:	e59f0110 	ldr	r0, [pc, #272]	; fffd0c5c <RelocateTlbs+0x16c>
fffd0b48:	e3002126 	movw	r2, #294	; 0x126
fffd0b4c:	e59f110c 	ldr	r1, [pc, #268]	; fffd0c60 <RelocateTlbs+0x170>
fffd0b50:	e59f310c 	ldr	r3, [pc, #268]	; fffd0c64 <RelocateTlbs+0x174>
fffd0b54:	e08f0000 	add	r0, pc, r0
fffd0b58:	e08f1001 	add	r1, pc, r1
fffd0b5c:	e08f3003 	add	r3, pc, r3
fffd0b60:	eb000f11 	bl	fffd47ac <LogError>
fffd0b64:	e59f00fc 	ldr	r0, [pc, #252]	; fffd0c68 <RelocateTlbs+0x178>
fffd0b68:	e08f0000 	add	r0, pc, r0
fffd0b6c:	eb000f0e 	bl	fffd47ac <LogError>
fffd0b70:	e59f00f4 	ldr	r0, [pc, #244]	; fffd0c6c <RelocateTlbs+0x17c>
fffd0b74:	e08f0000 	add	r0, pc, r0
fffd0b78:	ea00002b 	b	fffd0c2c <RelocateTlbs+0x13c>
fffd0b7c:	e59f30ec 	ldr	r3, [pc, #236]	; fffd0c70 <RelocateTlbs+0x180>
		return (-1);
	}

	if (Mode==0)
fffd0b80:	e3560000 	cmp	r6, #0
		RelocateToAddr = 0xFFFF0000-(16*1024); // Relocate TLBs to top 16K of the internl SRAM.
	else
		RelocateToAddr = g_TlbsOriginAddr; // Relocate TBLs back to previous location stored at g_TlbsOriginAddr

	g_TlbsOriginAddr = TTBR0&0xFFFFC000;
	LogMessage ("  >> Current address: 0x%08lX; Size: 16KB. \n",g_TlbsOriginAddr);
fffd0b84:	e59f00e8 	ldr	r0, [pc, #232]	; fffd0c74 <RelocateTlbs+0x184>
	if (Mode==0)
		RelocateToAddr = 0xFFFF0000-(16*1024); // Relocate TLBs to top 16K of the internl SRAM.
	else
		RelocateToAddr = g_TlbsOriginAddr; // Relocate TBLs back to previous location stored at g_TlbsOriginAddr

	g_TlbsOriginAddr = TTBR0&0xFFFFC000;
fffd0b88:	e3c41dff 	bic	r1, r4, #16320	; 0x3fc0
fffd0b8c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
	LogMessage ("  >> Current address: 0x%08lX; Size: 16KB. \n",g_TlbsOriginAddr);
	TTBR0 &= ~0xFFFFC000;
fffd0b90:	e7ed4054 	ubfx	r4, r4, #0, #14
fffd0b94:	e7956003 	ldr	r6, [r5, r3]
		LOG_ERROR ((" TTBR0.N is not 0; don't know how to relocate TLBs. "));
		return (-1);
	}

	if (Mode==0)
		RelocateToAddr = 0xFFFF0000-(16*1024); // Relocate TLBs to top 16K of the internl SRAM.
fffd0b98:	059f50d8 	ldreq	r5, [pc, #216]	; fffd0c78 <RelocateTlbs+0x188>
	else
		RelocateToAddr = g_TlbsOriginAddr; // Relocate TBLs back to previous location stored at g_TlbsOriginAddr

	g_TlbsOriginAddr = TTBR0&0xFFFFC000;
	LogMessage ("  >> Current address: 0x%08lX; Size: 16KB. \n",g_TlbsOriginAddr);
fffd0b9c:	e08f0000 	add	r0, pc, r0
	}

	if (Mode==0)
		RelocateToAddr = 0xFFFF0000-(16*1024); // Relocate TLBs to top 16K of the internl SRAM.
	else
		RelocateToAddr = g_TlbsOriginAddr; // Relocate TBLs back to previous location stored at g_TlbsOriginAddr
fffd0ba0:	15965000 	ldrne	r5, [r6]

	g_TlbsOriginAddr = TTBR0&0xFFFFC000;
fffd0ba4:	e5861000 	str	r1, [r6]
	LogMessage ("  >> Current address: 0x%08lX; Size: 16KB. \n",g_TlbsOriginAddr);
fffd0ba8:	eb000ed3 	bl	fffd46fc <LogMessage>
	TTBR0 &= ~0xFFFFC000;
	TTBR0 |= RelocateToAddr & 0xFFFFC000;
fffd0bac:	e3c55dff 	bic	r5, r5, #16320	; 0x3fc0
	LogMessage ("  >> Relocate address: 0x%08lX. \n",TTBR0&0xFFFFC000);
fffd0bb0:	e59f00c4 	ldr	r0, [pc, #196]	; fffd0c7c <RelocateTlbs+0x18c>
		RelocateToAddr = g_TlbsOriginAddr; // Relocate TBLs back to previous location stored at g_TlbsOriginAddr

	g_TlbsOriginAddr = TTBR0&0xFFFFC000;
	LogMessage ("  >> Current address: 0x%08lX; Size: 16KB. \n",g_TlbsOriginAddr);
	TTBR0 &= ~0xFFFFC000;
	TTBR0 |= RelocateToAddr & 0xFFFFC000;
fffd0bb4:	e3c5503f 	bic	r5, r5, #63	; 0x3f
fffd0bb8:	e1855004 	orr	r5, r5, r4
	LogMessage ("  >> Relocate address: 0x%08lX. \n",TTBR0&0xFFFFC000);
fffd0bbc:	e3c54dff 	bic	r4, r5, #16320	; 0x3fc0
fffd0bc0:	e08f0000 	add	r0, pc, r0
fffd0bc4:	e3c4403f 	bic	r4, r4, #63	; 0x3f
fffd0bc8:	e1a01004 	mov	r1, r4
fffd0bcc:	eb000eca 	bl	fffd46fc <LogMessage>

	// Copy TLBs from current location to new location
	MemCpy ((void*)(TTBR0&0xFFFFC000),(void*)(g_TlbsOriginAddr), 16*1024);
fffd0bd0:	e1a00004 	mov	r0, r4
fffd0bd4:	e5961000 	ldr	r1, [r6]
fffd0bd8:	e3a02901 	mov	r2, #16384	; 0x4000
fffd0bdc:	eb000fd7 	bl	fffd4b40 <MemCpy>
	status = MemoryCompare ((UINT16*)(TTBR0&0xFFFFC000),(UINT16*)(g_TlbsOriginAddr),16*1024/2);
fffd0be0:	e1a00004 	mov	r0, r4
fffd0be4:	e5961000 	ldr	r1, [r6]
fffd0be8:	e3a02a02 	mov	r2, #8192	; 0x2000
fffd0bec:	eb000924 	bl	fffd3084 <MemoryCompare>
	if (status != 0)
fffd0bf0:	e2504000 	subs	r4, r0, #0
fffd0bf4:	0a00000f 	beq	fffd0c38 <RelocateTlbs+0x148>
	{
		LOG_ERROR ((" Failed to copy TLBs. "));
fffd0bf8:	e59f0080 	ldr	r0, [pc, #128]	; fffd0c80 <RelocateTlbs+0x190>
fffd0bfc:	e300213a 	movw	r2, #314	; 0x13a
fffd0c00:	e59f107c 	ldr	r1, [pc, #124]	; fffd0c84 <RelocateTlbs+0x194>
fffd0c04:	e59f307c 	ldr	r3, [pc, #124]	; fffd0c88 <RelocateTlbs+0x198>
fffd0c08:	e08f0000 	add	r0, pc, r0
fffd0c0c:	e08f1001 	add	r1, pc, r1
fffd0c10:	e08f3003 	add	r3, pc, r3
fffd0c14:	eb000ee4 	bl	fffd47ac <LogError>
fffd0c18:	e59f006c 	ldr	r0, [pc, #108]	; fffd0c8c <RelocateTlbs+0x19c>
fffd0c1c:	e08f0000 	add	r0, pc, r0
fffd0c20:	eb000ee1 	bl	fffd47ac <LogError>
fffd0c24:	e59f0064 	ldr	r0, [pc, #100]	; fffd0c90 <RelocateTlbs+0x1a0>
fffd0c28:	e08f0000 	add	r0, pc, r0
fffd0c2c:	eb000eb2 	bl	fffd46fc <LogMessage>
		return (-1);
fffd0c30:	e3e00000 	mvn	r0, #0
fffd0c34:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}
	CP15_WRITE (TTBR0, 0, c2, c0, 0); 
fffd0c38:	ee025f10 	mcr	15, 0, r5, cr2, cr0, {0}
	LogPass ("  >> Done. \n");
fffd0c3c:	e59f0050 	ldr	r0, [pc, #80]	; fffd0c94 <RelocateTlbs+0x1a4>
fffd0c40:	e08f0000 	add	r0, pc, r0
fffd0c44:	eb000ef8 	bl	fffd482c <LogPass>
	return (0);
fffd0c48:	e1a00004 	mov	r0, r4
}
fffd0c4c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
fffd0c50:	00006774 	.word	0x00006774
fffd0c54:	0000000c 	.word	0x0000000c
fffd0c58:	00004f81 	.word	0x00004f81
fffd0c5c:	000046fa 	.word	0x000046fa
fffd0c60:	00004f87 	.word	0x00004f87
fffd0c64:	000060da 	.word	0x000060da
fffd0c68:	00004f82 	.word	0x00004f82
fffd0c6c:	00005158 	.word	0x00005158
fffd0c70:	00000014 	.word	0x00000014
fffd0c74:	00004f83 	.word	0x00004f83
fffd0c78:	fffec000 	.word	0xfffec000
fffd0c7c:	00004f8c 	.word	0x00004f8c
fffd0c80:	00004646 	.word	0x00004646
fffd0c84:	00004ed3 	.word	0x00004ed3
fffd0c88:	00006026 	.word	0x00006026
fffd0c8c:	00004f52 	.word	0x00004f52
fffd0c90:	000050a4 	.word	0x000050a4
fffd0c94:	00004f45 	.word	0x00004f45

fffd0c98 <CheckForAbort>:
}
*/
//------------------------------------------------------
// check for abort key
int CheckForAbort (void)
{
fffd0c98:	e59f3058 	ldr	r3, [pc, #88]	; fffd0cf8 <CheckForAbort+0x60>
	if (g_KeyPress==ESC_KEY)
fffd0c9c:	e59f2058 	ldr	r2, [pc, #88]	; fffd0cfc <CheckForAbort+0x64>
}
*/
//------------------------------------------------------
// check for abort key
int CheckForAbort (void)
{
fffd0ca0:	e92d4010 	push	{r4, lr}
fffd0ca4:	e08f3003 	add	r3, pc, r3
	if (g_KeyPress==ESC_KEY)
fffd0ca8:	e7934002 	ldr	r4, [r3, r2]
fffd0cac:	e5d43000 	ldrb	r3, [r4]
fffd0cb0:	e353001b 	cmp	r3, #27
fffd0cb4:	0a00000d 	beq	fffd0cf0 <CheckForAbort+0x58>
		return (-1);
	else
	{
		if (KbHit()==TRUE)
fffd0cb8:	eb000f1c 	bl	fffd4930 <KbHit>
fffd0cbc:	e3500001 	cmp	r0, #1
fffd0cc0:	0a000001 	beq	fffd0ccc <CheckForAbort+0x34>
				LogWarning ("\n\n %s \n",g_Text_AbortedByUser);
				return (-1);
			}
		}
	}
	return (0);
fffd0cc4:	e3a00000 	mov	r0, #0
fffd0cc8:	e8bd8010 	pop	{r4, pc}
		return (-1);
	else
	{
		if (KbHit()==TRUE)
		{
			g_KeyPress = GetChar();
fffd0ccc:	eb000f23 	bl	fffd4960 <GetChar>
			if (g_KeyPress==ESC_KEY)
fffd0cd0:	e350001b 	cmp	r0, #27
		return (-1);
	else
	{
		if (KbHit()==TRUE)
		{
			g_KeyPress = GetChar();
fffd0cd4:	e5c40000 	strb	r0, [r4]
			if (g_KeyPress==ESC_KEY)
fffd0cd8:	1afffff9 	bne	fffd0cc4 <CheckForAbort+0x2c>
			{
				LogWarning ("\n\n %s \n",g_Text_AbortedByUser);
fffd0cdc:	e59f001c 	ldr	r0, [pc, #28]	; fffd0d00 <CheckForAbort+0x68>
fffd0ce0:	e59f101c 	ldr	r1, [pc, #28]	; fffd0d04 <CheckForAbort+0x6c>
fffd0ce4:	e08f0000 	add	r0, pc, r0
fffd0ce8:	e08f1001 	add	r1, pc, r1
fffd0cec:	eb000ebe 	bl	fffd47ec <LogWarning>
//------------------------------------------------------
// check for abort key
int CheckForAbort (void)
{
	if (g_KeyPress==ESC_KEY)
		return (-1);
fffd0cf0:	e3e00000 	mvn	r0, #0
				return (-1);
			}
		}
	}
	return (0);
}
fffd0cf4:	e8bd8010 	pop	{r4, pc}
fffd0cf8:	000065d4 	.word	0x000065d4
fffd0cfc:	0000001c 	.word	0x0000001c
fffd0d00:	00004eae 	.word	0x00004eae
fffd0d04:	00005f63 	.word	0x00005f63

fffd0d08 <DQ_to_INT>:
//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------
//DQ_Trim: -63...0...63 = 0x3F...0x01,(0x00)0x40,0x41...0x7F
int  DQ_to_INT (UINT8 DQ_Trim)
{
	if ((DQ_Trim==0x00) || (DQ_Trim==0x40))
fffd0d08:	e21030bf 	ands	r3, r0, #191	; 0xbf
fffd0d0c:	0a000003 	beq	fffd0d20 <DQ_to_INT+0x18>
		return (0);
	else if (DQ_Trim>0x40) 
fffd0d10:	e3500040 	cmp	r0, #64	; 0x40
		return ((int)(DQ_Trim&0x3F));
fffd0d14:	8200003f 	andhi	r0, r0, #63	; 0x3f
	else
		return ((int)(-1)*(int)(DQ_Trim&0x3F));		
fffd0d18:	92600000 	rsbls	r0, r0, #0
fffd0d1c:	e12fff1e 	bx	lr
//---------------------------------------------------------------------------------------------------------------------
//DQ_Trim: -63...0...63 = 0x3F...0x01,(0x00)0x40,0x41...0x7F
int  DQ_to_INT (UINT8 DQ_Trim)
{
	if ((DQ_Trim==0x00) || (DQ_Trim==0x40))
		return (0);
fffd0d20:	e1a00003 	mov	r0, r3
	else if (DQ_Trim>0x40) 
		return ((int)(DQ_Trim&0x3F));
	else
		return ((int)(-1)*(int)(DQ_Trim&0x3F));		
}
fffd0d24:	e12fff1e 	bx	lr

fffd0d28 <INT_to_DQ>:

UINT8 INT_to_DQ (int DQ_Trim)
{
	if (DQ_Trim==0)
fffd0d28:	e3500000 	cmp	r0, #0
fffd0d2c:	0a000003 	beq	fffd0d40 <INT_to_DQ+0x18>
		return (0x40);
	else if (DQ_Trim>0) 
		return (0x40 | (UINT8)(DQ_Trim));
fffd0d30:	c3800040 	orrgt	r0, r0, #64	; 0x40
	else
		return ((UINT8)(DQ_Trim*(-1)));		
fffd0d34:	d2600000 	rsble	r0, r0, #0
fffd0d38:	e6ef0070 	uxtb	r0, r0
fffd0d3c:	e12fff1e 	bx	lr
}

UINT8 INT_to_DQ (int DQ_Trim)
{
	if (DQ_Trim==0)
		return (0x40);
fffd0d40:	e3a00040 	mov	r0, #64	; 0x40
	else if (DQ_Trim>0) 
		return (0x40 | (UINT8)(DQ_Trim));
	else
		return ((UINT8)(DQ_Trim*(-1)));		
}
fffd0d44:	e12fff1e 	bx	lr

fffd0d48 <Sweep_Trim_InputDQ_Offset>:
	
	return (DQ_Trim);
}
// This is delta sweep. This test sweep input DQn trim value by relative to present DQ trim settings. It scan up to +/- 63 steps from preset DQn value or until one of the data line reach max/min trim value.
BOOL Sweep_Trim_InputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd0d48:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
fffd0d4c:	e24dd0fc 	sub	sp, sp, #252	; 0xfc
fffd0d50:	e59f3370 	ldr	r3, [pc, #880]	; fffd10c8 <Sweep_Trim_InputDQ_Offset+0x380>
fffd0d54:	e1a0b000 	mov	r11, r0
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd0d58:	e3a04000 	mov	r4, #0
	
	return (DQ_Trim);
}
// This is delta sweep. This test sweep input DQn trim value by relative to present DQ trim settings. It scan up to +/- 63 steps from preset DQn value or until one of the data line reach max/min trim value.
BOOL Sweep_Trim_InputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd0d5c:	e58d201c 	str	r2, [sp, #28]
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd0d60:	e59f2364 	ldr	r2, [pc, #868]	; fffd10cc <Sweep_Trim_InputDQ_Offset+0x384>
	
	return (DQ_Trim);
}
// This is delta sweep. This test sweep input DQn trim value by relative to present DQ trim settings. It scan up to +/- 63 steps from preset DQn value or until one of the data line reach max/min trim value.
BOOL Sweep_Trim_InputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd0d64:	e08f3003 	add	r3, pc, r3
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;

	LogMessage ("\n");
fffd0d68:	e59f0360 	ldr	r0, [pc, #864]	; fffd10d0 <Sweep_Trim_InputDQ_Offset+0x388>
	
	return (DQ_Trim);
}
// This is delta sweep. This test sweep input DQn trim value by relative to present DQ trim settings. It scan up to +/- 63 steps from preset DQn value or until one of the data line reach max/min trim value.
BOOL Sweep_Trim_InputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd0d6c:	e58d1018 	str	r1, [sp, #24]
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd0d70:	e7933002 	ldr	r3, [r3, r2]

	LogMessage ("\n");
fffd0d74:	e08f0000 	add	r0, pc, r0
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd0d78:	e5c34000 	strb	r4, [r3]

	LogMessage ("\n");
fffd0d7c:	eb000e5e 	bl	fffd46fc <LogMessage>
	LogHeader (" Sweep Input DQ Delay Relative to DQS (%s)", Title);
fffd0d80:	e59f034c 	ldr	r0, [pc, #844]	; fffd10d4 <Sweep_Trim_InputDQ_Offset+0x38c>
fffd0d84:	e59d101c 	ldr	r1, [sp, #28]
fffd0d88:	e08f0000 	add	r0, pc, r0
fffd0d8c:	eb000eb6 	bl	fffd486c <LogHeader>
fffd0d90:	e28d3038 	add	r3, sp, #56	; 0x38
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<8; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
fffd0d94:	e0647184 	rsb	r7, r4, r4, lsl #3
fffd0d98:	e0838284 	add	r8, r3, r4, lsl #5
fffd0d9c:	e3a06000 	mov	r6, #0
fffd0da0:	e58d300c 	str	r3, [sp, #12]
fffd0da4:	e59f532c 	ldr	r5, [pc, #812]	; fffd10d8 <Sweep_Trim_InputDQ_Offset+0x390>
fffd0da8:	e0873406 	add	r3, r7, r6, lsl #8
fffd0dac:	e585312c 	str	r3, [r5, #300]	; 0x12c
			DqTrim = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
fffd0db0:	e5950194 	ldr	r0, [r5, #404]	; 0x194
			OriginTrimDQ [ilane][ibit] = DQ_to_INT (DqTrim);
fffd0db4:	e200007f 	and	r0, r0, #127	; 0x7f
fffd0db8:	ebffffd2 	bl	fffd0d08 <DQ_to_INT>
fffd0dbc:	e7880106 	str	r0, [r8, r6, lsl #2]
	//--------------------------------------------------------------------------
	// Get default trim values
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<8; ibit++) 
fffd0dc0:	e2866001 	add	r6, r6, #1
fffd0dc4:	e3560008 	cmp	r6, #8
fffd0dc8:	1afffff5 	bne	fffd0da4 <Sweep_Trim_InputDQ_Offset+0x5c>
fffd0dcc:	e2877b02 	add	r7, r7, #2048	; 0x800
			//LogMessage ("DQn[%lu][%lu]=0x%02x(%d).\n", ilane, ibit, DqTrim, OriginTrimDQ[ilane][ibit]);
		}
		ibit = 8;
		WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
		DqsTrim = (UINT8)(READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
		OriginTrimDQS[ilane] = (int)(DqsTrim);
fffd0dd0:	e28d202c 	add	r2, sp, #44	; 0x2c
			DqTrim = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
			OriginTrimDQ [ilane][ibit] = DQ_to_INT (DqTrim);
			//LogMessage ("DQn[%lu][%lu]=0x%02x(%d).\n", ilane, ibit, DqTrim, OriginTrimDQ[ilane][ibit]);
		}
		ibit = 8;
		WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
fffd0dd4:	e585712c 	str	r7, [r5, #300]	; 0x12c
		DqsTrim = (UINT8)(READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
fffd0dd8:	e5953194 	ldr	r3, [r5, #404]	; 0x194
		OriginTrimDQS[ilane] = (int)(DqsTrim);
fffd0ddc:	e203307f 	and	r3, r3, #127	; 0x7f
fffd0de0:	e7823104 	str	r3, [r2, r4, lsl #2]
	//--------------------------------------------------------------------------

	//--------------------------------------------------------------------------
	// Get default trim values
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd0de4:	e2844001 	add	r4, r4, #1
fffd0de8:	e3540003 	cmp	r4, #3
fffd0dec:	1affffe7 	bne	fffd0d90 <Sweep_Trim_InputDQ_Offset+0x48>
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
	IsReachLimit = FALSE;
	SweepDirection = 1;  // starting with up. 
	Offset = 0;
fffd0df0:	e3a04000 	mov	r4, #0
		//LogMessage ("DQS[%lu]=0x%02x(%d).\n", ilane, DqsTrim, OriginTrimDQS[ilane]);
	}
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
fffd0df4:	e28d3098 	add	r3, sp, #152	; 0x98
{
	UINT32 ilane,ibit;
	int OriginTrimDQS[3], OriginTrimDQ[3][8];
	int TmpTrimDQ[3][8];
	int SweepDirection;
	UINT8 MarginP=0, MarginM=0;
fffd0df8:	e1a08004 	mov	r8, r4
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
	IsReachLimit = FALSE;
	SweepDirection = 1;  // starting with up. 
fffd0dfc:	e3a09001 	mov	r9, #1
		//LogMessage ("DQS[%lu]=0x%02x(%d).\n", ilane, DqsTrim, OriginTrimDQS[ilane]);
	}
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
fffd0e00:	e1a00003 	mov	r0, r3
fffd0e04:	e59d100c 	ldr	r1, [sp, #12]
fffd0e08:	e3a02060 	mov	r2, #96	; 0x60
fffd0e0c:	e58d3020 	str	r3, [sp, #32]
fffd0e10:	eb000f4a 	bl	fffd4b40 <MemCpy>
	while (1)
	{
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd0e14:	e3a06000 	mov	r6, #0
fffd0e18:	e28da098 	add	r10, sp, #152	; 0x98
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd0e1c:	e0663186 	rsb	r3, r6, r6, lsl #3
fffd0e20:	e08aa286 	add	r10, r10, r6, lsl #5
fffd0e24:	e3a07000 	mov	r7, #0
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			for (ibit=0; ibit<8; ibit++) 
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
fffd0e28:	e79b2106 	ldr	r2, [r11, r6, lsl #2]
fffd0e2c:	e1a02732 	lsr	r2, r2, r7
fffd0e30:	e3120001 	tst	r2, #1
fffd0e34:	1a000009 	bne	fffd0e60 <Sweep_Trim_InputDQ_Offset+0x118>
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
fffd0e38:	e79a0107 	ldr	r0, [r10, r7, lsl #2]
fffd0e3c:	e58d3010 	str	r3, [sp, #16]
fffd0e40:	ebffffb8 	bl	fffd0d28 <INT_to_DQ>
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd0e44:	e59d3010 	ldr	r3, [sp, #16]
				WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd0e48:	e1e00c80 	mvn	r0, r0, lsl #25
fffd0e4c:	e1e00ca0 	mvn	r0, r0, lsr #25
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd0e50:	e0832407 	add	r2, r3, r7, lsl #8
				WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd0e54:	e6ef0070 	uxtb	r0, r0
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd0e58:	e585212c 	str	r2, [r5, #300]	; 0x12c
				WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd0e5c:	e5850194 	str	r0, [r5, #404]	; 0x194
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			for (ibit=0; ibit<8; ibit++) 
fffd0e60:	e2877001 	add	r7, r7, #1
fffd0e64:	e3570008 	cmp	r7, #8
fffd0e68:	1affffee 	bne	fffd0e28 <Sweep_Trim_InputDQ_Offset+0xe0>
	while (1)
	{
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd0e6c:	e2866001 	add	r6, r6, #1
fffd0e70:	e3560003 	cmp	r6, #3
fffd0e74:	1affffe7 	bne	fffd0e18 <Sweep_Trim_InputDQ_Offset+0xd0>
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
				WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
				//LogMessage ("DQn[%lu][%lu]<=0x%02x(%d).\n", ilane, ibit, DqTrim, DqTrim_int);
			}
		}
		if (Offset==0)
fffd0e78:	e3540000 	cmp	r4, #0
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd0e7c:	e3a00601 	mov	r0, #1048576	; 0x100000
fffd0e80:	01a02000 	moveq	r2, r0
		else
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Short); // dummy access to memory in order for values to update 
fffd0e84:	13a02801 	movne	r2, #65536	; 0x10000
				WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
				//LogMessage ("DQn[%lu][%lu]<=0x%02x(%d).\n", ilane, ibit, DqTrim, DqTrim_int);
			}
		}
		if (Offset==0)
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd0e88:	e3a01602 	mov	r1, #2097152	; 0x200000
		else
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Short); // dummy access to memory in order for values to update 
fffd0e8c:	eb000f1d 	bl	fffd4b08 <MemCmp>
		//-----------------------------------------------
		// test the memory
		//-----------------------------------------------
		LastResoults = MemStressTest ();
fffd0e90:	eb000891 	bl	fffd30dc <MemStressTest>
fffd0e94:	e1a0a000 	mov	r10, r0
		LogMessage ("> Offset %3d: 0x%04X \n",Offset, LastResoults); 
fffd0e98:	e59f023c 	ldr	r0, [pc, #572]	; fffd10dc <Sweep_Trim_InputDQ_Offset+0x394>
fffd0e9c:	e1a01004 	mov	r1, r4
fffd0ea0:	e1a0200a 	mov	r2, r10
fffd0ea4:	e08f0000 	add	r0, pc, r0
fffd0ea8:	eb000e13 	bl	fffd46fc <LogMessage>

		//-----------------------------------------------
		// Check Resoult limits 
		//-----------------------------------------------
		if (LastResoults!=0x0000)
fffd0eac:	e35a0000 	cmp	r10, #0
fffd0eb0:	01a0300a 	moveq	r3, r10
fffd0eb4:	0a000003 	beq	fffd0ec8 <Sweep_Trim_InputDQ_Offset+0x180>
		{
			LogMessage ("---------- \n");
fffd0eb8:	e59f0220 	ldr	r0, [pc, #544]	; fffd10e0 <Sweep_Trim_InputDQ_Offset+0x398>
fffd0ebc:	e08f0000 	add	r0, pc, r0
fffd0ec0:	eb000e0d 	bl	fffd46fc <LogMessage>
			IsReachLimit = TRUE;
fffd0ec4:	e3a03001 	mov	r3, #1
fffd0ec8:	e3a06000 	mov	r6, #0
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = OriginTrimDQS[ilane];
fffd0ecc:	e28d202c 	add	r2, sp, #44	; 0x2c
			for (ibit=0; ibit<8; ibit++) 
fffd0ed0:	e3a07000 	mov	r7, #0
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = OriginTrimDQS[ilane];
fffd0ed4:	e7922106 	ldr	r2, [r2, r6, lsl #2]
fffd0ed8:	e58d2010 	str	r2, [sp, #16]
fffd0edc:	e28d2098 	add	r2, sp, #152	; 0x98
fffd0ee0:	e0822286 	add	r2, r2, r6, lsl #5
fffd0ee4:	e58d2014 	str	r2, [sp, #20]
			for (ibit=0; ibit<8; ibit++) 
			{
				if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
fffd0ee8:	e79b2106 	ldr	r2, [r11, r6, lsl #2]
fffd0eec:	e1a02732 	lsr	r2, r2, r7
fffd0ef0:	e2122001 	ands	r2, r2, #1
fffd0ef4:	1a000021 	bne	fffd0f80 <Sweep_Trim_InputDQ_Offset+0x238>
					continue;

				DqTrim_int = TmpTrimDQ[ilane][ibit];
fffd0ef8:	e59d1014 	ldr	r1, [sp, #20]
				DqTrim_int += SweepDirection;
				TmpTrimDQ[ilane][ibit] = DqTrim_int;
				if ( (IsReachLimit!=TRUE) && ((DqTrim_int>63) || (DqTrim_int<-63)) )
fffd0efc:	e3530001 	cmp	r3, #1
			for (ibit=0; ibit<8; ibit++) 
			{
				if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
					continue;

				DqTrim_int = TmpTrimDQ[ilane][ibit];
fffd0f00:	e791c107 	ldr	r12, [r1, r7, lsl #2]
				DqTrim_int += SweepDirection;
fffd0f04:	e08cc009 	add	r12, r12, r9
				TmpTrimDQ[ilane][ibit] = DqTrim_int;
fffd0f08:	e781c107 	str	r12, [r1, r7, lsl #2]
				if ( (IsReachLimit!=TRUE) && ((DqTrim_int>63) || (DqTrim_int<-63)) )
fffd0f0c:	0a00000c 	beq	fffd0f44 <Sweep_Trim_InputDQ_Offset+0x1fc>
fffd0f10:	e28c303f 	add	r3, r12, #63	; 0x3f
fffd0f14:	e353007e 	cmp	r3, #126	; 0x7e
fffd0f18:	91a03002 	movls	r3, r2
fffd0f1c:	9a000008 	bls	fffd0f44 <Sweep_Trim_InputDQ_Offset+0x1fc>
				{

					LogMessage ("--- trim limit --- (DqTrim_int:%d, ilane:%u, ibit:%u) \n", DqTrim_int, ilane, ibit);
fffd0f20:	e59f01bc 	ldr	r0, [pc, #444]	; fffd10e4 <Sweep_Trim_InputDQ_Offset+0x39c>
fffd0f24:	e1a0100c 	mov	r1, r12
fffd0f28:	e1a03007 	mov	r3, r7
fffd0f2c:	e1a02006 	mov	r2, r6
fffd0f30:	e58dc024 	str	r12, [sp, #36]	; 0x24
fffd0f34:	e08f0000 	add	r0, pc, r0
fffd0f38:	eb000def 	bl	fffd46fc <LogMessage>
fffd0f3c:	e59dc024 	ldr	r12, [sp, #36]	; 0x24
					IsReachLimit = TRUE;
fffd0f40:	e3a03001 	mov	r3, #1
				}

				DelayLine_int = DqTrim_int + DqsTrim_int;
fffd0f44:	e59d2010 	ldr	r2, [sp, #16]
fffd0f48:	e08c1002 	add	r1, r12, r2
fffd0f4c:	e2232001 	eor	r2, r3, #1
				if ( (IsReachLimit!=TRUE) && ((DelayLine_int>63) || (DelayLine_int<0)) )
fffd0f50:	e351003f 	cmp	r1, #63	; 0x3f
fffd0f54:	93a02000 	movls	r2, #0
fffd0f58:	82022001 	andhi	r2, r2, #1
fffd0f5c:	e3520000 	cmp	r2, #0
fffd0f60:	0a000006 	beq	fffd0f80 <Sweep_Trim_InputDQ_Offset+0x238>
				{
					LogMessage ("--- delay-line limit --- (DelayLine:%d, DqTrim:%d, DqsTrim:%d, ilane:%u, ibit:%u) \n", DelayLine_int, DqTrim_int, DqsTrim_int, ilane, ibit);
fffd0f64:	e59f017c 	ldr	r0, [pc, #380]	; fffd10e8 <Sweep_Trim_InputDQ_Offset+0x3a0>
fffd0f68:	e1a0200c 	mov	r2, r12
fffd0f6c:	e59d3010 	ldr	r3, [sp, #16]
fffd0f70:	e88d00c0 	stm	sp, {r6, r7}
fffd0f74:	e08f0000 	add	r0, pc, r0
fffd0f78:	eb000ddf 	bl	fffd46fc <LogMessage>
					IsReachLimit = TRUE;
fffd0f7c:	e3a03001 	mov	r3, #1
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = OriginTrimDQS[ilane];
			for (ibit=0; ibit<8; ibit++) 
fffd0f80:	e2877001 	add	r7, r7, #1
fffd0f84:	e3570008 	cmp	r7, #8
fffd0f88:	1affffd6 	bne	fffd0ee8 <Sweep_Trim_InputDQ_Offset+0x1a0>
		}

		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd0f8c:	e2866001 	add	r6, r6, #1
fffd0f90:	e3560003 	cmp	r6, #3
fffd0f94:	1affffcc 	bne	fffd0ecc <Sweep_Trim_InputDQ_Offset+0x184>
					IsReachLimit = TRUE;
				}
			}
		}
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
fffd0f98:	e3530001 	cmp	r3, #1
				break; // done
			}
		}
		else
		{
			Offset += SweepDirection;
fffd0f9c:	10844009 	addne	r4, r4, r9
					IsReachLimit = TRUE;
				}
			}
		}
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
fffd0fa0:	1a000013 	bne	fffd0ff4 <Sweep_Trim_InputDQ_Offset+0x2ac>
		{
			if (SweepDirection>0)
fffd0fa4:	e3590001 	cmp	r9, #1
fffd0fa8:	1a00000a 	bne	fffd0fd8 <Sweep_Trim_InputDQ_Offset+0x290>
			{ // change sweep direction to negative (0, -1...-63)
				MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp  
fffd0fac:	e59d0020 	ldr	r0, [sp, #32]
fffd0fb0:	e3a02060 	mov	r2, #96	; 0x60
fffd0fb4:	e59d100c 	ldr	r1, [sp, #12]
				if ((LastResoults!=0x0000) && (Offset!=0))
					MarginP = (UINT8)(Offset-SweepDirection); 
				else
					MarginP = (UINT8)(Offset); 
				Offset = 0;
				SweepDirection *= -1;
fffd0fb8:	e3e09000 	mvn	r9, #0
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
		{
			if (SweepDirection>0)
			{ // change sweep direction to negative (0, -1...-63)
				MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp  
fffd0fbc:	eb000edf 	bl	fffd4b40 <MemCpy>
				if ((LastResoults!=0x0000) && (Offset!=0))
fffd0fc0:	e35a0000 	cmp	r10, #0
fffd0fc4:	13540000 	cmpne	r4, #0
					MarginP = (UINT8)(Offset-SweepDirection); 
fffd0fc8:	12444001 	subne	r4, r4, #1
				else
					MarginP = (UINT8)(Offset); 
fffd0fcc:	e6ef8074 	uxtb	r8, r4
				Offset = 0;
fffd0fd0:	e3a04000 	mov	r4, #0
fffd0fd4:	ea000006 	b	fffd0ff4 <Sweep_Trim_InputDQ_Offset+0x2ac>
				SweepDirection *= -1;
				IsReachLimit = FALSE;
			}
			else
			{
				if ((LastResoults!=0x0000) && (Offset!=0))
fffd0fd8:	e3540000 	cmp	r4, #0
fffd0fdc:	135a0000 	cmpne	r10, #0
					MarginM = (UINT8)(abs(Offset-SweepDirection)); 
fffd0fe0:	10694004 	rsbne	r4, r9, r4
				else
					MarginM = (UINT8)(abs(Offset)); 
fffd0fe4:	e3540000 	cmp	r4, #0
fffd0fe8:	b2644000 	rsblt	r4, r4, #0
fffd0fec:	e6ef4074 	uxtb	r4, r4
fffd0ff0:	ea000003 	b	fffd1004 <Sweep_Trim_InputDQ_Offset+0x2bc>
		else
		{
			Offset += SweepDirection;
		}
		//-----------------------------------------------
		if (CheckForAbort()!=0)
fffd0ff4:	ebffff27 	bl	fffd0c98 <CheckForAbort>
fffd0ff8:	e3500000 	cmp	r0, #0
fffd0ffc:	0affff84 	beq	fffd0e14 <Sweep_Trim_InputDQ_Offset+0xcc>
{
	UINT32 ilane,ibit;
	int OriginTrimDQS[3], OriginTrimDQ[3][8];
	int TmpTrimDQ[3][8];
	int SweepDirection;
	UINT8 MarginP=0, MarginM=0;
fffd1000:	e3a04000 	mov	r4, #0
			break;
	}
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd1004:	e3a06000 	mov	r6, #0
fffd1008:	e28d9038 	add	r9, sp, #56	; 0x38
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd100c:	e066a186 	rsb	r10, r6, r6, lsl #3
fffd1010:	e0899286 	add	r9, r9, r6, lsl #5
fffd1014:	e3a07000 	mov	r7, #0
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<8; ibit++) 
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
fffd1018:	e79b3106 	ldr	r3, [r11, r6, lsl #2]
fffd101c:	e1a03733 	lsr	r3, r3, r7
fffd1020:	e3130001 	tst	r3, #1
fffd1024:	1a000007 	bne	fffd1048 <Sweep_Trim_InputDQ_Offset+0x300>
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
fffd1028:	e7990107 	ldr	r0, [r9, r7, lsl #2]
fffd102c:	ebffff3d 	bl	fffd0d28 <INT_to_DQ>
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd1030:	e1e00c80 	mvn	r0, r0, lsl #25
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1034:	e08a3407 	add	r3, r10, r7, lsl #8
			WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd1038:	e1e00ca0 	mvn	r0, r0, lsr #25
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd103c:	e585312c 	str	r3, [r5, #300]	; 0x12c
			WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd1040:	e6ef0070 	uxtb	r0, r0
fffd1044:	e5850194 	str	r0, [r5, #404]	; 0x194
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<8; ibit++) 
fffd1048:	e2877001 	add	r7, r7, #1
fffd104c:	e3570008 	cmp	r7, #8
fffd1050:	1afffff0 	bne	fffd1018 <Sweep_Trim_InputDQ_Offset+0x2d0>
			break;
	}
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd1054:	e2866001 	add	r6, r6, #1
fffd1058:	e3560003 	cmp	r6, #3
fffd105c:	1affffe9 	bne	fffd1008 <Sweep_Trim_InputDQ_Offset+0x2c0>
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqTrim);
		}
	}
	MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd1060:	e3a00601 	mov	r0, #1048576	; 0x100000
fffd1064:	e3a01602 	mov	r1, #2097152	; 0x200000
fffd1068:	e1a02000 	mov	r2, r0
fffd106c:	eb000ea5 	bl	fffd4b08 <MemCmp>
	//--------------------------------------------------------------------------
	// Restouls
	LogMessage ("(%s) InputDQ Margin: Min required: +/-%u;  Measured: -%u/+%u. ", Title, ReqMargin, MarginM, MarginP);
fffd1070:	e59f0074 	ldr	r0, [pc, #116]	; fffd10ec <Sweep_Trim_InputDQ_Offset+0x3a4>
fffd1074:	e1a03004 	mov	r3, r4
fffd1078:	e58d8000 	str	r8, [sp]
fffd107c:	e59d101c 	ldr	r1, [sp, #28]
fffd1080:	e08f0000 	add	r0, pc, r0
fffd1084:	e59d2018 	ldr	r2, [sp, #24]
fffd1088:	eb000d9b 	bl	fffd46fc <LogMessage>
	if ((MarginM >= ReqMargin) &&  (MarginP >= ReqMargin))
fffd108c:	e59d3018 	ldr	r3, [sp, #24]
fffd1090:	e1580003 	cmp	r8, r3
fffd1094:	21540003 	cmpcs	r4, r3
fffd1098:	3a000004 	bcc	fffd10b0 <Sweep_Trim_InputDQ_Offset+0x368>
	{
		LogPass (" ==> PASS \n\n");
fffd109c:	e59f004c 	ldr	r0, [pc, #76]	; fffd10f0 <Sweep_Trim_InputDQ_Offset+0x3a8>
fffd10a0:	e08f0000 	add	r0, pc, r0
fffd10a4:	eb000de0 	bl	fffd482c <LogPass>
		return (0);
fffd10a8:	e3a00000 	mov	r0, #0
fffd10ac:	ea000003 	b	fffd10c0 <Sweep_Trim_InputDQ_Offset+0x378>
	}
	else
	{
		LogError (" ==> FAIL \n\n");
fffd10b0:	e59f003c 	ldr	r0, [pc, #60]	; fffd10f4 <Sweep_Trim_InputDQ_Offset+0x3ac>
fffd10b4:	e08f0000 	add	r0, pc, r0
fffd10b8:	eb000dbb 	bl	fffd47ac <LogError>
		return (1);
fffd10bc:	e3a00001 	mov	r0, #1
	}
}
fffd10c0:	e28dd0fc 	add	sp, sp, #252	; 0xfc
fffd10c4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
fffd10c8:	00006514 	.word	0x00006514
fffd10cc:	0000001c 	.word	0x0000001c
fffd10d0:	00004f58 	.word	0x00004f58
fffd10d4:	00004e12 	.word	0x00004e12
fffd10d8:	f05f0000 	.word	0xf05f0000
fffd10dc:	00004d21 	.word	0x00004d21
fffd10e0:	00004d20 	.word	0x00004d20
fffd10e4:	00004cb5 	.word	0x00004cb5
fffd10e8:	00004cad 	.word	0x00004cad
fffd10ec:	00004bf5 	.word	0x00004bf5
fffd10f0:	00004c14 	.word	0x00004c14
fffd10f4:	00004c0d 	.word	0x00004c0d

fffd10f8 <Sweep_Trim_InputDQS_Offset>:
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_InputDQS_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd10f8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
fffd10fc:	e24dd094 	sub	sp, sp, #148	; 0x94
fffd1100:	e59f330c 	ldr	r3, [pc, #780]	; fffd1414 <Sweep_Trim_InputDQS_Offset+0x31c>
fffd1104:	e1a0b000 	mov	r11, r0
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd1108:	e3a04000 	mov	r4, #0
		return (1);
	}
}
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_InputDQS_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd110c:	e58d200c 	str	r2, [sp, #12]
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd1110:	e59f2300 	ldr	r2, [pc, #768]	; fffd1418 <Sweep_Trim_InputDQS_Offset+0x320>
		return (1);
	}
}
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_InputDQS_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd1114:	e08f3003 	add	r3, pc, r3
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;

	LogMessage ("\n");
fffd1118:	e59f02fc 	ldr	r0, [pc, #764]	; fffd141c <Sweep_Trim_InputDQS_Offset+0x324>
		return (1);
	}
}
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_InputDQS_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd111c:	e58d1008 	str	r1, [sp, #8]
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd1120:	e7933002 	ldr	r3, [r3, r2]

	LogMessage ("\n");
fffd1124:	e08f0000 	add	r0, pc, r0
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd1128:	e5c34000 	strb	r4, [r3]

	LogMessage ("\n");
fffd112c:	eb000d72 	bl	fffd46fc <LogMessage>
	LogHeader (" Sweep Round-Trip Delay (%s) ", Title); // this register name is DQS in spec
fffd1130:	e59f02e8 	ldr	r0, [pc, #744]	; fffd1420 <Sweep_Trim_InputDQS_Offset+0x328>
fffd1134:	e59d100c 	ldr	r1, [sp, #12]
fffd1138:	e08f0000 	add	r0, pc, r0
fffd113c:	eb000dca 	bl	fffd486c <LogHeader>
fffd1140:	e28d8030 	add	r8, sp, #48	; 0x30
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<8; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
fffd1144:	e0647184 	rsb	r7, r4, r4, lsl #3
fffd1148:	e0888284 	add	r8, r8, r4, lsl #5
fffd114c:	e3a06000 	mov	r6, #0
fffd1150:	e59f52cc 	ldr	r5, [pc, #716]	; fffd1424 <Sweep_Trim_InputDQS_Offset+0x32c>
fffd1154:	e0873406 	add	r3, r7, r6, lsl #8
fffd1158:	e585312c 	str	r3, [r5, #300]	; 0x12c
			DqTrim = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
fffd115c:	e5950194 	ldr	r0, [r5, #404]	; 0x194
			OriginTrimDQ [ilane][ibit] = DQ_to_INT (DqTrim);
fffd1160:	e200007f 	and	r0, r0, #127	; 0x7f
fffd1164:	ebfffee7 	bl	fffd0d08 <DQ_to_INT>
fffd1168:	e7880106 	str	r0, [r8, r6, lsl #2]
	//--------------------------------------------------------------------------
	// Get default trim values
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<8; ibit++) 
fffd116c:	e2866001 	add	r6, r6, #1
fffd1170:	e3560008 	cmp	r6, #8
fffd1174:	1afffff5 	bne	fffd1150 <Sweep_Trim_InputDQS_Offset+0x58>
fffd1178:	e2877b02 	add	r7, r7, #2048	; 0x800
			//LogMessage ("DQn[%lu][%lu]=0x%02x(%d).\n", ilane, ibit, DqTrim, OriginTrimDQ[ilane][ibit]);
		}
		ibit = 8;
		WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
		DqsTrim = (UINT8)(READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
		OriginTrimDQS[ilane] = (int)(DqsTrim);
fffd117c:	e28d1018 	add	r1, sp, #24
			DqTrim = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
			OriginTrimDQ [ilane][ibit] = DQ_to_INT (DqTrim);
			//LogMessage ("DQn[%lu][%lu]=0x%02x(%d).\n", ilane, ibit, DqTrim, OriginTrimDQ[ilane][ibit]);
		}
		ibit = 8;
		WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
fffd1180:	e585712c 	str	r7, [r5, #300]	; 0x12c
		DqsTrim = (UINT8)(READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F);
fffd1184:	e5953194 	ldr	r3, [r5, #404]	; 0x194
		OriginTrimDQS[ilane] = (int)(DqsTrim);
fffd1188:	e203307f 	and	r3, r3, #127	; 0x7f
fffd118c:	e7813104 	str	r3, [r1, r4, lsl #2]
	//--------------------------------------------------------------------------

	//--------------------------------------------------------------------------
	// Get default trim values
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd1190:	e2844001 	add	r4, r4, #1
fffd1194:	e3540003 	cmp	r4, #3
fffd1198:	1affffe8 	bne	fffd1140 <Sweep_Trim_InputDQS_Offset+0x48>
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQS, OriginTrimDQS, sizeof(TmpTrimDQS)); // copy origin values to tmp array  
	IsReachLimit = FALSE;
	SweepDirection = 1;  // starting with up. 
	Offset = 0;
fffd119c:	e3a04000 	mov	r4, #0
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQS, OriginTrimDQS, sizeof(TmpTrimDQS)); // copy origin values to tmp array  
	IsReachLimit = FALSE;
	SweepDirection = 1;  // starting with up. 
fffd11a0:	e3a09001 	mov	r9, #1
{
	UINT32 ilane,ibit;
	int OriginTrimDQS[3], OriginTrimDQ[3][8];
	int TmpTrimDQS[3];
	int SweepDirection;
	UINT8 MarginP=0, MarginM=0;
fffd11a4:	e1a08004 	mov	r8, r4
		//LogMessage ("DQS[%lu]=0x%02x(%d).\n", ilane, DqsTrim, OriginTrimDQS[ilane]);
	}
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQS, OriginTrimDQS, sizeof(TmpTrimDQS)); // copy origin values to tmp array  
fffd11a8:	e28d0024 	add	r0, sp, #36	; 0x24
fffd11ac:	e3a0200c 	mov	r2, #12
fffd11b0:	eb000e62 	bl	fffd4b40 <MemCpy>
	while (1)
	{
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd11b4:	e3a03000 	mov	r3, #0
		{
			if (DqMask[ilane]) // DqMask: 1-skip, 0-test
fffd11b8:	e79b2103 	ldr	r2, [r11, r3, lsl #2]
fffd11bc:	e3520000 	cmp	r2, #0
fffd11c0:	1a000006 	bne	fffd11e0 <Sweep_Trim_InputDQS_Offset+0xe8>
				continue;		

			DqsTrim_int = TmpTrimDQS[ilane];
			DqsTrim = (UINT8)DqsTrim_int;
fffd11c4:	e28d2024 	add	r2, sp, #36	; 0x24
fffd11c8:	e0631183 	rsb	r1, r3, r3, lsl #3
fffd11cc:	e7d22103 	ldrb	r2, [r2, r3, lsl #2]
fffd11d0:	e2811b02 	add	r1, r1, #2048	; 0x800
			ibit = 8;
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd11d4:	e585112c 	str	r1, [r5, #300]	; 0x12c
			WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqsTrim);
fffd11d8:	e3822080 	orr	r2, r2, #128	; 0x80
fffd11dc:	e5852194 	str	r2, [r5, #404]	; 0x194
	while (1)
	{
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd11e0:	e2833001 	add	r3, r3, #1
fffd11e4:	e3530003 	cmp	r3, #3
fffd11e8:	1afffff2 	bne	fffd11b8 <Sweep_Trim_InputDQS_Offset+0xc0>
			ibit = 8;
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqsTrim);
			//LogMessage ("DQS[%lu]<=0x%02x(%d).\n", ilane, DqsTrim, DqsTrim_int);	
		}
		if (Offset==0)
fffd11ec:	e3540000 	cmp	r4, #0
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd11f0:	e3a00601 	mov	r0, #1048576	; 0x100000
fffd11f4:	01a02000 	moveq	r2, r0
		else
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Short); // dummy access to memory in order for values to update 
fffd11f8:	13a02801 	movne	r2, #65536	; 0x10000
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqsTrim);
			//LogMessage ("DQS[%lu]<=0x%02x(%d).\n", ilane, DqsTrim, DqsTrim_int);	
		}
		if (Offset==0)
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd11fc:	e3a01602 	mov	r1, #2097152	; 0x200000
		else
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Short); // dummy access to memory in order for values to update 
fffd1200:	eb000e40 	bl	fffd4b08 <MemCmp>
		//-----------------------------------------------
		// Test the memory
		//-----------------------------------------------
		LastResoults = MemStressTest ();
fffd1204:	eb0007b4 	bl	fffd30dc <MemStressTest>
fffd1208:	e1a0a000 	mov	r10, r0
		LogMessage ("> Offset %3d: 0x%04X \n",Offset, LastResoults); 
fffd120c:	e59f0214 	ldr	r0, [pc, #532]	; fffd1428 <Sweep_Trim_InputDQS_Offset+0x330>
fffd1210:	e1a01004 	mov	r1, r4
fffd1214:	e1a0200a 	mov	r2, r10
fffd1218:	e08f0000 	add	r0, pc, r0
fffd121c:	eb000d36 	bl	fffd46fc <LogMessage>

		//-----------------------------------------------
		// Check result limits 
		//-----------------------------------------------
		if (LastResoults!=0x0000)
fffd1220:	e35a0000 	cmp	r10, #0
fffd1224:	01a0300a 	moveq	r3, r10
fffd1228:	0a000003 	beq	fffd123c <Sweep_Trim_InputDQS_Offset+0x144>
		{
			LogMessage ("---------- \n");
fffd122c:	e59f01f8 	ldr	r0, [pc, #504]	; fffd142c <Sweep_Trim_InputDQS_Offset+0x334>
fffd1230:	e08f0000 	add	r0, pc, r0
fffd1234:	eb000d30 	bl	fffd46fc <LogMessage>
			IsReachLimit = TRUE;
fffd1238:	e3a03001 	mov	r3, #1
fffd123c:	e3a06000 	mov	r6, #0
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = TmpTrimDQS[ilane];
fffd1240:	e28d2024 	add	r2, sp, #36	; 0x24
			DqsTrim_int += SweepDirection;
			TmpTrimDQS[ilane] = DqsTrim_int;
			for (ibit=0; ibit<8; ibit++) 
fffd1244:	e3a07000 	mov	r7, #0
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = TmpTrimDQS[ilane];
fffd1248:	e792c106 	ldr	r12, [r2, r6, lsl #2]
			DqsTrim_int += SweepDirection;
fffd124c:	e08cc009 	add	r12, r12, r9
			TmpTrimDQS[ilane] = DqsTrim_int;
fffd1250:	e782c106 	str	r12, [r2, r6, lsl #2]
fffd1254:	e28d2030 	add	r2, sp, #48	; 0x30
fffd1258:	e0822286 	add	r2, r2, r6, lsl #5
fffd125c:	e58d2010 	str	r2, [sp, #16]
			for (ibit=0; ibit<8; ibit++) 
			{
				if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
fffd1260:	e79b2106 	ldr	r2, [r11, r6, lsl #2]
fffd1264:	e1a02732 	lsr	r2, r2, r7
fffd1268:	e3120001 	tst	r2, #1
fffd126c:	1a00001f 	bne	fffd12f0 <Sweep_Trim_InputDQS_Offset+0x1f8>
fffd1270:	e2232001 	eor	r2, r3, #1
					continue;

				if ( (IsReachLimit!=TRUE) && ((DqsTrim_int>63) || (DqsTrim_int<0)) )
fffd1274:	e35c003f 	cmp	r12, #63	; 0x3f
fffd1278:	93a02000 	movls	r2, #0
fffd127c:	82022001 	andhi	r2, r2, #1
fffd1280:	e3520000 	cmp	r2, #0
fffd1284:	0a000008 	beq	fffd12ac <Sweep_Trim_InputDQS_Offset+0x1b4>
				{
					LogMessage ("--- trim limit --- (DqsTrim:%d, ilane:%u, ibit:%u) \n", DqsTrim_int, ilane, ibit);
fffd1288:	e59f01a0 	ldr	r0, [pc, #416]	; fffd1430 <Sweep_Trim_InputDQS_Offset+0x338>
fffd128c:	e1a0100c 	mov	r1, r12
fffd1290:	e1a03007 	mov	r3, r7
fffd1294:	e1a02006 	mov	r2, r6
fffd1298:	e58dc014 	str	r12, [sp, #20]
fffd129c:	e08f0000 	add	r0, pc, r0
fffd12a0:	eb000d15 	bl	fffd46fc <LogMessage>
					IsReachLimit = TRUE;
fffd12a4:	e59dc014 	ldr	r12, [sp, #20]
fffd12a8:	e3a03001 	mov	r3, #1
				}

				DqTrim_int = OriginTrimDQ[ilane][ibit];
fffd12ac:	e59d2010 	ldr	r2, [sp, #16]
fffd12b0:	e2230001 	eor	r0, r3, #1
fffd12b4:	e7922107 	ldr	r2, [r2, r7, lsl #2]
				DelayLine_int = DqTrim_int + DqsTrim_int;
fffd12b8:	e082100c 	add	r1, r2, r12
				if ( (IsReachLimit!=TRUE) && ((DelayLine_int>63) || (DelayLine_int<0)) )
fffd12bc:	e351003f 	cmp	r1, #63	; 0x3f
fffd12c0:	93a00000 	movls	r0, #0
fffd12c4:	82000001 	andhi	r0, r0, #1
fffd12c8:	e3500000 	cmp	r0, #0
fffd12cc:	0a000007 	beq	fffd12f0 <Sweep_Trim_InputDQS_Offset+0x1f8>
				{
					LogMessage ("--- delay-line limit --- (DelayLine:%d, DqTrim:%d, DqsTrim:%d, ilane:%u, ibit:%u) \n", DelayLine_int, DqTrim_int, DqsTrim_int, ilane, ibit);
fffd12d0:	e59f015c 	ldr	r0, [pc, #348]	; fffd1434 <Sweep_Trim_InputDQS_Offset+0x33c>
fffd12d4:	e1a0300c 	mov	r3, r12
fffd12d8:	e88d00c0 	stm	sp, {r6, r7}
fffd12dc:	e58dc014 	str	r12, [sp, #20]
fffd12e0:	e08f0000 	add	r0, pc, r0
fffd12e4:	eb000d04 	bl	fffd46fc <LogMessage>
					IsReachLimit = TRUE;
fffd12e8:	e59dc014 	ldr	r12, [sp, #20]
fffd12ec:	e3a03001 	mov	r3, #1
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = TmpTrimDQS[ilane];
			DqsTrim_int += SweepDirection;
			TmpTrimDQS[ilane] = DqsTrim_int;
			for (ibit=0; ibit<8; ibit++) 
fffd12f0:	e2877001 	add	r7, r7, #1
fffd12f4:	e3570008 	cmp	r7, #8
fffd12f8:	1affffd8 	bne	fffd1260 <Sweep_Trim_InputDQS_Offset+0x168>
		}
		
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd12fc:	e2866001 	add	r6, r6, #1
fffd1300:	e3560003 	cmp	r6, #3
fffd1304:	1affffcd 	bne	fffd1240 <Sweep_Trim_InputDQS_Offset+0x148>
					IsReachLimit = TRUE;
				}
			}
		}
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
fffd1308:	e3530001 	cmp	r3, #1
				break; // done
			}
		}
		else
		{
			Offset += SweepDirection;
fffd130c:	10844009 	addne	r4, r4, r9
					IsReachLimit = TRUE;
				}
			}
		}
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
fffd1310:	1a000013 	bne	fffd1364 <Sweep_Trim_InputDQS_Offset+0x26c>
		{
			if (SweepDirection>0)
fffd1314:	e3590001 	cmp	r9, #1
fffd1318:	1a00000a 	bne	fffd1348 <Sweep_Trim_InputDQS_Offset+0x250>
			{ // change sweep direction to negative (0, -1...-63)
				MemCpy (TmpTrimDQS, OriginTrimDQS, sizeof(TmpTrimDQS)); // copy origin values to tmp array 
fffd131c:	e28d0024 	add	r0, sp, #36	; 0x24
fffd1320:	e28d1018 	add	r1, sp, #24
fffd1324:	e3a0200c 	mov	r2, #12
				if ((LastResoults!=0x0000) && (Offset!=0))
					MarginP = (UINT8)(Offset-SweepDirection); 
				else
					MarginP = (UINT8)(Offset); 
				Offset = 0;
				SweepDirection *= -1;
fffd1328:	e3e09000 	mvn	r9, #0
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
		{
			if (SweepDirection>0)
			{ // change sweep direction to negative (0, -1...-63)
				MemCpy (TmpTrimDQS, OriginTrimDQS, sizeof(TmpTrimDQS)); // copy origin values to tmp array 
fffd132c:	eb000e03 	bl	fffd4b40 <MemCpy>
				if ((LastResoults!=0x0000) && (Offset!=0))
fffd1330:	e35a0000 	cmp	r10, #0
fffd1334:	13540000 	cmpne	r4, #0
					MarginP = (UINT8)(Offset-SweepDirection); 
fffd1338:	12444001 	subne	r4, r4, #1
				else
					MarginP = (UINT8)(Offset); 
fffd133c:	e6ef8074 	uxtb	r8, r4
				Offset = 0;
fffd1340:	e3a04000 	mov	r4, #0
fffd1344:	ea000006 	b	fffd1364 <Sweep_Trim_InputDQS_Offset+0x26c>
				SweepDirection *= -1;
				IsReachLimit = FALSE;
			}
			else
			{
				if ((LastResoults!=0x0000) && (Offset!=0))
fffd1348:	e3540000 	cmp	r4, #0
fffd134c:	135a0000 	cmpne	r10, #0
					MarginM = (UINT8)(abs(Offset-SweepDirection)); 
fffd1350:	10694004 	rsbne	r4, r9, r4
				else
					MarginM = (UINT8)(abs(Offset)); 
fffd1354:	e3540000 	cmp	r4, #0
fffd1358:	b2644000 	rsblt	r4, r4, #0
fffd135c:	e6ef4074 	uxtb	r4, r4
fffd1360:	ea000003 	b	fffd1374 <Sweep_Trim_InputDQS_Offset+0x27c>
		else
		{
			Offset += SweepDirection;
		}
		//-----------------------------------------------
		if (CheckForAbort()!=0)
fffd1364:	ebfffe4b 	bl	fffd0c98 <CheckForAbort>
fffd1368:	e3500000 	cmp	r0, #0
fffd136c:	0affff90 	beq	fffd11b4 <Sweep_Trim_InputDQS_Offset+0xbc>
{
	UINT32 ilane,ibit;
	int OriginTrimDQS[3], OriginTrimDQ[3][8];
	int TmpTrimDQS[3];
	int SweepDirection;
	UINT8 MarginP=0, MarginM=0;
fffd1370:	e3a04000 	mov	r4, #0
			break;
	}
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd1374:	e3a03000 	mov	r3, #0
	{
		if (DqMask[ilane]) // DqMask: 1-skip, 0-test
fffd1378:	e79b2103 	ldr	r2, [r11, r3, lsl #2]
fffd137c:	e3520000 	cmp	r2, #0
fffd1380:	1a000006 	bne	fffd13a0 <Sweep_Trim_InputDQS_Offset+0x2a8>
			continue;
		DqsTrim_int = OriginTrimDQS[ilane];
		DqsTrim = (UINT8)DqsTrim_int;
fffd1384:	e28d2018 	add	r2, sp, #24
fffd1388:	e0631183 	rsb	r1, r3, r3, lsl #3
fffd138c:	e7d22103 	ldrb	r2, [r2, r3, lsl #2]
fffd1390:	e2811b02 	add	r1, r1, #2048	; 0x800
		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1394:	e585112c 	str	r1, [r5, #300]	; 0x12c
		WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqsTrim);
fffd1398:	e3822080 	orr	r2, r2, #128	; 0x80
fffd139c:	e5852194 	str	r2, [r5, #404]	; 0x194
			break;
	}
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd13a0:	e2833001 	add	r3, r3, #1
fffd13a4:	e3530003 	cmp	r3, #3
fffd13a8:	1afffff2 	bne	fffd1378 <Sweep_Trim_InputDQS_Offset+0x280>
		DqsTrim = (UINT8)DqsTrim_int;
		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		WRITE_REG (IP_DQ_DQS_BITWISE_TRIM, 0x80 | DqsTrim);
	}
	MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd13ac:	e3a00601 	mov	r0, #1048576	; 0x100000
fffd13b0:	e3a01602 	mov	r1, #2097152	; 0x200000
fffd13b4:	e1a02000 	mov	r2, r0
fffd13b8:	eb000dd2 	bl	fffd4b08 <MemCmp>
	//--------------------------------------------------------------------------
	// Restouls
	LogMessage ("(%s) Round-Trip Margin:  Min required: +/-%u;  Measured: -%u/+%u. ", Title, ReqMargin, MarginM, MarginP);
fffd13bc:	e59f0074 	ldr	r0, [pc, #116]	; fffd1438 <Sweep_Trim_InputDQS_Offset+0x340>
fffd13c0:	e1a03004 	mov	r3, r4
fffd13c4:	e58d8000 	str	r8, [sp]
fffd13c8:	e59d100c 	ldr	r1, [sp, #12]
fffd13cc:	e08f0000 	add	r0, pc, r0
fffd13d0:	e59d2008 	ldr	r2, [sp, #8]
fffd13d4:	eb000cc8 	bl	fffd46fc <LogMessage>
	if ((MarginM >= ReqMargin) &&  (MarginP >= ReqMargin))
fffd13d8:	e59d3008 	ldr	r3, [sp, #8]
fffd13dc:	e1580003 	cmp	r8, r3
fffd13e0:	21540003 	cmpcs	r4, r3
fffd13e4:	3a000004 	bcc	fffd13fc <Sweep_Trim_InputDQS_Offset+0x304>
	{
		LogPass (" ==> PASS \n\n");
fffd13e8:	e59f004c 	ldr	r0, [pc, #76]	; fffd143c <Sweep_Trim_InputDQS_Offset+0x344>
fffd13ec:	e08f0000 	add	r0, pc, r0
fffd13f0:	eb000d0d 	bl	fffd482c <LogPass>
		return (0);
fffd13f4:	e3a00000 	mov	r0, #0
fffd13f8:	ea000003 	b	fffd140c <Sweep_Trim_InputDQS_Offset+0x314>
	}
	else
	{
		LogError (" ==> FAIL \n\n");
fffd13fc:	e59f003c 	ldr	r0, [pc, #60]	; fffd1440 <Sweep_Trim_InputDQS_Offset+0x348>
fffd1400:	e08f0000 	add	r0, pc, r0
fffd1404:	eb000ce8 	bl	fffd47ac <LogError>
		return (1);
fffd1408:	e3a00001 	mov	r0, #1
	}
}
fffd140c:	e28dd094 	add	sp, sp, #148	; 0x94
fffd1410:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
fffd1414:	00006164 	.word	0x00006164
fffd1418:	0000001c 	.word	0x0000001c
fffd141c:	00004ba8 	.word	0x00004ba8
fffd1420:	00004b96 	.word	0x00004b96
fffd1424:	f05f0000 	.word	0xf05f0000
fffd1428:	000049ad 	.word	0x000049ad
fffd142c:	000049ac 	.word	0x000049ac
fffd1430:	00004a50 	.word	0x00004a50
fffd1434:	00004941 	.word	0x00004941
fffd1438:	00004955 	.word	0x00004955
fffd143c:	000048c8 	.word	0x000048c8
fffd1440:	000048c1 	.word	0x000048c1

fffd1444 <Sweep_Trim_OutputDQ_Offset>:
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_OutputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd1444:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
fffd1448:	e24ddf45 	sub	sp, sp, #276	; 0x114
fffd144c:	e59f3380 	ldr	r3, [pc, #896]	; fffd17d4 <Sweep_Trim_OutputDQ_Offset+0x390>
fffd1450:	e1a0b000 	mov	r11, r0
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd1454:	e3a04000 	mov	r4, #0
		return (1);
	}
}
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_OutputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd1458:	e58d201c 	str	r2, [sp, #28]
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd145c:	e59f2374 	ldr	r2, [pc, #884]	; fffd17d8 <Sweep_Trim_OutputDQ_Offset+0x394>
		return (1);
	}
}
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_OutputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd1460:	e08f3003 	add	r3, pc, r3
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;

	LogMessage ("\n");
fffd1464:	e59f0370 	ldr	r0, [pc, #880]	; fffd17dc <Sweep_Trim_OutputDQ_Offset+0x398>
		return (1);
	}
}
///---------------------------------------------------------------------------------------------------------------------
BOOL Sweep_Trim_OutputDQ_Offset (UINT32 DqMask[], UINT8 ReqMargin, char *Title)
{
fffd1468:	e58d1018 	str	r1, [sp, #24]
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd146c:	e7933002 	ldr	r3, [r3, r2]

	LogMessage ("\n");
fffd1470:	e08f0000 	add	r0, pc, r0
	UINT8 DqTrim, DqsTrim;
	int DqTrim_int, DqsTrim_int; 
	int DelayLine_int;
	int Offset;

	g_KeyPress = 0;
fffd1474:	e5c34000 	strb	r4, [r3]

	LogMessage ("\n");
fffd1478:	eb000c9f 	bl	fffd46fc <LogMessage>
	LogHeader (" Sweep Output DQ Delay Relative to DQS (%s)", Title);
fffd147c:	e59f035c 	ldr	r0, [pc, #860]	; fffd17e0 <Sweep_Trim_OutputDQ_Offset+0x39c>
fffd1480:	e59d101c 	ldr	r1, [sp, #28]
fffd1484:	e08f0000 	add	r0, pc, r0
fffd1488:	eb000cf7 	bl	fffd486c <LogHeader>
fffd148c:	e28d3038 	add	r3, sp, #56	; 0x38
fffd1490:	e3a08024 	mov	r8, #36	; 0x24
fffd1494:	e0283498 	mla	r8, r8, r4, r3
fffd1498:	e58d300c 	str	r3, [sp, #12]
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<9; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
fffd149c:	e0647184 	rsb	r7, r4, r4, lsl #3
fffd14a0:	e3a06000 	mov	r6, #0
fffd14a4:	e59f5338 	ldr	r5, [pc, #824]	; fffd17e4 <Sweep_Trim_OutputDQ_Offset+0x3a0>
fffd14a8:	e0873406 	add	r3, r7, r6, lsl #8
fffd14ac:	e585312c 	str	r3, [r5, #300]	; 0x12c
			DqTrim = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F);
fffd14b0:	e59501a0 	ldr	r0, [r5, #416]	; 0x1a0
			OriginTrimDQ [ilane][ibit] = DQ_to_INT (DqTrim);
fffd14b4:	e200007f 	and	r0, r0, #127	; 0x7f
fffd14b8:	ebfffe12 	bl	fffd0d08 <DQ_to_INT>
fffd14bc:	e7880106 	str	r0, [r8, r6, lsl #2]
	//--------------------------------------------------------------------------
	// Get default trim values
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<9; ibit++) 
fffd14c0:	e2866001 	add	r6, r6, #1
fffd14c4:	e3560009 	cmp	r6, #9
fffd14c8:	1afffff5 	bne	fffd14a4 <Sweep_Trim_OutputDQ_Offset+0x60>
fffd14cc:	e2877c09 	add	r7, r7, #2304	; 0x900
			//LogMessage ("DQn[%lu][%lu]=0x%02x(%d).\n", ilane, ibit, DqTrim, OriginTrimDQ[ilane][ibit]);
		}
		ibit = 9;
		WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
		DqsTrim = (UINT8)(READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F);
		OriginTrimDQS[ilane] = (int)(DqsTrim);
fffd14d0:	e28d202c 	add	r2, sp, #44	; 0x2c
			DqTrim = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F);
			OriginTrimDQ [ilane][ibit] = DQ_to_INT (DqTrim);
			//LogMessage ("DQn[%lu][%lu]=0x%02x(%d).\n", ilane, ibit, DqTrim, OriginTrimDQ[ilane][ibit]);
		}
		ibit = 9;
		WRITE_REG (PHY_LANE_SEL, (ilane*7)+((UINT32)ibit<<8));
fffd14d4:	e585712c 	str	r7, [r5, #300]	; 0x12c
		DqsTrim = (UINT8)(READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F);
fffd14d8:	e59531a0 	ldr	r3, [r5, #416]	; 0x1a0
		OriginTrimDQS[ilane] = (int)(DqsTrim);
fffd14dc:	e203307f 	and	r3, r3, #127	; 0x7f
fffd14e0:	e7823104 	str	r3, [r2, r4, lsl #2]
	//--------------------------------------------------------------------------

	//--------------------------------------------------------------------------
	// Get default trim values
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd14e4:	e2844001 	add	r4, r4, #1
fffd14e8:	e3540003 	cmp	r4, #3
fffd14ec:	1affffe6 	bne	fffd148c <Sweep_Trim_OutputDQ_Offset+0x48>
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
	IsReachLimit = FALSE;
	SweepDirection = 1;  // starting with up. 
	Offset = 0;
fffd14f0:	e3a04000 	mov	r4, #0
		//LogMessage ("DQS[%lu]=0x%02x(%d).\n", ilane, DqsTrim, OriginTrimDQS[ilane]);
	}
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
fffd14f4:	e28d30a4 	add	r3, sp, #164	; 0xa4
{
	UINT32 ilane,ibit;
	int OriginTrimDQS[3], OriginTrimDQ[3][9];
	int TmpTrimDQ[3][9];
	int SweepDirection;
	UINT8 MarginP=0, MarginM=0;
fffd14f8:	e1a08004 	mov	r8, r4
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
	IsReachLimit = FALSE;
	SweepDirection = 1;  // starting with up. 
fffd14fc:	e3a09001 	mov	r9, #1
		//LogMessage ("DQS[%lu]=0x%02x(%d).\n", ilane, DqsTrim, OriginTrimDQS[ilane]);
	}
	//--------------------------------------------------------------------------
	// Sweep .... 
	//--------------------------------------------------------------------------
	MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp array  
fffd1500:	e1a00003 	mov	r0, r3
fffd1504:	e59d100c 	ldr	r1, [sp, #12]
fffd1508:	e3a0206c 	mov	r2, #108	; 0x6c
fffd150c:	e58d3020 	str	r3, [sp, #32]
fffd1510:	eb000d8a 	bl	fffd4b40 <MemCpy>
	while (1)
	{
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd1514:	e3a06000 	mov	r6, #0
fffd1518:	e3a0a024 	mov	r10, #36	; 0x24
fffd151c:	e28d20a4 	add	r2, sp, #164	; 0xa4
fffd1520:	e02a269a 	mla	r10, r10, r6, r2
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1524:	e0663186 	rsb	r3, r6, r6, lsl #3
fffd1528:	e3a07000 	mov	r7, #0
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			for (ibit=0; ibit<9; ibit++) 
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
fffd152c:	e79b2106 	ldr	r2, [r11, r6, lsl #2]
fffd1530:	e1a02732 	lsr	r2, r2, r7
fffd1534:	e3120001 	tst	r2, #1
fffd1538:	1a000009 	bne	fffd1564 <Sweep_Trim_OutputDQ_Offset+0x120>
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
fffd153c:	e79a0107 	ldr	r0, [r10, r7, lsl #2]
fffd1540:	e58d3010 	str	r3, [sp, #16]
fffd1544:	ebfffdf7 	bl	fffd0d28 <INT_to_DQ>
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1548:	e59d3010 	ldr	r3, [sp, #16]
				WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd154c:	e1e00c80 	mvn	r0, r0, lsl #25
fffd1550:	e1e00ca0 	mvn	r0, r0, lsr #25
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1554:	e0832407 	add	r2, r3, r7, lsl #8
				WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd1558:	e6ef0070 	uxtb	r0, r0
			{ 
				if ( (DqMask[ilane]) & ((UINT32)1<<ibit) ) // DqMask: 1-skip, 0-test
					continue;		
				DqTrim_int = TmpTrimDQ[ilane][ibit];
				DqTrim = INT_to_DQ (DqTrim_int);
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd155c:	e585212c 	str	r2, [r5, #300]	; 0x12c
				WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd1560:	e58501a0 	str	r0, [r5, #416]	; 0x1a0
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			for (ibit=0; ibit<9; ibit++) 
fffd1564:	e2877001 	add	r7, r7, #1
fffd1568:	e3570009 	cmp	r7, #9
fffd156c:	1affffee 	bne	fffd152c <Sweep_Trim_OutputDQ_Offset+0xe8>
	while (1)
	{
		//-----------------------------------------------
		// update trim values
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd1570:	e2866001 	add	r6, r6, #1
fffd1574:	e3560003 	cmp	r6, #3
fffd1578:	1affffe6 	bne	fffd1518 <Sweep_Trim_OutputDQ_Offset+0xd4>
				WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
				WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
				//LogMessage ("DQn[%lu][%lu]<=0x%02x(%d).\n", ilane, ibit, DqTrim, DqTrim_int);
			}
		}
		if (Offset==0)
fffd157c:	e3540000 	cmp	r4, #0
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd1580:	e3a00601 	mov	r0, #1048576	; 0x100000
fffd1584:	01a02000 	moveq	r2, r0
		else
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Short); // dummy access to memory in order for values to update 
fffd1588:	13a02801 	movne	r2, #65536	; 0x10000
				WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
				//LogMessage ("DQn[%lu][%lu]<=0x%02x(%d).\n", ilane, ibit, DqTrim, DqTrim_int);
			}
		}
		if (Offset==0)
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd158c:	e3a01602 	mov	r1, #2097152	; 0x200000
		else
			MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Short); // dummy access to memory in order for values to update 
fffd1590:	eb000d5c 	bl	fffd4b08 <MemCmp>
		//-----------------------------------------------
		// Test the memory
		//-----------------------------------------------
		LastResoults = MemStressTest ();
fffd1594:	eb0006d0 	bl	fffd30dc <MemStressTest>
fffd1598:	e1a0a000 	mov	r10, r0
		LogMessage ("> Offset %3d: 0x%04X \n",Offset, LastResoults); 
fffd159c:	e59f0244 	ldr	r0, [pc, #580]	; fffd17e8 <Sweep_Trim_OutputDQ_Offset+0x3a4>
fffd15a0:	e1a01004 	mov	r1, r4
fffd15a4:	e1a0200a 	mov	r2, r10
fffd15a8:	e08f0000 	add	r0, pc, r0
fffd15ac:	eb000c52 	bl	fffd46fc <LogMessage>

		//-----------------------------------------------
		// Check resoult limits 
		//-----------------------------------------------
		if (LastResoults!=0x0000)
fffd15b0:	e35a0000 	cmp	r10, #0
fffd15b4:	01a0300a 	moveq	r3, r10
fffd15b8:	0a000003 	beq	fffd15cc <Sweep_Trim_OutputDQ_Offset+0x188>
		{
			LogMessage ("---------- \n");
fffd15bc:	e59f0228 	ldr	r0, [pc, #552]	; fffd17ec <Sweep_Trim_OutputDQ_Offset+0x3a8>
fffd15c0:	e08f0000 	add	r0, pc, r0
fffd15c4:	eb000c4c 	bl	fffd46fc <LogMessage>
			IsReachLimit = TRUE;
fffd15c8:	e3a03001 	mov	r3, #1
fffd15cc:	e3a06000 	mov	r6, #0
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = OriginTrimDQS[ilane];
fffd15d0:	e28d202c 	add	r2, sp, #44	; 0x2c
fffd15d4:	e3a01024 	mov	r1, #36	; 0x24
fffd15d8:	e7922106 	ldr	r2, [r2, r6, lsl #2]
			for (ibit=0; ibit<9; ibit++) 
fffd15dc:	e3a07000 	mov	r7, #0
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = OriginTrimDQS[ilane];
fffd15e0:	e58d2010 	str	r2, [sp, #16]
fffd15e4:	e28d20a4 	add	r2, sp, #164	; 0xa4
fffd15e8:	e0222691 	mla	r2, r1, r6, r2
fffd15ec:	e58d2014 	str	r2, [sp, #20]
			for (ibit=0; ibit<9; ibit++) 
			{
				if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
fffd15f0:	e79b2106 	ldr	r2, [r11, r6, lsl #2]
fffd15f4:	e1a02732 	lsr	r2, r2, r7
fffd15f8:	e2122001 	ands	r2, r2, #1
fffd15fc:	1a000021 	bne	fffd1688 <Sweep_Trim_OutputDQ_Offset+0x244>
					continue;
				DqTrim_int = TmpTrimDQ[ilane][ibit];
fffd1600:	e59d1014 	ldr	r1, [sp, #20]
				DqTrim_int += SweepDirection;
				TmpTrimDQ[ilane][ibit] = DqTrim_int;
				if ( (IsReachLimit!=TRUE) && ((DqTrim_int>63) || (DqTrim_int<-63)) )
fffd1604:	e3530001 	cmp	r3, #1
			DqsTrim_int = OriginTrimDQS[ilane];
			for (ibit=0; ibit<9; ibit++) 
			{
				if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
					continue;
				DqTrim_int = TmpTrimDQ[ilane][ibit];
fffd1608:	e791c107 	ldr	r12, [r1, r7, lsl #2]
				DqTrim_int += SweepDirection;
fffd160c:	e08cc009 	add	r12, r12, r9
				TmpTrimDQ[ilane][ibit] = DqTrim_int;
fffd1610:	e781c107 	str	r12, [r1, r7, lsl #2]
				if ( (IsReachLimit!=TRUE) && ((DqTrim_int>63) || (DqTrim_int<-63)) )
fffd1614:	0a00000c 	beq	fffd164c <Sweep_Trim_OutputDQ_Offset+0x208>
fffd1618:	e28c303f 	add	r3, r12, #63	; 0x3f
fffd161c:	e353007e 	cmp	r3, #126	; 0x7e
fffd1620:	91a03002 	movls	r3, r2
fffd1624:	9a000008 	bls	fffd164c <Sweep_Trim_OutputDQ_Offset+0x208>
				{

					LogMessage ("--- trim limit --- (DqTrim_int:%d, ilane:%u, ibit:%u) \n", DqTrim_int, ilane, ibit);
fffd1628:	e59f01c0 	ldr	r0, [pc, #448]	; fffd17f0 <Sweep_Trim_OutputDQ_Offset+0x3ac>
fffd162c:	e1a0100c 	mov	r1, r12
fffd1630:	e1a03007 	mov	r3, r7
fffd1634:	e1a02006 	mov	r2, r6
fffd1638:	e58dc024 	str	r12, [sp, #36]	; 0x24
fffd163c:	e08f0000 	add	r0, pc, r0
fffd1640:	eb000c2d 	bl	fffd46fc <LogMessage>
fffd1644:	e59dc024 	ldr	r12, [sp, #36]	; 0x24
					IsReachLimit = TRUE;
fffd1648:	e3a03001 	mov	r3, #1
				}

				DelayLine_int = DqTrim_int + DqsTrim_int;
fffd164c:	e59d2010 	ldr	r2, [sp, #16]
fffd1650:	e08c1002 	add	r1, r12, r2
fffd1654:	e2232001 	eor	r2, r3, #1
				if ( (IsReachLimit!=TRUE) && ((DelayLine_int>63) || (DelayLine_int<0)) )
fffd1658:	e351003f 	cmp	r1, #63	; 0x3f
fffd165c:	93a02000 	movls	r2, #0
fffd1660:	82022001 	andhi	r2, r2, #1
fffd1664:	e3520000 	cmp	r2, #0
fffd1668:	0a000006 	beq	fffd1688 <Sweep_Trim_OutputDQ_Offset+0x244>
				{
					LogMessage ("--- delay-line limit --- (DelayLine:%d, DqTrim:%d, DqsTrim:%d, ilane:%u, ibit:%u) \n", DelayLine_int, DqTrim_int, DqsTrim_int, ilane, ibit);
fffd166c:	e59f0180 	ldr	r0, [pc, #384]	; fffd17f4 <Sweep_Trim_OutputDQ_Offset+0x3b0>
fffd1670:	e1a0200c 	mov	r2, r12
fffd1674:	e59d3010 	ldr	r3, [sp, #16]
fffd1678:	e88d00c0 	stm	sp, {r6, r7}
fffd167c:	e08f0000 	add	r0, pc, r0
fffd1680:	eb000c1d 	bl	fffd46fc <LogMessage>
					IsReachLimit = TRUE;
fffd1684:	e3a03001 	mov	r3, #1
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
		{
			DqsTrim_int = OriginTrimDQS[ilane];
			for (ibit=0; ibit<9; ibit++) 
fffd1688:	e2877001 	add	r7, r7, #1
fffd168c:	e3570009 	cmp	r7, #9
fffd1690:	1affffd6 	bne	fffd15f0 <Sweep_Trim_OutputDQ_Offset+0x1ac>
		}
		
		//-----------------------------------------------
		// Calculate next step and check trim and delay-line limits
		//-----------------------------------------------
		for (ilane=0; ilane<3; ilane++)
fffd1694:	e2866001 	add	r6, r6, #1
fffd1698:	e3560003 	cmp	r6, #3
fffd169c:	1affffcb 	bne	fffd15d0 <Sweep_Trim_OutputDQ_Offset+0x18c>
					IsReachLimit = TRUE;
				}
			}
		}
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
fffd16a0:	e3530001 	cmp	r3, #1
				break; // done
			}
		}
		else
		{
			Offset += SweepDirection;
fffd16a4:	10844009 	addne	r4, r4, r9
					IsReachLimit = TRUE;
				}
			}
		}
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
fffd16a8:	1a000013 	bne	fffd16fc <Sweep_Trim_OutputDQ_Offset+0x2b8>
		{
			if (SweepDirection>0)
fffd16ac:	e3590001 	cmp	r9, #1
fffd16b0:	1a00000a 	bne	fffd16e0 <Sweep_Trim_OutputDQ_Offset+0x29c>
			{ // change sweep direction to negative (0, -1...-63)
				MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp  
fffd16b4:	e59d0020 	ldr	r0, [sp, #32]
fffd16b8:	e3a0206c 	mov	r2, #108	; 0x6c
fffd16bc:	e59d100c 	ldr	r1, [sp, #12]
				if ((LastResoults!=0x0000) && (Offset!=0))
					MarginP = (UINT8)(Offset-SweepDirection); 
				else
					MarginP = (UINT8)(Offset); 
				Offset = 0;
				SweepDirection *= -1;
fffd16c0:	e3e09000 	mvn	r9, #0
		//-----------------------------------------------
		if (IsReachLimit==TRUE)
		{
			if (SweepDirection>0)
			{ // change sweep direction to negative (0, -1...-63)
				MemCpy (TmpTrimDQ, OriginTrimDQ, sizeof(TmpTrimDQ)); // copy origin values to tmp  
fffd16c4:	eb000d1d 	bl	fffd4b40 <MemCpy>
				if ((LastResoults!=0x0000) && (Offset!=0))
fffd16c8:	e35a0000 	cmp	r10, #0
fffd16cc:	13540000 	cmpne	r4, #0
					MarginP = (UINT8)(Offset-SweepDirection); 
fffd16d0:	12444001 	subne	r4, r4, #1
				else
					MarginP = (UINT8)(Offset); 
fffd16d4:	e6ef8074 	uxtb	r8, r4
				Offset = 0;
fffd16d8:	e3a04000 	mov	r4, #0
fffd16dc:	ea000006 	b	fffd16fc <Sweep_Trim_OutputDQ_Offset+0x2b8>
				SweepDirection *= -1;
				IsReachLimit = FALSE;
			}
			else
			{
				if ((LastResoults!=0x0000) && (Offset!=0))
fffd16e0:	e3540000 	cmp	r4, #0
fffd16e4:	135a0000 	cmpne	r10, #0
					MarginM = (UINT8)(abs(Offset-SweepDirection)); 
fffd16e8:	10694004 	rsbne	r4, r9, r4
				else
					MarginM = (UINT8)(abs(Offset)); 
fffd16ec:	e3540000 	cmp	r4, #0
fffd16f0:	b2644000 	rsblt	r4, r4, #0
fffd16f4:	e6ef4074 	uxtb	r4, r4
fffd16f8:	ea000003 	b	fffd170c <Sweep_Trim_OutputDQ_Offset+0x2c8>
		else
		{
			Offset += SweepDirection;
		}
		//-----------------------------------------------
		if (CheckForAbort()!=0)
fffd16fc:	ebfffd65 	bl	fffd0c98 <CheckForAbort>
fffd1700:	e3500000 	cmp	r0, #0
fffd1704:	0affff82 	beq	fffd1514 <Sweep_Trim_OutputDQ_Offset+0xd0>
{
	UINT32 ilane,ibit;
	int OriginTrimDQS[3], OriginTrimDQ[3][9];
	int TmpTrimDQ[3][9];
	int SweepDirection;
	UINT8 MarginP=0, MarginM=0;
fffd1708:	e3a04000 	mov	r4, #0
			break;
	}
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd170c:	e3a06000 	mov	r6, #0
fffd1710:	e3a09024 	mov	r9, #36	; 0x24
fffd1714:	e28d3038 	add	r3, sp, #56	; 0x38
fffd1718:	e0293699 	mla	r9, r9, r6, r3
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd171c:	e066a186 	rsb	r10, r6, r6, lsl #3
fffd1720:	e3a07000 	mov	r7, #0
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<9; ibit++) 
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
fffd1724:	e79b3106 	ldr	r3, [r11, r6, lsl #2]
fffd1728:	e1a03733 	lsr	r3, r3, r7
fffd172c:	e3130001 	tst	r3, #1
fffd1730:	1a000007 	bne	fffd1754 <Sweep_Trim_OutputDQ_Offset+0x310>
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
fffd1734:	e7990107 	ldr	r0, [r9, r7, lsl #2]
fffd1738:	ebfffd7a 	bl	fffd0d28 <INT_to_DQ>
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd173c:	e1e00c80 	mvn	r0, r0, lsl #25
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1740:	e08a3407 	add	r3, r10, r7, lsl #8
			WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd1744:	e1e00ca0 	mvn	r0, r0, lsr #25
		{
			if (DqMask[ilane]&((UINT32)1<<ibit)) // DqMask: 1-skip, 0-test
				continue;
			DqTrim_int = OriginTrimDQ[ilane][ibit];
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1748:	e585312c 	str	r3, [r5, #300]	; 0x12c
			WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
fffd174c:	e6ef0070 	uxtb	r0, r0
fffd1750:	e58501a0 	str	r0, [r5, #416]	; 0x1a0
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
	{
		for (ibit=0; ibit<9; ibit++) 
fffd1754:	e2877001 	add	r7, r7, #1
fffd1758:	e3570009 	cmp	r7, #9
fffd175c:	1afffff0 	bne	fffd1724 <Sweep_Trim_OutputDQ_Offset+0x2e0>
			break;
	}
	//--------------------------------------------------------------------------
	// restore origin trim values 
	//--------------------------------------------------------------------------
	for (ilane=0; ilane<3; ilane++)
fffd1760:	e2866001 	add	r6, r6, #1
fffd1764:	e3560003 	cmp	r6, #3
fffd1768:	1affffe8 	bne	fffd1710 <Sweep_Trim_OutputDQ_Offset+0x2cc>
			DqTrim = INT_to_DQ (DqTrim_int);
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			WRITE_REG (OP_DQ_DM_DQS_BITWISE_TRIM, 0x80 | DqTrim);
		}
	}
	MemCmp((void*)DDR_ADDR_BASE, (void*)DDR_ADDR_BASE+(1024*1024), Dummy_Delay_Long); // dummy access to memory in order for values to update 
fffd176c:	e3a00601 	mov	r0, #1048576	; 0x100000
fffd1770:	e3a01602 	mov	r1, #2097152	; 0x200000
fffd1774:	e1a02000 	mov	r2, r0
fffd1778:	eb000ce2 	bl	fffd4b08 <MemCmp>
	//--------------------------------------------------------------------------
	// Restouls
	LogMessage ("(%s) OutputDQ Margin: Min required: +/-%u;  Measured: -%u/+%u. ", Title, ReqMargin, MarginM, MarginP);
fffd177c:	e59f0074 	ldr	r0, [pc, #116]	; fffd17f8 <Sweep_Trim_OutputDQ_Offset+0x3b4>
fffd1780:	e1a03004 	mov	r3, r4
fffd1784:	e58d8000 	str	r8, [sp]
fffd1788:	e59d101c 	ldr	r1, [sp, #28]
fffd178c:	e08f0000 	add	r0, pc, r0
fffd1790:	e59d2018 	ldr	r2, [sp, #24]
fffd1794:	eb000bd8 	bl	fffd46fc <LogMessage>
	if ((MarginM >= ReqMargin) &&  (MarginP >= ReqMargin))
fffd1798:	e59d3018 	ldr	r3, [sp, #24]
fffd179c:	e1580003 	cmp	r8, r3
fffd17a0:	21540003 	cmpcs	r4, r3
fffd17a4:	3a000004 	bcc	fffd17bc <Sweep_Trim_OutputDQ_Offset+0x378>
	{
		LogPass (" ==> PASS \n\n");
fffd17a8:	e59f004c 	ldr	r0, [pc, #76]	; fffd17fc <Sweep_Trim_OutputDQ_Offset+0x3b8>
fffd17ac:	e08f0000 	add	r0, pc, r0
fffd17b0:	eb000c1d 	bl	fffd482c <LogPass>
		return (0);
fffd17b4:	e3a00000 	mov	r0, #0
fffd17b8:	ea000003 	b	fffd17cc <Sweep_Trim_OutputDQ_Offset+0x388>
	}
	else
	{
		LogError (" ==> FAIL \n\n");
fffd17bc:	e59f003c 	ldr	r0, [pc, #60]	; fffd1800 <Sweep_Trim_OutputDQ_Offset+0x3bc>
fffd17c0:	e08f0000 	add	r0, pc, r0
fffd17c4:	eb000bf8 	bl	fffd47ac <LogError>
		return (1);
fffd17c8:	e3a00001 	mov	r0, #1
	}
}
fffd17cc:	e28ddf45 	add	sp, sp, #276	; 0x114
fffd17d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
fffd17d4:	00005e18 	.word	0x00005e18
fffd17d8:	0000001c 	.word	0x0000001c
fffd17dc:	0000485c 	.word	0x0000485c
fffd17e0:	000048e0 	.word	0x000048e0
fffd17e4:	f05f0000 	.word	0xf05f0000
fffd17e8:	0000461d 	.word	0x0000461d
fffd17ec:	0000461c 	.word	0x0000461c
fffd17f0:	000045ad 	.word	0x000045ad
fffd17f4:	000045a5 	.word	0x000045a5
fffd17f8:	00004604 	.word	0x00004604
fffd17fc:	00004508 	.word	0x00004508
fffd1800:	00004501 	.word	0x00004501

fffd1804 <WriteModeReg>:
	// 25: trigger

	//LogMessage ("\nWrite to MR%u data 0x%08lX\n", Index, Data);

	// clear all status bits
	IOW32(MC_BASE_ADDR + (117*4), -1); // DENALI_CTL_117
fffd1804:	e59f307c 	ldr	r3, [pc, #124]	; fffd1888 <WriteModeReg+0x84>
fffd1808:	e3e02000 	mvn	r2, #0
	*Step = (MPR2[1]>>1) & 0x3F;
	*Range = MPR2[1]>>7;
}
//----------------------------------------------------------------------
int WriteModeReg (UINT8 Index, UINT32 Data)
{
fffd180c:	e92d4010 	push	{r4, lr}

	UINT32 WRITE_MODEREG = (UINT32)1<<25 | (UINT32)1<<17 ; // write to CS 0, to all DDR4 MR registers  
*/
	
	IOW32(MC_BASE_ADDR + (85*4), Data); // DENALI_CTL_85.MRSINGLE_DATA_0
	UINT32 WRITE_MODEREG = (UINT32)1<<25 | (UINT32)1<<23 | Index; // write to CS 0, to MR specify in bits 7:0 
fffd1810:	e380050a 	orr	r0, r0, #41943040	; 0x2800000
	// 25: trigger

	//LogMessage ("\nWrite to MR%u data 0x%08lX\n", Index, Data);

	// clear all status bits
	IOW32(MC_BASE_ADDR + (117*4), -1); // DENALI_CTL_117
fffd1814:	e58321d4 	str	r2, [r3, #468]	; 0x1d4
*/
	
	IOW32(MC_BASE_ADDR + (85*4), Data); // DENALI_CTL_85.MRSINGLE_DATA_0
	UINT32 WRITE_MODEREG = (UINT32)1<<25 | (UINT32)1<<23 | Index; // write to CS 0, to MR specify in bits 7:0 

	IOW32(MC_BASE_ADDR + (70*4), WRITE_MODEREG); // DENALI_CTL_70
fffd1818:	e3022711 	movw	r2, #10001	; 0x2711
	}

	UINT32 WRITE_MODEREG = (UINT32)1<<25 | (UINT32)1<<17 ; // write to CS 0, to all DDR4 MR registers  
*/
	
	IOW32(MC_BASE_ADDR + (85*4), Data); // DENALI_CTL_85.MRSINGLE_DATA_0
fffd181c:	e5831154 	str	r1, [r3, #340]	; 0x154
	UINT32 WRITE_MODEREG = (UINT32)1<<25 | (UINT32)1<<23 | Index; // write to CS 0, to MR specify in bits 7:0 

	IOW32(MC_BASE_ADDR + (70*4), WRITE_MODEREG); // DENALI_CTL_70
fffd1820:	e5830118 	str	r0, [r3, #280]	; 0x118
	//LogMessage ("DENALI_CTL_116 = 0x%08lX \n",IOR32(MC_BASE_ADDR + (116*4)));

	UINT32 TimeOut=10000;
	while (1)
	{
		if ( ((IOR32(MC_BASE_ADDR + (116*4))>>25) & 0x01) == 0x01)  // DENALI_CTL_116.25
fffd1824:	e59311d0 	ldr	r1, [r3, #464]	; 0x1d0
fffd1828:	e59f4058 	ldr	r4, [pc, #88]	; fffd1888 <WriteModeReg+0x84>
fffd182c:	e3110402 	tst	r1, #33554432	; 0x2000000
fffd1830:	0a000005 	beq	fffd184c <WriteModeReg+0x48>
		{
			if  ( (IOR32(MC_BASE_ADDR + (71*4)) & 0xFF) == 0x01 ) // DENALI_CTL_71.MRW_STATUS
fffd1834:	e594011c 	ldr	r0, [r4, #284]	; 0x11c
fffd1838:	e6ef0070 	uxtb	r0, r0
fffd183c:	e3500001 	cmp	r0, #1
fffd1840:	13a00000 	movne	r0, #0
fffd1844:	03e00000 	mvneq	r0, #0
fffd1848:	e8bd8010 	pop	{r4, pc}
				return (-1);
			else
				return (0);
		}

		if (TimeOut==0)
fffd184c:	e2522001 	subs	r2, r2, #1
fffd1850:	1afffff3 	bne	fffd1824 <WriteModeReg+0x20>
		{
			LogError ("WriteModeReg::TimeOut\n");
fffd1854:	e59f0030 	ldr	r0, [pc, #48]	; fffd188c <WriteModeReg+0x88>
fffd1858:	e08f0000 	add	r0, pc, r0
fffd185c:	eb000bd2 	bl	fffd47ac <LogError>
			LogMessage ("DENALI_CTL_116 = 0x%08lX \n",IOR32(MC_BASE_ADDR + (116*4)));
fffd1860:	e59f0028 	ldr	r0, [pc, #40]	; fffd1890 <WriteModeReg+0x8c>
fffd1864:	e59411d0 	ldr	r1, [r4, #464]	; 0x1d0
fffd1868:	e08f0000 	add	r0, pc, r0
fffd186c:	eb000ba2 	bl	fffd46fc <LogMessage>
			LogMessage ("DENALI_CTL_71 = 0x%08lX \n",IOR32(MC_BASE_ADDR + (71*4)));
fffd1870:	e59f001c 	ldr	r0, [pc, #28]	; fffd1894 <WriteModeReg+0x90>
fffd1874:	e594111c 	ldr	r1, [r4, #284]	; 0x11c
fffd1878:	e08f0000 	add	r0, pc, r0
fffd187c:	eb000b9e 	bl	fffd46fc <LogMessage>
fffd1880:	e3e00000 	mvn	r0, #0
			return (-1);
		}

		TimeOut--;
	}
}
fffd1884:	e8bd8010 	pop	{r4, pc}
fffd1888:	f0824000 	.word	0xf0824000
fffd188c:	00004578 	.word	0x00004578
fffd1890:	0000457f 	.word	0x0000457f
fffd1894:	0000458a 	.word	0x0000458a

fffd1898 <MPR_Readout_RawData>:
*/
//----------------------------------------------------------------------
// Readout: array of UINT16 * 8 * 4.
//----------------------------------------------------------------------
void MPR_Readout_RawData (UINT8 Page, UINT16 *RawData)
{
fffd1898:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	UINT32 MC_MR3;
	UINT32 MPR_Page_Offset; 
	int status;

	MemSet (RawData,0x00,2*8*4);
fffd189c:	e3a02040 	mov	r2, #64	; 0x40

	MC_MR3 = IOR32(MC_BASE_ADDR + (86*4)) & 0x1FFFF ; // ENALI_CTL_86.MR3_DATA_F0_0
fffd18a0:	e59f40bc 	ldr	r4, [pc, #188]	; fffd1964 <MPR_Readout_RawData+0xcc>
*/
//----------------------------------------------------------------------
// Readout: array of UINT16 * 8 * 4.
//----------------------------------------------------------------------
void MPR_Readout_RawData (UINT8 Page, UINT16 *RawData)
{
fffd18a4:	e1a07000 	mov	r7, r0
fffd18a8:	e1a06001 	mov	r6, r1
	UINT32 MC_MR3;
	UINT32 MPR_Page_Offset; 
	int status;

	MemSet (RawData,0x00,2*8*4);
fffd18ac:	e1a00001 	mov	r0, r1
fffd18b0:	e3a01000 	mov	r1, #0

	MC_MR3 = IOR32(MC_BASE_ADDR + (86*4)) & 0x1FFFF ; // ENALI_CTL_86.MR3_DATA_F0_0
	MC_MR3 = MC_MR3 & ~(UINT32)0x7 & ~((UINT32)3<<11); // remove MPR operation (bit 2), MPR selection (bits 1:0) and MPR Read Format (bits 12:11) 
fffd18b4:	e59f50ac 	ldr	r5, [pc, #172]	; fffd1968 <MPR_Readout_RawData+0xd0>
{
	UINT32 MC_MR3;
	UINT32 MPR_Page_Offset; 
	int status;

	MemSet (RawData,0x00,2*8*4);
fffd18b8:	eb000ca7 	bl	fffd4b5c <MemSet>

	MC_MR3 = IOR32(MC_BASE_ADDR + (86*4)) & 0x1FFFF ; // ENALI_CTL_86.MR3_DATA_F0_0
fffd18bc:	e5943158 	ldr	r3, [r4, #344]	; 0x158
	MC_MR3 = MC_MR3 & ~(UINT32)0x7 & ~((UINT32)3<<11); // remove MPR operation (bit 2), MPR selection (bits 1:0) and MPR Read Format (bits 12:11) 

	status = WriteModeReg (3, MC_MR3 | (UINT32)0<<11 /*Readout serial mode*/ | (UINT32)1<<2 /*Enable MPR*/ | (UINT32)Page<<0 /*Page number*/);	
fffd18c0:	e3a00003 	mov	r0, #3
	int status;

	MemSet (RawData,0x00,2*8*4);

	MC_MR3 = IOR32(MC_BASE_ADDR + (86*4)) & 0x1FFFF ; // ENALI_CTL_86.MR3_DATA_F0_0
	MC_MR3 = MC_MR3 & ~(UINT32)0x7 & ~((UINT32)3<<11); // remove MPR operation (bit 2), MPR selection (bits 1:0) and MPR Read Format (bits 12:11) 
fffd18c4:	e0055003 	and	r5, r5, r3
fffd18c8:	e3851004 	orr	r1, r5, #4

	status = WriteModeReg (3, MC_MR3 | (UINT32)0<<11 /*Readout serial mode*/ | (UINT32)1<<2 /*Enable MPR*/ | (UINT32)Page<<0 /*Page number*/);	
fffd18cc:	e1811007 	orr	r1, r1, r7
fffd18d0:	ebffffcb 	bl	fffd1804 <WriteModeReg>
	if (status!=0) // 05/10/2015
fffd18d4:	e3500000 	cmp	r0, #0
fffd18d8:	18bd80f8 	popne	{r3, r4, r5, r6, r7, pc}
		return;
	Sleep (10); // some delay to the DDR device to enter MPR mode
fffd18dc:	e3a0000a 	mov	r0, #10
fffd18e0:	eb000c76 	bl	fffd4ac0 <Sleep>

	// if ECC is enable, disable it.
	UINT32 ECC_Mode = REG_READ_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET);
fffd18e4:	e5943174 	ldr	r3, [r4, #372]	; 0x174
*/
//----------------------------------------------------------------------
// Readout: array of UINT16 * 8 * 4.
//----------------------------------------------------------------------
void MPR_Readout_RawData (UINT8 Page, UINT16 *RawData)
{
fffd18e8:	e3a02000 	mov	r2, #0
	if (status!=0) // 05/10/2015
		return;
	Sleep (10); // some delay to the DDR device to enter MPR mode

	// if ECC is enable, disable it.
	UINT32 ECC_Mode = REG_READ_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET);
fffd18ec:	e7e01c53 	ubfx	r1, r3, #24, #1
	if (ECC_Mode!=0)
fffd18f0:	e3510000 	cmp	r1, #0
		REG_SET_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET, 0); 
fffd18f4:	15943174 	ldrne	r3, [r4, #372]	; 0x174
fffd18f8:	13c33401 	bicne	r3, r3, #16777216	; 0x1000000
fffd18fc:	15843174 	strne	r3, [r4, #372]	; 0x174
	// Note: There is indirect mothod to read from MPR using MC read_mpr bit and data is placed at MC mprr_data_x registers.
	// decided to use direct read mothod (memory read). To bypass cache issue (CPU read from cache and not from DDR) use DMA to read from memory. 
	for (MPR_Page_Offset=0;MPR_Page_Offset<4; MPR_Page_Offset++)
	{

		GDMA_CTL (0,0) = 0;
fffd1900:	e59f3064 	ldr	r3, [pc, #100]	; fffd196c <MPR_Readout_RawData+0xd4>
fffd1904:	e3a00000 	mov	r0, #0
fffd1908:	e5830000 	str	r0, [r3]
		GDMA_SRCB(0,0) = (UINT32)(MPR_Page_Offset<<12);  // BA[1:0] set register index inside a page of MPR. CPU adress to DDR address:  [ ....  ;BA[1:0] ; Column[9:0]; byte/word]
fffd190c:	e1a00602 	lsl	r0, r2, #12
fffd1910:	e5830004 	str	r0, [r3, #4]
fffd1914:	e0860202 	add	r0, r6, r2, lsl #4
		GDMA_DSTB(0,0) = (UINT32)RawData; 
fffd1918:	e5830008 	str	r0, [r3, #8]
		GDMA_TCNT(0,0) = 8 /*8*UINT16*/;
fffd191c:	e3a00008 	mov	r0, #8
fffd1920:	e583000c 	str	r0, [r3, #12]
		RawData += 8;

		GDMA_CTL (0,0) = 1<<16/*software req*/ | 1<<12/*16 bits transfer*/ | 1<<0/*Enable*/ | 0<<7/*inc/dec Source*/ | 0<<6/*inc/dec Destination*/; // Software-mode, incremented
fffd1924:	e59f0044 	ldr	r0, [pc, #68]	; fffd1970 <MPR_Readout_RawData+0xd8>
fffd1928:	e5830000 	str	r0, [r3]
		while ((GDMA_CTL (0,0) & (1<<18))==0);
fffd192c:	e5930000 	ldr	r0, [r3]
fffd1930:	e3100701 	tst	r0, #262144	; 0x40000
fffd1934:	0afffffc 	beq	fffd192c <MPR_Readout_RawData+0x94>
	if (ECC_Mode!=0)
		REG_SET_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET, 0); 

	// Note: There is indirect mothod to read from MPR using MC read_mpr bit and data is placed at MC mprr_data_x registers.
	// decided to use direct read mothod (memory read). To bypass cache issue (CPU read from cache and not from DDR) use DMA to read from memory. 
	for (MPR_Page_Offset=0;MPR_Page_Offset<4; MPR_Page_Offset++)
fffd1938:	e2822001 	add	r2, r2, #1
fffd193c:	e3520004 	cmp	r2, #4
fffd1940:	1affffee 	bne	fffd1900 <MPR_Readout_RawData+0x68>
		GDMA_CTL (0,0) = 1<<16/*software req*/ | 1<<12/*16 bits transfer*/ | 1<<0/*Enable*/ | 0<<7/*inc/dec Source*/ | 0<<6/*inc/dec Destination*/; // Software-mode, incremented
		while ((GDMA_CTL (0,0) & (1<<18))==0);
	}

	// re-enable ECC if was enabled.
	REG_SET_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET, ECC_Mode);
fffd1944:	e5943174 	ldr	r3, [r4, #372]	; 0x174

	// Disable MPR
	WriteModeReg (3, MC_MR3);
fffd1948:	e3a00003 	mov	r0, #3
		GDMA_CTL (0,0) = 1<<16/*software req*/ | 1<<12/*16 bits transfer*/ | 1<<0/*Enable*/ | 0<<7/*inc/dec Source*/ | 0<<6/*inc/dec Destination*/; // Software-mode, incremented
		while ((GDMA_CTL (0,0) & (1<<18))==0);
	}

	// re-enable ECC if was enabled.
	REG_SET_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET, ECC_Mode);
fffd194c:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
fffd1950:	e1833c01 	orr	r3, r3, r1, lsl #24

	// Disable MPR
	WriteModeReg (3, MC_MR3);
fffd1954:	e1a01005 	mov	r1, r5
		GDMA_CTL (0,0) = 1<<16/*software req*/ | 1<<12/*16 bits transfer*/ | 1<<0/*Enable*/ | 0<<7/*inc/dec Source*/ | 0<<6/*inc/dec Destination*/; // Software-mode, incremented
		while ((GDMA_CTL (0,0) & (1<<18))==0);
	}

	// re-enable ECC if was enabled.
	REG_SET_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET, ECC_Mode);
fffd1958:	e5843174 	str	r3, [r4, #372]	; 0x174

	// Disable MPR
	WriteModeReg (3, MC_MR3);
}
fffd195c:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}

	// re-enable ECC if was enabled.
	REG_SET_FIELD(MC_BASE_ADDR + ((UINT32)(ECC_EN_ADDR) * 4), ECC_EN_WIDTH, ECC_EN_OFFSET, ECC_Mode);

	// Disable MPR
	WriteModeReg (3, MC_MR3);
fffd1960:	eaffffa7 	b	fffd1804 <WriteModeReg>
fffd1964:	f0824000 	.word	0xf0824000
fffd1968:	0001e7f8 	.word	0x0001e7f8
fffd196c:	f0850000 	.word	0xf0850000
fffd1970:	00011001 	.word	0x00011001

fffd1974 <MPR_Page2_Readout>:
}
//----------------------------------------------------------------------
// MPR should be array of 4.
//----------------------------------------------------------------------
int MPR_Page2_Readout (UINT8 *MPR)
{
fffd1974:	e92d4030 	push	{r4, r5, lr}
fffd1978:	e24dd044 	sub	sp, sp, #68	; 0x44
fffd197c:	e1a05000 	mov	r5, r0
	UINT16 MPR2_Readout [8*4];
	UINT16 *pMPR2_Readout = MPR2_Readout;
	
	MPR_Readout_RawData (2,MPR2_Readout); // read page-2 raw data (at serial mode)
fffd1980:	e1a0100d 	mov	r1, sp
fffd1984:	e3a00002 	mov	r0, #2
fffd1988:	e1a0400d 	mov	r4, sp
fffd198c:	ebffffc1 	bl	fffd1898 <MPR_Readout_RawData>
fffd1990:	e285e004 	add	lr, r5, #4
fffd1994:	e1a02004 	mov	r2, r4
fffd1998:	e284c010 	add	r12, r4, #16
}
//----------------------------------------------------------------------
// MPR should be array of 4.
//----------------------------------------------------------------------
int MPR_Page2_Readout (UINT8 *MPR)
{
fffd199c:	e3a01080 	mov	r1, #128	; 0x80
fffd19a0:	e3a03000 	mov	r3, #0
	{
		UINT8 tmp_data = 0;
		UINT32 bit_index=0x80; 
		while (bit_index!=0)
		{
			if (*pMPR2_Readout == 0xFFFF)
fffd19a4:	e0d200b2 	ldrh	r0, [r2], #2
fffd19a8:	e30f4fff 	movw	r4, #65535	; 0xffff
fffd19ac:	e1500004 	cmp	r0, r4
				tmp_data |= bit_index;
fffd19b0:	01833001 	orreq	r3, r3, r1
fffd19b4:	06ef3073 	uxtbeq	r3, r3
	{
		UINT8 tmp_data = 0;
		UINT32 bit_index=0x80; 
		while (bit_index!=0)
		{
			if (*pMPR2_Readout == 0xFFFF)
fffd19b8:	0a000001 	beq	fffd19c4 <MPR_Page2_Readout+0x50>
				tmp_data |= bit_index;
			else if (*pMPR2_Readout != 0x0000)
fffd19bc:	e3500000 	cmp	r0, #0
fffd19c0:	1a000008 	bne	fffd19e8 <MPR_Page2_Readout+0x74>

	for (MPR_Page_Offset=0; MPR_Page_Offset<4; MPR_Page_Offset++)
	{
		UINT8 tmp_data = 0;
		UINT32 bit_index=0x80; 
		while (bit_index!=0)
fffd19c4:	e152000c 	cmp	r2, r12
			if (*pMPR2_Readout == 0xFFFF)
				tmp_data |= bit_index;
			else if (*pMPR2_Readout != 0x0000)
				return (-1); // in serial mode all data bus must be the same value. If not, there may be a signal integrity issue.

			bit_index = bit_index >> 1;
fffd19c8:	e1a010a1 	lsr	r1, r1, #1
			pMPR2_Readout++;
fffd19cc:	e1a04002 	mov	r4, r2

	for (MPR_Page_Offset=0; MPR_Page_Offset<4; MPR_Page_Offset++)
	{
		UINT8 tmp_data = 0;
		UINT32 bit_index=0x80; 
		while (bit_index!=0)
fffd19d0:	1afffff3 	bne	fffd19a4 <MPR_Page2_Readout+0x30>
				return (-1); // in serial mode all data bus must be the same value. If not, there may be a signal integrity issue.

			bit_index = bit_index >> 1;
			pMPR2_Readout++;
		}
		*MPR = tmp_data;
fffd19d4:	e4c53001 	strb	r3, [r5], #1
	UINT16 *pMPR2_Readout = MPR2_Readout;
	
	MPR_Readout_RawData (2,MPR2_Readout); // read page-2 raw data (at serial mode)
	UINT32 MPR_Page_Offset; 

	for (MPR_Page_Offset=0; MPR_Page_Offset<4; MPR_Page_Offset++)
fffd19d8:	e155000e 	cmp	r5, lr
fffd19dc:	1affffec 	bne	fffd1994 <MPR_Page2_Readout+0x20>
			pMPR2_Readout++;
		}
		*MPR = tmp_data;
		MPR++;
	}
	return (0);
fffd19e0:	e3a00000 	mov	r0, #0
fffd19e4:	ea000000 	b	fffd19ec <MPR_Page2_Readout+0x78>
		while (bit_index!=0)
		{
			if (*pMPR2_Readout == 0xFFFF)
				tmp_data |= bit_index;
			else if (*pMPR2_Readout != 0x0000)
				return (-1); // in serial mode all data bus must be the same value. If not, there may be a signal integrity issue.
fffd19e8:	e3e00000 	mvn	r0, #0
		}
		*MPR = tmp_data;
		MPR++;
	}
	return (0);
}
fffd19ec:	e28dd044 	add	sp, sp, #68	; 0x44
fffd19f0:	e8bd8030 	pop	{r4, r5, pc}

fffd19f4 <VrefDQ_Get_DRAM>:
//----------------------------------------------------------------------
void VrefDQ_Get_DRAM (UINT8 *Range, UINT8 *Step)
{
fffd19f4:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
fffd19f8:	e1a04000 	mov	r4, r0
	// Get value from DDR
	UINT8 MPR2[4];
	if (MPR_Page2_Readout (MPR2)==(-1))
fffd19fc:	e28d0004 	add	r0, sp, #4
	}
	return (0);
}
//----------------------------------------------------------------------
void VrefDQ_Get_DRAM (UINT8 *Range, UINT8 *Step)
{
fffd1a00:	e1a05001 	mov	r5, r1
	// Get value from DDR
	UINT8 MPR2[4];
	if (MPR_Page2_Readout (MPR2)==(-1))
fffd1a04:	ebffffda 	bl	fffd1974 <MPR_Page2_Readout>
fffd1a08:	e3700001 	cmn	r0, #1
		MPR2[1] = 0;
fffd1a0c:	03a03000 	moveq	r3, #0
fffd1a10:	05cd3005 	strbeq	r3, [sp, #5]
	*Step = (MPR2[1]>>1) & 0x3F;
fffd1a14:	e5dd3005 	ldrb	r3, [sp, #5]
fffd1a18:	e7e520d3 	ubfx	r2, r3, #1, #6
	*Range = MPR2[1]>>7;
fffd1a1c:	e1a033a3 	lsr	r3, r3, #7
{
	// Get value from DDR
	UINT8 MPR2[4];
	if (MPR_Page2_Readout (MPR2)==(-1))
		MPR2[1] = 0;
	*Step = (MPR2[1]>>1) & 0x3F;
fffd1a20:	e5c52000 	strb	r2, [r5]
	*Range = MPR2[1]>>7;
fffd1a24:	e5c43000 	strb	r3, [r4]
}
fffd1a28:	e28dd00c 	add	sp, sp, #12
fffd1a2c:	e8bd8030 	pop	{r4, r5, pc}

fffd1a30 <VrefDQ_Convert_Step_to_mV>:
		TimeOut--;
	}
}
//-------------------------------------------------------------------------------
UINT16 VrefDQ_Convert_Step_to_mV (UINT8 Range, UINT8 Step)
{
fffd1a30:	e1a03301 	lsl	r3, r1, #6
	UINT16 VrefDQ_Percent;
	UINT16 VrefDQ_mV;

	if (Range==0) // range 1
fffd1a34:	e3500000 	cmp	r0, #0
		VrefDQ_Percent = (UINT16)6000 + ((UINT16)Step * (UINT16)65);
	else // range 2
		VrefDQ_Percent = (UINT16)4500 + ((UINT16)Step * (UINT16)65);

	VrefDQ_mV = (UINT16)( (((UINT32)1200 * (UINT32)VrefDQ_Percent) + 5000) / (UINT32)10000); 
fffd1a38:	e3a02e4b 	mov	r2, #1200	; 0x4b0
{
	UINT16 VrefDQ_Percent;
	UINT16 VrefDQ_mV;

	if (Range==0) // range 1
		VrefDQ_Percent = (UINT16)6000 + ((UINT16)Step * (UINT16)65);
fffd1a3c:	e0811003 	add	r1, r1, r3
fffd1a40:	02811d5d 	addeq	r1, r1, #5952	; 0x1740
	else // range 2
		VrefDQ_Percent = (UINT16)4500 + ((UINT16)Step * (UINT16)65);
fffd1a44:	12811d46 	addne	r1, r1, #4480	; 0x1180
{
	UINT16 VrefDQ_Percent;
	UINT16 VrefDQ_mV;

	if (Range==0) // range 1
		VrefDQ_Percent = (UINT16)6000 + ((UINT16)Step * (UINT16)65);
fffd1a48:	02811030 	addeq	r1, r1, #48	; 0x30
	else // range 2
		VrefDQ_Percent = (UINT16)4500 + ((UINT16)Step * (UINT16)65);
fffd1a4c:	12811014 	addne	r1, r1, #20

	VrefDQ_mV = (UINT16)( (((UINT32)1200 * (UINT32)VrefDQ_Percent) + 5000) / (UINT32)10000); 
fffd1a50:	e0010192 	mul	r1, r2, r1
fffd1a54:	e59f2010 	ldr	r2, [pc, #16]	; fffd1a6c <VrefDQ_Convert_Step_to_mV+0x3c>
fffd1a58:	e2811d4e 	add	r1, r1, #4992	; 0x1380
fffd1a5c:	e2811008 	add	r1, r1, #8
fffd1a60:	e0832291 	umull	r2, r3, r1, r2
	return (VrefDQ_mV);
}
fffd1a64:	e7ef06d3 	ubfx	r0, r3, #13, #16
fffd1a68:	e12fff1e 	bx	lr
fffd1a6c:	d1b71759 	.word	0xd1b71759

fffd1a70 <DisplayInfo>:
	UINT32 ilane,ibit;
	UINT8 val;
	int status;
	UINT8 NumOfLanes;
	
	LogMessage("\n");
fffd1a70:	e59f0bc8 	ldr	r0, [pc, #3016]	; fffd2640 <DisplayInfo+0xbd0>
}
//--------------------------------------------------
const UINT8 CL[16] = {9,10,11,12,13,14,15,16,18,20,22,24,0,0,0,0};
const UINT8 CWL[8] = {9,10,11,12,14,16,18,0};
BOOL DisplayInfo (void)
{
fffd1a74:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
fffd1a78:	e24dd05c 	sub	sp, sp, #92	; 0x5c
	//----------------------------------------------------------
	LogMessage ("> Clock frequency: \n");
	Check_BMC_PLL (READ_REG (PLLCON1), 1);

	//----------------------------------------------------------
	LogMessage ("> PHY Revision: 0x%08lX \n",READ_REG (PHY_REV_CNTRL_REG));
fffd1a7c:	e59f4bc0 	ldr	r4, [pc, #3008]	; fffd2644 <DisplayInfo+0xbd4>
	UINT32 ilane,ibit;
	UINT8 val;
	int status;
	UINT8 NumOfLanes;
	
	LogMessage("\n");
fffd1a80:	e08f0000 	add	r0, pc, r0
fffd1a84:	eb000b1c 	bl	fffd46fc <LogMessage>
	LogHeader (" DDR4 PHY Information ");
fffd1a88:	e59f0bb8 	ldr	r0, [pc, #3000]	; fffd2648 <DisplayInfo+0xbd8>

	//----------------------------------------------------------
	LogMessage ("> PHY Revision: 0x%08lX \n",READ_REG (PHY_REV_CNTRL_REG));

	//----------------------------------------------------------
	TmpReg32 = IOR32(MC_BASE_ADDR + (93*4)); // DENALI_CTL_93_DATA
fffd1a8c:	e59f5bb8 	ldr	r5, [pc, #3000]	; fffd264c <DisplayInfo+0xbdc>
}
//--------------------------------------------------
const UINT8 CL[16] = {9,10,11,12,13,14,15,16,18,20,22,24,0,0,0,0};
const UINT8 CWL[8] = {9,10,11,12,14,16,18,0};
BOOL DisplayInfo (void)
{
fffd1a90:	e59f6bb8 	ldr	r6, [pc, #3000]	; fffd2650 <DisplayInfo+0xbe0>
	UINT8 val;
	int status;
	UINT8 NumOfLanes;
	
	LogMessage("\n");
	LogHeader (" DDR4 PHY Information ");
fffd1a94:	e08f0000 	add	r0, pc, r0
fffd1a98:	eb000b73 	bl	fffd486c <LogHeader>

	//----------------------------------------------------------
	LogMessage ("> Clock frequency: \n");
fffd1a9c:	e59f0bb0 	ldr	r0, [pc, #2992]	; fffd2654 <DisplayInfo+0xbe4>
}
//--------------------------------------------------
const UINT8 CL[16] = {9,10,11,12,13,14,15,16,18,20,22,24,0,0,0,0};
const UINT8 CWL[8] = {9,10,11,12,14,16,18,0};
BOOL DisplayInfo (void)
{
fffd1aa0:	e08f6006 	add	r6, pc, r6
	
	LogMessage("\n");
	LogHeader (" DDR4 PHY Information ");

	//----------------------------------------------------------
	LogMessage ("> Clock frequency: \n");
fffd1aa4:	e08f0000 	add	r0, pc, r0
fffd1aa8:	eb000b13 	bl	fffd46fc <LogMessage>
	Check_BMC_PLL (READ_REG (PLLCON1), 1);
fffd1aac:	e59f3ba4 	ldr	r3, [pc, #2980]	; fffd2658 <DisplayInfo+0xbe8>
fffd1ab0:	e3a01001 	mov	r1, #1
fffd1ab4:	e5930010 	ldr	r0, [r3, #16]
fffd1ab8:	ebfffa5a 	bl	fffd0428 <Check_BMC_PLL>

	//----------------------------------------------------------
	LogMessage ("> PHY Revision: 0x%08lX \n",READ_REG (PHY_REV_CNTRL_REG));
fffd1abc:	e59f0b98 	ldr	r0, [pc, #2968]	; fffd265c <DisplayInfo+0xbec>
fffd1ac0:	e59411b0 	ldr	r1, [r4, #432]	; 0x1b0
fffd1ac4:	e08f0000 	add	r0, pc, r0
fffd1ac8:	eb000b0b 	bl	fffd46fc <LogMessage>

	//----------------------------------------------------------
	TmpReg32 = IOR32(MC_BASE_ADDR + (93*4)); // DENALI_CTL_93_DATA
fffd1acc:	e5953174 	ldr	r3, [r5, #372]	; 0x174
	if (((TmpReg32>>24)&0x01)==0)
fffd1ad0:	e3130401 	tst	r3, #16777216	; 0x1000000
fffd1ad4:	1a000004 	bne	fffd1aec <DisplayInfo+0x7c>
	{
		LogWarning ("> ECC is OFF. \n");
fffd1ad8:	e59f0b80 	ldr	r0, [pc, #2944]	; fffd2660 <DisplayInfo+0xbf0>
		NumOfLanes = 2;
fffd1adc:	e3a07002 	mov	r7, #2

	//----------------------------------------------------------
	TmpReg32 = IOR32(MC_BASE_ADDR + (93*4)); // DENALI_CTL_93_DATA
	if (((TmpReg32>>24)&0x01)==0)
	{
		LogWarning ("> ECC is OFF. \n");
fffd1ae0:	e08f0000 	add	r0, pc, r0
fffd1ae4:	eb000b40 	bl	fffd47ec <LogWarning>
fffd1ae8:	ea000016 	b	fffd1b48 <DisplayInfo+0xd8>
		NumOfLanes = 2;
	}
	else
	{
		LogPass ("> ECC is ON. \n");
fffd1aec:	e59f0b70 	ldr	r0, [pc, #2928]	; fffd2664 <DisplayInfo+0xbf4>
fffd1af0:	e08f0000 	add	r0, pc, r0
fffd1af4:	eb000b4c 	bl	fffd482c <LogPass>
		NumOfLanes = 3;

		UINT32 int_status = IOR32(MC_BASE_ADDR + (116*4)); // DENALI_CTL_116_DATA  read all status
fffd1af8:	e59571d0 	ldr	r7, [r5, #464]	; 0x1d0

		if (((int_status>>5)&0x3)!=0)
fffd1afc:	e3170060 	tst	r7, #96	; 0x60
fffd1b00:	0a000006 	beq	fffd1b20 <DisplayInfo+0xb0>
		{
			UINT32 ECC_U_ADDR = IOR32(MC_BASE_ADDR + (95*4)); // DENALI_CTL_95_DATA  Address of uncorrectable ECC event.
			UINT32 ECC_U_DATA = IOR32(MC_BASE_ADDR + (97*4)); // DENALI_CTL_97_DATA  Data of uncorrectable ECC event.
			LogError("  >> Uncorrectable ECC errors: Addr:0x%08lX, Data:0x%08lX.\n",ECC_U_ADDR,ECC_U_DATA);
fffd1b04:	e59f0b5c 	ldr	r0, [pc, #2908]	; fffd2668 <DisplayInfo+0xbf8>

		UINT32 int_status = IOR32(MC_BASE_ADDR + (116*4)); // DENALI_CTL_116_DATA  read all status

		if (((int_status>>5)&0x3)!=0)
		{
			UINT32 ECC_U_ADDR = IOR32(MC_BASE_ADDR + (95*4)); // DENALI_CTL_95_DATA  Address of uncorrectable ECC event.
fffd1b08:	e595117c 	ldr	r1, [r5, #380]	; 0x17c
			UINT32 ECC_U_DATA = IOR32(MC_BASE_ADDR + (97*4)); // DENALI_CTL_97_DATA  Data of uncorrectable ECC event.
fffd1b0c:	e5952184 	ldr	r2, [r5, #388]	; 0x184
			LogError("  >> Uncorrectable ECC errors: Addr:0x%08lX, Data:0x%08lX.\n",ECC_U_ADDR,ECC_U_DATA);
fffd1b10:	e08f0000 	add	r0, pc, r0
fffd1b14:	eb000b24 	bl	fffd47ac <LogError>
			IOW32(MC_BASE_ADDR + (117*4),0x3<<5); // DENALI_CTL_117_DATA  clear status
fffd1b18:	e3a03060 	mov	r3, #96	; 0x60
fffd1b1c:	e58531d4 	str	r3, [r5, #468]	; 0x1d4
		}

		if (((int_status>>3)&0x3)!=0)
fffd1b20:	e3170018 	tst	r7, #24
fffd1b24:	0a000006 	beq	fffd1b44 <DisplayInfo+0xd4>
		{
			UINT32 ECC_C_ADDR = IOR32(MC_BASE_ADDR + (98*4)); // DENALI_CTL_98_DATA  Address of correctable ECC event.
			UINT32 ECC_C_DATA = IOR32(MC_BASE_ADDR + (100*4)); // DENALI_CTL_100_DATA  Data of correctable ECC event.
			LogError("  >> Correctable ECC errors:   Addr:0x%08lX, Data:0x%08lX.\n",ECC_C_ADDR,ECC_C_DATA);
fffd1b28:	e59f0b3c 	ldr	r0, [pc, #2876]	; fffd266c <DisplayInfo+0xbfc>
			IOW32(MC_BASE_ADDR + (117*4),0x3<<5); // DENALI_CTL_117_DATA  clear status
		}

		if (((int_status>>3)&0x3)!=0)
		{
			UINT32 ECC_C_ADDR = IOR32(MC_BASE_ADDR + (98*4)); // DENALI_CTL_98_DATA  Address of correctable ECC event.
fffd1b2c:	e5951188 	ldr	r1, [r5, #392]	; 0x188
			UINT32 ECC_C_DATA = IOR32(MC_BASE_ADDR + (100*4)); // DENALI_CTL_100_DATA  Data of correctable ECC event.
fffd1b30:	e5952190 	ldr	r2, [r5, #400]	; 0x190
			LogError("  >> Correctable ECC errors:   Addr:0x%08lX, Data:0x%08lX.\n",ECC_C_ADDR,ECC_C_DATA);
fffd1b34:	e08f0000 	add	r0, pc, r0
fffd1b38:	eb000b1b 	bl	fffd47ac <LogError>
			IOW32(MC_BASE_ADDR + (117*4),0x3<<3); // DENALI_CTL_117_DATA  clear status
fffd1b3c:	e3a03018 	mov	r3, #24
fffd1b40:	e58531d4 	str	r3, [r5, #468]	; 0x1d4
		NumOfLanes = 2;
	}
	else
	{
		LogPass ("> ECC is ON. \n");
		NumOfLanes = 3;
fffd1b44:	e3a07003 	mov	r7, #3
			IOW32(MC_BASE_ADDR + (117*4),0x3<<3); // DENALI_CTL_117_DATA  clear status
		}
	}

	//---------------------------------------------------------------
	TmpReg32 = READ_REG(SCL_START) /*cuml_scl_rslt*/ & READ_REG (WRLVL_CTRL) /*write-leveling status*/ & (~(READ_REG(DYNAMIC_WRITE_BIT_LVL)>>20)) /*bit_lvl_wr_failure_status*/ & (READ_REG(IP_DQ_DQS_BITWISE_TRIM)>>8) /*bit_lvl_done_status*/ & (~(READ_REG(DYNAMIC_BIT_LVL)>>14)) /*bit_lvl_failure_status*/ ;
fffd1b48:	e5942100 	ldr	r2, [r4, #256]	; 0x100
	LogMessage ("> Self-Configuring Logic (SCL), Write-Leveling and Read/Write Bit-Leveling status: \n");
	for (ilane=0;ilane<NumOfLanes;ilane++)
fffd1b4c:	e3a08000 	mov	r8, #0
			IOW32(MC_BASE_ADDR + (117*4),0x3<<3); // DENALI_CTL_117_DATA  clear status
		}
	}

	//---------------------------------------------------------------
	TmpReg32 = READ_REG(SCL_START) /*cuml_scl_rslt*/ & READ_REG (WRLVL_CTRL) /*write-leveling status*/ & (~(READ_REG(DYNAMIC_WRITE_BIT_LVL)>>20)) /*bit_lvl_wr_failure_status*/ & (READ_REG(IP_DQ_DQS_BITWISE_TRIM)>>8) /*bit_lvl_done_status*/ & (~(READ_REG(DYNAMIC_BIT_LVL)>>14)) /*bit_lvl_failure_status*/ ;
fffd1b50:	e5940148 	ldr	r0, [r4, #328]	; 0x148
fffd1b54:	e59451c0 	ldr	r5, [r4, #448]	; 0x1c0
fffd1b58:	e5943194 	ldr	r3, [r4, #404]	; 0x194
fffd1b5c:	e0022000 	and	r2, r2, r0
fffd1b60:	e59411ac 	ldr	r1, [r4, #428]	; 0x1ac
	LogMessage ("> Self-Configuring Logic (SCL), Write-Leveling and Read/Write Bit-Leveling status: \n");
fffd1b64:	e59f0b04 	ldr	r0, [pc, #2820]	; fffd2670 <DisplayInfo+0xc00>
fffd1b68:	e0023423 	and	r3, r2, r3, lsr #8
fffd1b6c:	e08f0000 	add	r0, pc, r0
			IOW32(MC_BASE_ADDR + (117*4),0x3<<3); // DENALI_CTL_117_DATA  clear status
		}
	}

	//---------------------------------------------------------------
	TmpReg32 = READ_REG(SCL_START) /*cuml_scl_rslt*/ & READ_REG (WRLVL_CTRL) /*write-leveling status*/ & (~(READ_REG(DYNAMIC_WRITE_BIT_LVL)>>20)) /*bit_lvl_wr_failure_status*/ & (READ_REG(IP_DQ_DQS_BITWISE_TRIM)>>8) /*bit_lvl_done_status*/ & (~(READ_REG(DYNAMIC_BIT_LVL)>>14)) /*bit_lvl_failure_status*/ ;
fffd1b70:	e1c33a25 	bic	r3, r3, r5, lsr #20
fffd1b74:	e1c35721 	bic	r5, r3, r1, lsr #14
	LogMessage ("> Self-Configuring Logic (SCL), Write-Leveling and Read/Write Bit-Leveling status: \n");
fffd1b78:	eb000adf 	bl	fffd46fc <LogMessage>
	for (ilane=0;ilane<NumOfLanes;ilane++)
fffd1b7c:	e1580007 	cmp	r8, r7
fffd1b80:	2a00000d 	bcs	fffd1bbc <DisplayInfo+0x14c>
	{
		if ((TmpReg32&(1<<ilane))==0)
fffd1b84:	e3a03001 	mov	r3, #1
fffd1b88:	e0153813 	ands	r3, r5, r3, lsl r8
fffd1b8c:	1a000004 	bne	fffd1ba4 <DisplayInfo+0x134>
			LogError ("  >> lane%u: Failed.\n",ilane);
fffd1b90:	e59f0adc 	ldr	r0, [pc, #2780]	; fffd2674 <DisplayInfo+0xc04>
fffd1b94:	e1a01008 	mov	r1, r8
fffd1b98:	e08f0000 	add	r0, pc, r0
fffd1b9c:	eb000b02 	bl	fffd47ac <LogError>
fffd1ba0:	ea000003 	b	fffd1bb4 <DisplayInfo+0x144>
		else
			LogPass  ("  >> lane%u: Passed.\n",ilane);
fffd1ba4:	e59f0acc 	ldr	r0, [pc, #2764]	; fffd2678 <DisplayInfo+0xc08>
fffd1ba8:	e1a01008 	mov	r1, r8
fffd1bac:	e08f0000 	add	r0, pc, r0
fffd1bb0:	eb000b1d 	bl	fffd482c <LogPass>
	}

	//---------------------------------------------------------------
	TmpReg32 = READ_REG(SCL_START) /*cuml_scl_rslt*/ & READ_REG (WRLVL_CTRL) /*write-leveling status*/ & (~(READ_REG(DYNAMIC_WRITE_BIT_LVL)>>20)) /*bit_lvl_wr_failure_status*/ & (READ_REG(IP_DQ_DQS_BITWISE_TRIM)>>8) /*bit_lvl_done_status*/ & (~(READ_REG(DYNAMIC_BIT_LVL)>>14)) /*bit_lvl_failure_status*/ ;
	LogMessage ("> Self-Configuring Logic (SCL), Write-Leveling and Read/Write Bit-Leveling status: \n");
	for (ilane=0;ilane<NumOfLanes;ilane++)
fffd1bb4:	e2888001 	add	r8, r8, #1
fffd1bb8:	eaffffef 	b	fffd1b7c <DisplayInfo+0x10c>
			LogError ("  >> lane%u: Failed.\n",ilane);
		else
			LogPass  ("  >> lane%u: Passed.\n",ilane);
	}
	//---------------------------------------------------------------
	TmpReg32 = READ_REG(DSCL_CNT);
fffd1bbc:	e594519c 	ldr	r5, [r4, #412]	; 0x19c
	LogMessage ("> DSCL_CNT (0x67) = 0x%08lX \n", TmpReg32);
fffd1bc0:	e59f0ab4 	ldr	r0, [pc, #2740]	; fffd267c <DisplayInfo+0xc0c>
fffd1bc4:	e1a01005 	mov	r1, r5
fffd1bc8:	e08f0000 	add	r0, pc, r0
fffd1bcc:	eb000aca 	bl	fffd46fc <LogMessage>
	if (((TmpReg32>>24)&0x01)==0x00)
fffd1bd0:	e3150401 	tst	r5, #16777216	; 0x1000000
fffd1bd4:	1a000003 	bne	fffd1be8 <DisplayInfo+0x178>
		LogWarning("  >> Dynamic SCL is OFF !\n");
fffd1bd8:	e59f0aa0 	ldr	r0, [pc, #2720]	; fffd2680 <DisplayInfo+0xc10>
fffd1bdc:	e08f0000 	add	r0, pc, r0
fffd1be0:	eb000b01 	bl	fffd47ec <LogWarning>
fffd1be4:	ea000027 	b	fffd1c88 <DisplayInfo+0x218>
	else
	{
		LogPass ("  >> Dynamic SCL is ON. \n");
fffd1be8:	e59f0a94 	ldr	r0, [pc, #2708]	; fffd2684 <DisplayInfo+0xc14>
fffd1bec:	e08f0000 	add	r0, pc, r0
fffd1bf0:	eb000b0d 	bl	fffd482c <LogPass>
		LogMessage ("  >> dscl_exp_cnt = %lu x 256 PHY clock cycles. \n",TmpReg32&0x00FFFFFF);
fffd1bf4:	e59f0a8c 	ldr	r0, [pc, #2700]	; fffd2688 <DisplayInfo+0xc18>
fffd1bf8:	e3c514ff 	bic	r1, r5, #-16777216	; 0xff000000
fffd1bfc:	e08f0000 	add	r0, pc, r0
fffd1c00:	eb000abd 	bl	fffd46fc <LogMessage>
		if (((TmpReg32>>25)&0x01)==1)
fffd1c04:	e3150402 	tst	r5, #33554432	; 0x2000000
fffd1c08:	0a000003 	beq	fffd1c1c <DisplayInfo+0x1ac>
			LogMessage ("  >> dscl_save_restore_needed = 1. \n");
fffd1c0c:	e59f0a78 	ldr	r0, [pc, #2680]	; fffd268c <DisplayInfo+0xc1c>
fffd1c10:	e08f0000 	add	r0, pc, r0
fffd1c14:	eb000ab8 	bl	fffd46fc <LogMessage>
fffd1c18:	ea00000a 	b	fffd1c48 <DisplayInfo+0x1d8>
		else
		{
			UINT32 Reg32 = READ_REG(PHY_SCL_START_ADDR);
fffd1c1c:	e59f3a20 	ldr	r3, [pc, #2592]	; fffd2644 <DisplayInfo+0xbd4>
			UINT32 Addr = ((Reg32&0x3FF0000) >> 16)*4 +  (Reg32&0x7FFF)*0x4000 +   ((Reg32&0x60000000) >> 29)*0x1000 ;
			LogWarning ("  >> dscl_save_restore_needed = 0. (PHY_SCL_START_ADDR = 0x%08lX; Actual Addr = 0x%08lX). \n",Reg32,Addr);
fffd1c20:	e59f0a68 	ldr	r0, [pc, #2664]	; fffd2690 <DisplayInfo+0xc20>
		LogMessage ("  >> dscl_exp_cnt = %lu x 256 PHY clock cycles. \n",TmpReg32&0x00FFFFFF);
		if (((TmpReg32>>25)&0x01)==1)
			LogMessage ("  >> dscl_save_restore_needed = 1. \n");
		else
		{
			UINT32 Reg32 = READ_REG(PHY_SCL_START_ADDR);
fffd1c24:	e5931188 	ldr	r1, [r3, #392]	; 0x188
			UINT32 Addr = ((Reg32&0x3FF0000) >> 16)*4 +  (Reg32&0x7FFF)*0x4000 +   ((Reg32&0x60000000) >> 29)*0x1000 ;
			LogWarning ("  >> dscl_save_restore_needed = 0. (PHY_SCL_START_ADDR = 0x%08lX; Actual Addr = 0x%08lX). \n",Reg32,Addr);
fffd1c28:	e08f0000 	add	r0, pc, r0
		if (((TmpReg32>>25)&0x01)==1)
			LogMessage ("  >> dscl_save_restore_needed = 1. \n");
		else
		{
			UINT32 Reg32 = READ_REG(PHY_SCL_START_ADDR);
			UINT32 Addr = ((Reg32&0x3FF0000) >> 16)*4 +  (Reg32&0x7FFF)*0x4000 +   ((Reg32&0x60000000) >> 29)*0x1000 ;
fffd1c2c:	e7e13ed1 	ubfx	r3, r1, #29, #2
fffd1c30:	e7ee2051 	ubfx	r2, r1, #0, #15
fffd1c34:	e0832102 	add	r2, r3, r2, lsl #2
fffd1c38:	e7e93851 	ubfx	r3, r1, #16, #10
fffd1c3c:	e0832502 	add	r2, r3, r2, lsl #10
			LogWarning ("  >> dscl_save_restore_needed = 0. (PHY_SCL_START_ADDR = 0x%08lX; Actual Addr = 0x%08lX). \n",Reg32,Addr);
fffd1c40:	e1a02102 	lsl	r2, r2, #2
fffd1c44:	eb000ae8 	bl	fffd47ec <LogWarning>
		}

		if ( (READ_REG(DYNAMIC_BIT_LVL)&0x01) == 0 ) 
fffd1c48:	e59431ac 	ldr	r3, [r4, #428]	; 0x1ac
fffd1c4c:	e3130001 	tst	r3, #1
			LogMessage ("  >> Dynamic SCL without Bit-Levelling. \n");
fffd1c50:	059f0a3c 	ldreq	r0, [pc, #2620]	; fffd2694 <DisplayInfo+0xc24>
fffd1c54:	008f0000 	addeq	r0, pc, r0
fffd1c58:	0a000009 	beq	fffd1c84 <DisplayInfo+0x214>
		else 
		{
			LogMessage ("  >> Dynamic SCL with Bit-Levelling. \n");
fffd1c5c:	e59f0a34 	ldr	r0, [pc, #2612]	; fffd2698 <DisplayInfo+0xc28>
fffd1c60:	e08f0000 	add	r0, pc, r0
fffd1c64:	eb000aa4 	bl	fffd46fc <LogMessage>
			if ( (READ_REG(DYNAMIC_WRITE_BIT_LVL)&0x01) == 0 ) 
fffd1c68:	e59f39d4 	ldr	r3, [pc, #2516]	; fffd2644 <DisplayInfo+0xbd4>
fffd1c6c:	e59331c0 	ldr	r3, [r3, #448]	; 0x1c0
fffd1c70:	e3130001 	tst	r3, #1
				LogMessage ("  >> Dynamic SCL without Write Bit-Levelling. \n");
fffd1c74:	059f0a20 	ldreq	r0, [pc, #2592]	; fffd269c <DisplayInfo+0xc2c>
fffd1c78:	008f0000 	addeq	r0, pc, r0
			else 
				LogMessage ("  >> Dynamic SCL with Write Bit-Levelling. \n");
fffd1c7c:	159f0a1c 	ldrne	r0, [pc, #2588]	; fffd26a0 <DisplayInfo+0xc30>
fffd1c80:	108f0000 	addne	r0, pc, r0
fffd1c84:	eb000a9c 	bl	fffd46fc <LogMessage>
		}
	}

	//--------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd1c88:	e3a03000 	mov	r3, #0
	TmpReg32 = READ_REG(PHY_DLL_ADRCTRL);
	LogMessage ("> PHY_DLL_ADRCTRL (0x4A) = 0x%08lX \n", TmpReg32);
fffd1c8c:	e59f0a10 	ldr	r0, [pc, #2576]	; fffd26a4 <DisplayInfo+0xc34>
				LogMessage ("  >> Dynamic SCL with Write Bit-Levelling. \n");
		}
	}

	//--------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd1c90:	e584312c 	str	r3, [r4, #300]	; 0x12c
	TmpReg32 = READ_REG(PHY_DLL_ADRCTRL);
fffd1c94:	e5945128 	ldr	r5, [r4, #296]	; 0x128
	LogMessage ("> PHY_DLL_ADRCTRL (0x4A) = 0x%08lX \n", TmpReg32);
fffd1c98:	e08f0000 	add	r0, pc, r0
fffd1c9c:	e1a01005 	mov	r1, r5
fffd1ca0:	eb000a95 	bl	fffd46fc <LogMessage>
	LogMessageColor(COLOR_YELLOW, "  >> Number of delay elements corresponds to one clock cycle (dll_mas_dly): %lu. \n", TmpReg32>>24);
fffd1ca4:	e59f19fc 	ldr	r1, [pc, #2556]	; fffd26a8 <DisplayInfo+0xc38>
fffd1ca8:	e3a00003 	mov	r0, #3
fffd1cac:	e1a02c25 	lsr	r2, r5, #24
fffd1cb0:	e08f1001 	add	r1, pc, r1
fffd1cb4:	eb000aad 	bl	fffd4770 <LogMessageColor>
	LogMessageColor(COLOR_YELLOW, "  >> Number of delay elements corresponds to 1/4 clock cycle (dll_slv_dly_wire): %lu.\n", (TmpReg32>>16)&0x3F);
fffd1cb8:	e59f19ec 	ldr	r1, [pc, #2540]	; fffd26ac <DisplayInfo+0xc3c>
fffd1cbc:	e3a00003 	mov	r0, #3
fffd1cc0:	e7e52855 	ubfx	r2, r5, #16, #6
fffd1cc4:	e08f1001 	add	r1, pc, r1
fffd1cc8:	eb000aa8 	bl	fffd4770 <LogMessageColor>
	if ((TmpReg32&0x100)==0) 
fffd1ccc:	e3150c01 	tst	r5, #256	; 0x100
fffd1cd0:	1a00000c 	bne	fffd1d08 <DisplayInfo+0x298>
	{
		LogMessage ("  >> Delay of control signals with respect to output data signals (dlls_trim_adrctl): ");
fffd1cd4:	e59f09d4 	ldr	r0, [pc, #2516]	; fffd26b0 <DisplayInfo+0xc40>
fffd1cd8:	e08f0000 	add	r0, pc, r0
fffd1cdc:	eb000a86 	bl	fffd46fc <LogMessage>
		if ((TmpReg32&0x200)!=0) 
fffd1ce0:	e3150c02 	tst	r5, #512	; 0x200
			LogMessage ("+"); // set to increment; limited by 1/4 clock (i.e., from dlls_trim_clk)
fffd1ce4:	159f09c8 	ldrne	r0, [pc, #2504]	; fffd26b4 <DisplayInfo+0xc44>
fffd1ce8:	108f0000 	addne	r0, pc, r0
		else
			LogMessage ("-"); // decrement; limited by 1/4 clock
fffd1cec:	059f09c4 	ldreq	r0, [pc, #2500]	; fffd26b8 <DisplayInfo+0xc48>
fffd1cf0:	008f0000 	addeq	r0, pc, r0
fffd1cf4:	eb000a80 	bl	fffd46fc <LogMessage>
		LogMessage ("%lu.\n", (TmpReg32>>0)&0x3F); 
fffd1cf8:	e59f09bc 	ldr	r0, [pc, #2492]	; fffd26bc <DisplayInfo+0xc4c>
fffd1cfc:	e205103f 	and	r1, r5, #63	; 0x3f
fffd1d00:	e08f0000 	add	r0, pc, r0
fffd1d04:	eb000a7c 	bl	fffd46fc <LogMessage>
	}
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd1d08:	e3a03000 	mov	r3, #0
	TmpReg32 = READ_REG(PHY_DLL_RECALIB);
	LogMessage ("> PHY_DLL_RECALIB (0x49) = 0x%08lX \n", TmpReg32);
fffd1d0c:	e59f09ac 	ldr	r0, [pc, #2476]	; fffd26c0 <DisplayInfo+0xc50>
		else
			LogMessage ("-"); // decrement; limited by 1/4 clock
		LogMessage ("%lu.\n", (TmpReg32>>0)&0x3F); 
	}
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd1d10:	e584312c 	str	r3, [r4, #300]	; 0x12c
	TmpReg32 = READ_REG(PHY_DLL_RECALIB);
fffd1d14:	e5945124 	ldr	r5, [r4, #292]	; 0x124
	LogMessage ("> PHY_DLL_RECALIB (0x49) = 0x%08lX \n", TmpReg32);
fffd1d18:	e08f0000 	add	r0, pc, r0
fffd1d1c:	e1a01005 	mov	r1, r5
fffd1d20:	eb000a75 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> Delay of row/column address signals with respect to data output signals (dlls_trim_adrctrl_ma): ");
fffd1d24:	e59f0998 	ldr	r0, [pc, #2456]	; fffd26c4 <DisplayInfo+0xc54>
fffd1d28:	e08f0000 	add	r0, pc, r0
fffd1d2c:	eb000a72 	bl	fffd46fc <LogMessage>
	if ((TmpReg32&((UINT32)1<<27))!=0) 
fffd1d30:	e3150302 	tst	r5, #134217728	; 0x8000000
		LogMessage ("+"); // set to increment; limited by 1/4 clock (i.e., from dlls_trim_clk)
fffd1d34:	159f098c 	ldrne	r0, [pc, #2444]	; fffd26c8 <DisplayInfo+0xc58>
fffd1d38:	108f0000 	addne	r0, pc, r0
	else
		LogMessage ("-"); // decrement; limited by 1/4 clock
fffd1d3c:	059f0988 	ldreq	r0, [pc, #2440]	; fffd26cc <DisplayInfo+0xc5c>
fffd1d40:	008f0000 	addeq	r0, pc, r0
fffd1d44:	eb000a6c 	bl	fffd46fc <LogMessage>
	LogMessage ("%lu.\n", (TmpReg32>>0)&0x3F);
fffd1d48:	e59f0980 	ldr	r0, [pc, #2432]	; fffd26d0 <DisplayInfo+0xc60>
fffd1d4c:	e205103f 	and	r1, r5, #63	; 0x3f
fffd1d50:	e08f0000 	add	r0, pc, r0
fffd1d54:	eb000a68 	bl	fffd46fc <LogMessage>

	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // no a must, just in case
fffd1d58:	e3a03000 	mov	r3, #0
	TmpReg32 = READ_REG(PHY_DLL_TRIM_CLK);
	LogMessage ("> PHY_DLL_TRIM_CLK (0x69) = 0x%08lX \n", TmpReg32);
fffd1d5c:	e59f0970 	ldr	r0, [pc, #2416]	; fffd26d4 <DisplayInfo+0xc64>
	else
		LogMessage ("-"); // decrement; limited by 1/4 clock
	LogMessage ("%lu.\n", (TmpReg32>>0)&0x3F);

	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // no a must, just in case
fffd1d60:	e584312c 	str	r3, [r4, #300]	; 0x12c
	TmpReg32 = READ_REG(PHY_DLL_TRIM_CLK);
fffd1d64:	e59451a4 	ldr	r5, [r4, #420]	; 0x1a4
	LogMessage ("> PHY_DLL_TRIM_CLK (0x69) = 0x%08lX \n", TmpReg32);
fffd1d68:	e08f0000 	add	r0, pc, r0
fffd1d6c:	e1a01005 	mov	r1, r5
fffd1d70:	eb000a61 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> Delay of clock signal with respect to data output signals (dlls_trim_clk): ");
fffd1d74:	e59f095c 	ldr	r0, [pc, #2396]	; fffd26d8 <DisplayInfo+0xc68>
fffd1d78:	e08f0000 	add	r0, pc, r0
fffd1d7c:	eb000a5e 	bl	fffd46fc <LogMessage>
	if ((TmpReg32&0x40)!=0) 
fffd1d80:	e3150040 	tst	r5, #64	; 0x40
		LogMessage ("+"); // set to increment;
fffd1d84:	159f0950 	ldrne	r0, [pc, #2384]	; fffd26dc <DisplayInfo+0xc6c>
fffd1d88:	108f0000 	addne	r0, pc, r0
	else
		LogMessage ("-"); // decrement. (limited by the value of 1/4 clock)
fffd1d8c:	059f094c 	ldreq	r0, [pc, #2380]	; fffd26e0 <DisplayInfo+0xc70>
fffd1d90:	008f0000 	addeq	r0, pc, r0
fffd1d94:	eb000a58 	bl	fffd46fc <LogMessage>
	LogMessage ("%lu.\n", (TmpReg32>>0)&0x3F);
fffd1d98:	e59f0944 	ldr	r0, [pc, #2372]	; fffd26e4 <DisplayInfo+0xc74>
fffd1d9c:	e205103f 	and	r1, r5, #63	; 0x3f
	LogMessage ("  >> rise_cycle_cnt (half-cycle period detected by the DLL): = %lu \n", (TmpReg32>>4)&0xFF);
	*/
	//---------------------------------------------------------------
	
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just in case
fffd1da0:	e3a05000 	mov	r5, #0
	LogMessage ("> SCL_LATENCY (0x43) = 0x%08lX. \n", TmpReg32);
	LogMessage ("  >> capture_clk_dly: = %lu \n", (TmpReg32>>0)&0xF);
	LogMessageColor(COLOR_YELLOW,"  >> main_clk_dly: = %lu \n", (TmpReg32>>4)&0xF);
	//---------------------------------------------------------------

	LogMessage ("> Data Output Delay: \n");
fffd1da4:	e3a0ab02 	mov	r10, #2048	; 0x800
	LogMessage ("  >> Delay of clock signal with respect to data output signals (dlls_trim_clk): ");
	if ((TmpReg32&0x40)!=0) 
		LogMessage ("+"); // set to increment;
	else
		LogMessage ("-"); // decrement. (limited by the value of 1/4 clock)
	LogMessage ("%lu.\n", (TmpReg32>>0)&0x3F);
fffd1da8:	e08f0000 	add	r0, pc, r0
fffd1dac:	eb000a52 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> rise_cycle_cnt (half-cycle period detected by the DLL): = %lu \n", (TmpReg32>>4)&0xFF);
	*/
	//---------------------------------------------------------------
	
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just in case
fffd1db0:	e584512c 	str	r5, [r4, #300]	; 0x12c
	TmpReg32 = READ_REG(SCL_LATENCY);
	LogMessage ("> SCL_LATENCY (0x43) = 0x%08lX. \n", TmpReg32);
fffd1db4:	e59f092c 	ldr	r0, [pc, #2348]	; fffd26e8 <DisplayInfo+0xc78>
	*/
	//---------------------------------------------------------------
	
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just in case
	TmpReg32 = READ_REG(SCL_LATENCY);
fffd1db8:	e594810c 	ldr	r8, [r4, #268]	; 0x10c
	LogMessage ("> SCL_LATENCY (0x43) = 0x%08lX. \n", TmpReg32);
fffd1dbc:	e08f0000 	add	r0, pc, r0
fffd1dc0:	e1a01008 	mov	r1, r8
fffd1dc4:	eb000a4c 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> capture_clk_dly: = %lu \n", (TmpReg32>>0)&0xF);
fffd1dc8:	e59f091c 	ldr	r0, [pc, #2332]	; fffd26ec <DisplayInfo+0xc7c>
fffd1dcc:	e208100f 	and	r1, r8, #15
fffd1dd0:	e08f0000 	add	r0, pc, r0
fffd1dd4:	eb000a48 	bl	fffd46fc <LogMessage>
	LogMessageColor(COLOR_YELLOW,"  >> main_clk_dly: = %lu \n", (TmpReg32>>4)&0xF);
fffd1dd8:	e59f1910 	ldr	r1, [pc, #2320]	; fffd26f0 <DisplayInfo+0xc80>
fffd1ddc:	e3a00003 	mov	r0, #3
fffd1de0:	e7e32258 	ubfx	r2, r8, #4, #4
fffd1de4:	e08f1001 	add	r1, pc, r1
fffd1de8:	eb000a60 	bl	fffd4770 <LogMessageColor>
	//---------------------------------------------------------------

	LogMessage ("> Data Output Delay: \n");
fffd1dec:	e59f0900 	ldr	r0, [pc, #2304]	; fffd26f4 <DisplayInfo+0xc84>
fffd1df0:	e08f0000 	add	r0, pc, r0
fffd1df4:	eb000a40 	bl	fffd46fc <LogMessage>
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
fffd1df8:	e59f08f8 	ldr	r0, [pc, #2296]	; fffd26f8 <DisplayInfo+0xc88>
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1dfc:	e1a0b185 	lsl	r11, r5, #3
	//---------------------------------------------------------------

	LogMessage ("> Data Output Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
fffd1e00:	e1a01005 	mov	r1, r5
		for (ibit = 0 ; ibit < 8 ; ibit++) 
fffd1e04:	e3a09000 	mov	r9, #0
	//---------------------------------------------------------------

	LogMessage ("> Data Output Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
fffd1e08:	e08f0000 	add	r0, pc, r0
fffd1e0c:	eb000a3a 	bl	fffd46fc <LogMessage>
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1e10:	e065c00b 	rsb	r12, r5, r11
fffd1e14:	e08c3409 	add	r3, r12, r9, lsl #8
fffd1e18:	e58dc00c 	str	r12, [sp, #12]
			val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1e1c:	e59f18d8 	ldr	r1, [pc, #2264]	; fffd26fc <DisplayInfo+0xc8c>
fffd1e20:	e1a02009 	mov	r2, r9
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1e24:	e584312c 	str	r3, [r4, #300]	; 0x12c
			val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1e28:	e3a00003 	mov	r0, #3
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
fffd1e2c:	e59431a0 	ldr	r3, [r4, #416]	; 0x1a0

	LogMessage ("> Data Output Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
fffd1e30:	e2899001 	add	r9, r9, #1
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1e34:	e08f1001 	add	r1, pc, r1
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1e38:	e59f8804 	ldr	r8, [pc, #2052]	; fffd2644 <DisplayInfo+0xbd4>
			val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1e3c:	e203307f 	and	r3, r3, #127	; 0x7f
fffd1e40:	eb000a4a 	bl	fffd4770 <LogMessageColor>

	LogMessage ("> Data Output Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
fffd1e44:	e3590008 	cmp	r9, #8
fffd1e48:	e59dc00c 	ldr	r12, [sp, #12]
fffd1e4c:	1afffff0 	bne	fffd1e14 <DisplayInfo+0x3a4>
			val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
		}

		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1e50:	e588a12c 	str	r10, [r8, #300]	; 0x12c
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessageColor(COLOR_YELLOW,"DM:0x%02X, ",val);
fffd1e54:	e3a00003 	mov	r0, #3
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
		}

		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
fffd1e58:	e59821a0 	ldr	r2, [r8, #416]	; 0x1a0
		ibit = 9;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessage ("Base:0x%02X, ",val);

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
fffd1e5c:	e3a09006 	mov	r9, #6
		}

		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessageColor(COLOR_YELLOW,"DM:0x%02X, ",val);
fffd1e60:	e59f1898 	ldr	r1, [pc, #2200]	; fffd2700 <DisplayInfo+0xc90>
		ibit = 9;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessage ("Base:0x%02X, ",val);

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
fffd1e64:	e0090599 	mul	r9, r9, r5
		}

		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessageColor(COLOR_YELLOW,"DM:0x%02X, ",val);
fffd1e68:	e202207f 	and	r2, r2, #127	; 0x7f
fffd1e6c:	e08f1001 	add	r1, pc, r1
fffd1e70:	eb000a3e 	bl	fffd4770 <LogMessageColor>

		ibit = 9;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1e74:	e28a3c01 	add	r3, r10, #256	; 0x100
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessage ("Base:0x%02X, ",val);
fffd1e78:	e59f0884 	ldr	r0, [pc, #2180]	; fffd2704 <DisplayInfo+0xc94>
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessageColor(COLOR_YELLOW,"DM:0x%02X, ",val);

		ibit = 9;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1e7c:	e588312c 	str	r3, [r8, #300]	; 0x12c
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
fffd1e80:	e59811a0 	ldr	r1, [r8, #416]	; 0x1a0
		LogMessage ("Base:0x%02X, ",val);
fffd1e84:	e08f0000 	add	r0, pc, r0
fffd1e88:	e201107f 	and	r1, r1, #127	; 0x7f
fffd1e8c:	eb000a1a 	bl	fffd46fc <LogMessage>

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
fffd1e90:	e588912c 	str	r9, [r8, #300]	; 0x12c
		val = (UINT8) (READ_REG (PHY_DLL_TRIM_1) & 0x3F) ;
fffd1e94:	e5981130 	ldr	r1, [r8, #304]	; 0x130
		if (((READ_REG (PHY_DLL_INCR_TRIM_1)>>ilane) & 0x01)==0x01)
fffd1e98:	e5983164 	ldr	r3, [r8, #356]	; 0x164
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (OP_DQ_DM_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessage ("Base:0x%02X, ",val);

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
		val = (UINT8) (READ_REG (PHY_DLL_TRIM_1) & 0x3F) ;
fffd1e9c:	e201103f 	and	r1, r1, #63	; 0x3f
		if (((READ_REG (PHY_DLL_INCR_TRIM_1)>>ilane) & 0x01)==0x01)
fffd1ea0:	e1a03533 	lsr	r3, r3, r5
fffd1ea4:	e3130001 	tst	r3, #1
			LogMessage ("trim_1:+%u, ",val); // output dqs timing with respect to output dq/dm signals
fffd1ea8:	159f0858 	ldrne	r0, [pc, #2136]	; fffd2708 <DisplayInfo+0xc98>
fffd1eac:	108f0000 	addne	r0, pc, r0
		else
			LogMessage ("trim_1:-%u, ",val);
fffd1eb0:	059f0854 	ldreq	r0, [pc, #2132]	; fffd270c <DisplayInfo+0xc9c>
fffd1eb4:	008f0000 	addeq	r0, pc, r0
fffd1eb8:	eb000a0f 	bl	fffd46fc <LogMessage>

		WRITE_REG (PHY_LANE_SEL,(ilane*5));
fffd1ebc:	e0853105 	add	r3, r5, r5, lsl #2
		val = (UINT8) ((READ_REG (UNQ_ANALOG_DLL_3) >> 0) & 0x1F);
		LogMessage ("phase1:%u/64 cycle, ",val);  // DQS delayed on the write side
fffd1ec0:	e59f0848 	ldr	r0, [pc, #2120]	; fffd2710 <DisplayInfo+0xca0>
	LogMessage ("  >> capture_clk_dly: = %lu \n", (TmpReg32>>0)&0xF);
	LogMessageColor(COLOR_YELLOW,"  >> main_clk_dly: = %lu \n", (TmpReg32>>4)&0xF);
	//---------------------------------------------------------------

	LogMessage ("> Data Output Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd1ec4:	e2855001 	add	r5, r5, #1
		if (((READ_REG (PHY_DLL_INCR_TRIM_1)>>ilane) & 0x01)==0x01)
			LogMessage ("trim_1:+%u, ",val); // output dqs timing with respect to output dq/dm signals
		else
			LogMessage ("trim_1:-%u, ",val);

		WRITE_REG (PHY_LANE_SEL,(ilane*5));
fffd1ec8:	e584312c 	str	r3, [r4, #300]	; 0x12c
fffd1ecc:	e28aa007 	add	r10, r10, #7
		val = (UINT8) ((READ_REG (UNQ_ANALOG_DLL_3) >> 0) & 0x1F);
fffd1ed0:	e5941190 	ldr	r1, [r4, #400]	; 0x190
		LogMessage ("phase1:%u/64 cycle, ",val);  // DQS delayed on the write side
fffd1ed4:	e08f0000 	add	r0, pc, r0
fffd1ed8:	e201101f 	and	r1, r1, #31
fffd1edc:	eb000a06 	bl	fffd46fc <LogMessage>

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
fffd1ee0:	e584912c 	str	r9, [r4, #300]	; 0x12c
		val = (UINT8) (READ_REG (PHY_DLL_TRIM_2) & 0x3f) ;
		LogMessageColor(COLOR_YELLOW,"trim_2:%u, ",val); //  adjust output dq/dqs/dm timing with respect to DRAM clock; This value is set by write-levelling 
fffd1ee4:	e3a00003 	mov	r0, #3
		WRITE_REG (PHY_LANE_SEL,(ilane*5));
		val = (UINT8) ((READ_REG (UNQ_ANALOG_DLL_3) >> 0) & 0x1F);
		LogMessage ("phase1:%u/64 cycle, ",val);  // DQS delayed on the write side

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
		val = (UINT8) (READ_REG (PHY_DLL_TRIM_2) & 0x3f) ;
fffd1ee8:	e5942134 	ldr	r2, [r4, #308]	; 0x134
		LogMessageColor(COLOR_YELLOW,"trim_2:%u, ",val); //  adjust output dq/dqs/dm timing with respect to DRAM clock; This value is set by write-levelling 
fffd1eec:	e59f1820 	ldr	r1, [pc, #2080]	; fffd2714 <DisplayInfo+0xca4>
fffd1ef0:	e202203f 	and	r2, r2, #63	; 0x3f
fffd1ef4:	e08f1001 	add	r1, pc, r1
fffd1ef8:	eb000a1c 	bl	fffd4770 <LogMessageColor>
	
		WRITE_REG (PHY_LANE_SEL,(ilane*8));
fffd1efc:	e584b12c 	str	r11, [r4, #300]	; 0x12c
		val = (UINT8)((READ_REG (UNQ_ANALOG_DLL_2) >> 24) & 0xFF); // master delay line setting of this lane
		LogMessageColor(COLOR_YELLOW,"mas_dly:%u, ",val);
fffd1f00:	e3a00003 	mov	r0, #3
		WRITE_REG (PHY_LANE_SEL,(ilane*6));
		val = (UINT8) (READ_REG (PHY_DLL_TRIM_2) & 0x3f) ;
		LogMessageColor(COLOR_YELLOW,"trim_2:%u, ",val); //  adjust output dq/dqs/dm timing with respect to DRAM clock; This value is set by write-levelling 
	
		WRITE_REG (PHY_LANE_SEL,(ilane*8));
		val = (UINT8)((READ_REG (UNQ_ANALOG_DLL_2) >> 24) & 0xFF); // master delay line setting of this lane
fffd1f04:	e5942160 	ldr	r2, [r4, #352]	; 0x160
		LogMessageColor(COLOR_YELLOW,"mas_dly:%u, ",val);
fffd1f08:	e59f1808 	ldr	r1, [pc, #2056]	; fffd2718 <DisplayInfo+0xca8>
fffd1f0c:	e1a02c22 	lsr	r2, r2, #24
fffd1f10:	e08f1001 	add	r1, pc, r1
fffd1f14:	eb000a15 	bl	fffd4770 <LogMessageColor>
	
		LogMessage ("\n");
fffd1f18:	e59f07fc 	ldr	r0, [pc, #2044]	; fffd271c <DisplayInfo+0xcac>
fffd1f1c:	e08f0000 	add	r0, pc, r0
fffd1f20:	eb0009f5 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> capture_clk_dly: = %lu \n", (TmpReg32>>0)&0xF);
	LogMessageColor(COLOR_YELLOW,"  >> main_clk_dly: = %lu \n", (TmpReg32>>4)&0xF);
	//---------------------------------------------------------------

	LogMessage ("> Data Output Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd1f24:	e1550007 	cmp	r5, r7
fffd1f28:	3affffb2 	bcc	fffd1df8 <DisplayInfo+0x388>
		LogMessageColor(COLOR_YELLOW,"mas_dly:%u, ",val);
	
		LogMessage ("\n");
	}	
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
fffd1f2c:	e59f07ec 	ldr	r0, [pc, #2028]	; fffd2720 <DisplayInfo+0xcb0>
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd1f30:	e3a05000 	mov	r5, #0
		LogMessageColor(COLOR_YELLOW,"mas_dly:%u, ",val);
	
		LogMessage ("\n");
	}	
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
fffd1f34:	e08f0000 	add	r0, pc, r0
fffd1f38:	eb0009ef 	bl	fffd46fc <LogMessage>
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
fffd1f3c:	e59f07e0 	ldr	r0, [pc, #2016]	; fffd2724 <DisplayInfo+0xcb4>
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1f40:	e1a0a185 	lsl	r10, r5, #3
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
fffd1f44:	e3a09000 	mov	r9, #0
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1f48:	e065b00a 	rsb	r11, r5, r10
	}	
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
fffd1f4c:	e1a01005 	mov	r1, r5
fffd1f50:	e08f0000 	add	r0, pc, r0
fffd1f54:	eb0009e8 	bl	fffd46fc <LogMessage>
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1f58:	e08b3409 	add	r3, r11, r9, lsl #8
			val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1f5c:	e59f17c4 	ldr	r1, [pc, #1988]	; fffd2728 <DisplayInfo+0xcb8>
fffd1f60:	e1a02009 	mov	r2, r9
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1f64:	e59f86d8 	ldr	r8, [pc, #1752]	; fffd2644 <DisplayInfo+0xbd4>
fffd1f68:	e584312c 	str	r3, [r4, #300]	; 0x12c
			val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1f6c:	e3a00003 	mov	r0, #3
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
fffd1f70:	e5943194 	ldr	r3, [r4, #404]	; 0x194
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1f74:	e08f1001 	add	r1, pc, r1
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
fffd1f78:	e2899001 	add	r9, r9, #1
		{
			WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
			val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
fffd1f7c:	e203307f 	and	r3, r3, #127	; 0x7f
fffd1f80:	eb0009fa 	bl	fffd4770 <LogMessageColor>
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		LogMessage ("  >> Lane%lu: ", ilane );
		for (ibit = 0 ; ibit < 8 ; ibit++) 
fffd1f84:	e3590008 	cmp	r9, #8
fffd1f88:	1afffff2 	bne	fffd1f58 <DisplayInfo+0x4e8>
fffd1f8c:	e28bbb02 	add	r11, r11, #2048	; 0x800
		}

		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessage ("         Base:0x%02X, ",val);
fffd1f90:	e59f0794 	ldr	r0, [pc, #1940]	; fffd272c <DisplayInfo+0xcbc>
			val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
			LogMessageColor(COLOR_YELLOW,"DQ%lu:0x%02X, ",ibit,val);
		}

		ibit = 8;
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
fffd1f94:	e588b12c 	str	r11, [r8, #300]	; 0x12c
		val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
fffd1f98:	e5981194 	ldr	r1, [r8, #404]	; 0x194
		LogMessage ("         Base:0x%02X, ",val);
fffd1f9c:	e08f0000 	add	r0, pc, r0
fffd1fa0:	e201107f 	and	r1, r1, #127	; 0x7f
fffd1fa4:	eb0009d4 	bl	fffd46fc <LogMessage>

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
fffd1fa8:	e3a03006 	mov	r3, #6
fffd1fac:	e0030593 	mul	r3, r3, r5
fffd1fb0:	e588312c 	str	r3, [r8, #300]	; 0x12c
		val = (UINT8) (READ_REG (PHY_DLL_TRIM_3) & 0x3F) ;
fffd1fb4:	e5981138 	ldr	r1, [r8, #312]	; 0x138
		if (((READ_REG (PHY_DLL_INCR_TRIM_3)>>ilane) & 0x01)==0x01)
fffd1fb8:	e5983168 	ldr	r3, [r8, #360]	; 0x168
		WRITE_REG (PHY_LANE_SEL,(ilane*7)+((UINT32)ibit<<8));
		val = (UINT8) (READ_REG (IP_DQ_DQS_BITWISE_TRIM) & 0x7F) ;
		LogMessage ("         Base:0x%02X, ",val);

		WRITE_REG (PHY_LANE_SEL,(ilane*6));
		val = (UINT8) (READ_REG (PHY_DLL_TRIM_3) & 0x3F) ;
fffd1fbc:	e201103f 	and	r1, r1, #63	; 0x3f
		if (((READ_REG (PHY_DLL_INCR_TRIM_3)>>ilane) & 0x01)==0x01)
fffd1fc0:	e1a03533 	lsr	r3, r3, r5
fffd1fc4:	e3130001 	tst	r3, #1
			LogMessage ("trim_3:+%u, ",val);
fffd1fc8:	159f0760 	ldrne	r0, [pc, #1888]	; fffd2730 <DisplayInfo+0xcc0>
fffd1fcc:	108f0000 	addne	r0, pc, r0
		else
			LogMessage ("trim_3:-%u, ",val); // input dqs timing with respect to input dq
fffd1fd0:	059f075c 	ldreq	r0, [pc, #1884]	; fffd2734 <DisplayInfo+0xcc4>
fffd1fd4:	008f0000 	addeq	r0, pc, r0
fffd1fd8:	eb0009c7 	bl	fffd46fc <LogMessage>

		WRITE_REG (PHY_LANE_SEL,(ilane*5));
fffd1fdc:	e0853105 	add	r3, r5, r5, lsl #2
		val = (UINT8) ((READ_REG (UNQ_ANALOG_DLL_3) >> 8) & 0x1F);
		LogMessage ("phase2:%u/64 cycle, ",val);
fffd1fe0:	e59f0750 	ldr	r0, [pc, #1872]	; fffd2738 <DisplayInfo+0xcc8>
		if (((READ_REG (PHY_DLL_INCR_TRIM_3)>>ilane) & 0x01)==0x01)
			LogMessage ("trim_3:+%u, ",val);
		else
			LogMessage ("trim_3:-%u, ",val); // input dqs timing with respect to input dq

		WRITE_REG (PHY_LANE_SEL,(ilane*5));
fffd1fe4:	e59f8658 	ldr	r8, [pc, #1624]	; fffd2644 <DisplayInfo+0xbd4>
fffd1fe8:	e584312c 	str	r3, [r4, #300]	; 0x12c
		val = (UINT8) ((READ_REG (UNQ_ANALOG_DLL_3) >> 8) & 0x1F);
fffd1fec:	e5941190 	ldr	r1, [r4, #400]	; 0x190
		LogMessage ("phase2:%u/64 cycle, ",val);
fffd1ff0:	e08f0000 	add	r0, pc, r0
fffd1ff4:	e7e41451 	ubfx	r1, r1, #8, #5
fffd1ff8:	eb0009bf 	bl	fffd46fc <LogMessage>

		WRITE_REG (PHY_LANE_SEL,(ilane*8));
fffd1ffc:	e584a12c 	str	r10, [r4, #300]	; 0x12c
		val = (UINT8) (READ_REG (SCL_DCAPCLK_DLY) & 0xFF) ;
		LogMessageColor(COLOR_YELLOW,"data_capture_clk:0x%02X, ",val); // data_capture_clk edge used to transfer data from the input DQS clock domain to the PHY core clock domain // Automatically programmed by SCL
fffd2000:	e3a00003 	mov	r0, #3
		WRITE_REG (PHY_LANE_SEL,(ilane*5));
		val = (UINT8) ((READ_REG (UNQ_ANALOG_DLL_3) >> 8) & 0x1F);
		LogMessage ("phase2:%u/64 cycle, ",val);

		WRITE_REG (PHY_LANE_SEL,(ilane*8));
		val = (UINT8) (READ_REG (SCL_DCAPCLK_DLY) & 0xFF) ;
fffd2004:	e594213c 	ldr	r2, [r4, #316]	; 0x13c
		LogMessageColor(COLOR_YELLOW,"data_capture_clk:0x%02X, ",val); // data_capture_clk edge used to transfer data from the input DQS clock domain to the PHY core clock domain // Automatically programmed by SCL
fffd2008:	e59f172c 	ldr	r1, [pc, #1836]	; fffd273c <DisplayInfo+0xccc>
fffd200c:	e6ef2072 	uxtb	r2, r2
fffd2010:	e08f1001 	add	r1, pc, r1
fffd2014:	eb0009d5 	bl	fffd4770 <LogMessageColor>

		WRITE_REG (PHY_LANE_SEL,(ilane*3));
fffd2018:	e0853085 	add	r3, r5, r5, lsl #1
		val = (UINT8) (READ_REG (SCL_MAIN_CLK_DELTA) & 0x7); // SCL latency // Automatically programmed by SCL
		LogMessageColor(COLOR_YELLOW,"main_clk_delta_dly:0x%02X, ",val);
fffd201c:	e59f171c 	ldr	r1, [pc, #1820]	; fffd2740 <DisplayInfo+0xcd0>
fffd2020:	e3a00003 	mov	r0, #3

		WRITE_REG (PHY_LANE_SEL,(ilane*8));
		val = (UINT8) (READ_REG (SCL_DCAPCLK_DLY) & 0xFF) ;
		LogMessageColor(COLOR_YELLOW,"data_capture_clk:0x%02X, ",val); // data_capture_clk edge used to transfer data from the input DQS clock domain to the PHY core clock domain // Automatically programmed by SCL

		WRITE_REG (PHY_LANE_SEL,(ilane*3));
fffd2024:	e584312c 	str	r3, [r4, #300]	; 0x12c
	
		LogMessage ("\n");
	}	
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd2028:	e2855001 	add	r5, r5, #1
		WRITE_REG (PHY_LANE_SEL,(ilane*8));
		val = (UINT8) (READ_REG (SCL_DCAPCLK_DLY) & 0xFF) ;
		LogMessageColor(COLOR_YELLOW,"data_capture_clk:0x%02X, ",val); // data_capture_clk edge used to transfer data from the input DQS clock domain to the PHY core clock domain // Automatically programmed by SCL

		WRITE_REG (PHY_LANE_SEL,(ilane*3));
		val = (UINT8) (READ_REG (SCL_MAIN_CLK_DELTA) & 0x7); // SCL latency // Automatically programmed by SCL
fffd202c:	e5942140 	ldr	r2, [r4, #320]	; 0x140
		LogMessageColor(COLOR_YELLOW,"main_clk_delta_dly:0x%02X, ",val);
fffd2030:	e08f1001 	add	r1, pc, r1
fffd2034:	e2022007 	and	r2, r2, #7
fffd2038:	eb0009cc 	bl	fffd4770 <LogMessageColor>

		WRITE_REG (PHY_LANE_SEL,(ilane*8));
fffd203c:	e584a12c 	str	r10, [r4, #300]	; 0x12c
		val = (UINT8) ((READ_REG(SCL_START)>>20)&0xFF); // number of delay elements required to delay the clock signal to align with the read DQS falling edge
		LogMessageColor(COLOR_YELLOW,"cycle_cnt:0x%02X, ",val);
fffd2040:	e3a00003 	mov	r0, #3
		WRITE_REG (PHY_LANE_SEL,(ilane*3));
		val = (UINT8) (READ_REG (SCL_MAIN_CLK_DELTA) & 0x7); // SCL latency // Automatically programmed by SCL
		LogMessageColor(COLOR_YELLOW,"main_clk_delta_dly:0x%02X, ",val);

		WRITE_REG (PHY_LANE_SEL,(ilane*8));
		val = (UINT8) ((READ_REG(SCL_START)>>20)&0xFF); // number of delay elements required to delay the clock signal to align with the read DQS falling edge
fffd2044:	e5942100 	ldr	r2, [r4, #256]	; 0x100
		LogMessageColor(COLOR_YELLOW,"cycle_cnt:0x%02X, ",val);
fffd2048:	e59f16f4 	ldr	r1, [pc, #1780]	; fffd2744 <DisplayInfo+0xcd4>
fffd204c:	e7e72a52 	ubfx	r2, r2, #20, #8
fffd2050:	e08f1001 	add	r1, pc, r1
fffd2054:	eb0009c5 	bl	fffd4770 <LogMessageColor>

		LogMessage ("\n");
fffd2058:	e59f06e8 	ldr	r0, [pc, #1768]	; fffd2748 <DisplayInfo+0xcd8>
fffd205c:	e08f0000 	add	r0, pc, r0
fffd2060:	eb0009a5 	bl	fffd46fc <LogMessage>
	
		LogMessage ("\n");
	}	
	//----------------------------------------------------------------------
	LogMessage ("> Data Input Delay: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd2064:	e1550007 	cmp	r5, r7
fffd2068:	3affffb3 	bcc	fffd1f3c <DisplayInfo+0x4cc>
		LogMessageColor(COLOR_YELLOW,"cycle_cnt:0x%02X, ",val);

		LogMessage ("\n");
	}
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd206c:	e3a03000 	mov	r3, #0
	TmpReg32 = READ_REG (UNIQUIFY_IO_1);
	LogMessage ("> UNIQUIFY_IO_1 (0x5C) = 0x%08lX: \n",TmpReg32);
fffd2070:	e59f06d4 	ldr	r0, [pc, #1748]	; fffd274c <DisplayInfo+0xcdc>
		LogMessageColor(COLOR_YELLOW,"cycle_cnt:0x%02X, ",val);

		LogMessage ("\n");
	}
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd2074:	e588312c 	str	r3, [r8, #300]	; 0x12c
	TmpReg32 = READ_REG (UNIQUIFY_IO_1);
fffd2078:	e5985170 	ldr	r5, [r8, #368]	; 0x170
	LogMessage ("> UNIQUIFY_IO_1 (0x5C) = 0x%08lX: \n",TmpReg32);
fffd207c:	e08f0000 	add	r0, pc, r0
fffd2080:	e1a01005 	mov	r1, r5
fffd2084:	eb00099c 	bl	fffd46fc <LogMessage>
	if ( (TmpReg32&(1<<0/*start_io_calib*/ | 1<<15/*override_cal_p*/ | 1<<23/*override_cal_n*/)) == (1<<0) )
fffd2088:	e59f36c0 	ldr	r3, [pc, #1728]	; fffd2750 <DisplayInfo+0xce0>
fffd208c:	e0033005 	and	r3, r3, r5
fffd2090:	e3530001 	cmp	r3, #1
fffd2094:	1a000005 	bne	fffd20b0 <DisplayInfo+0x640>
		LogMessage ("  >> ZQ auto calibration is ON. Period: %u x 256 PHY clocks. \n", (READ_REG (PHY_DLL_RECALIB)>>8)&0x3ffff);
fffd2098:	e5981124 	ldr	r1, [r8, #292]	; 0x124
fffd209c:	e59f06b0 	ldr	r0, [pc, #1712]	; fffd2754 <DisplayInfo+0xce4>
fffd20a0:	e7f11451 	ubfx	r1, r1, #8, #18
fffd20a4:	e08f0000 	add	r0, pc, r0
fffd20a8:	eb000993 	bl	fffd46fc <LogMessage>
fffd20ac:	ea000002 	b	fffd20bc <DisplayInfo+0x64c>
	else
		LogWarning ("  >> ZQ auto calibration is OFF or overrided. \n");
fffd20b0:	e59f06a0 	ldr	r0, [pc, #1696]	; fffd2758 <DisplayInfo+0xce8>
fffd20b4:	e08f0000 	add	r0, pc, r0
fffd20b8:	eb0009cb 	bl	fffd47ec <LogWarning>
	
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd20bc:	e3a08000 	mov	r8, #0
	TmpReg32 = READ_REG (UNIQUIFY_IO_2);
	LogMessage ("> UNIQUIFY_IO_2 (0x5D) = 0x%08lX: \n",TmpReg32);
fffd20c0:	e59f0694 	ldr	r0, [pc, #1684]	; fffd275c <DisplayInfo+0xcec>
	if ( (TmpReg32&(1<<0/*start_io_calib*/ | 1<<15/*override_cal_p*/ | 1<<23/*override_cal_n*/)) == (1<<0) )
		LogMessage ("  >> ZQ auto calibration is ON. Period: %u x 256 PHY clocks. \n", (READ_REG (PHY_DLL_RECALIB)>>8)&0x3ffff);
	else
		LogWarning ("  >> ZQ auto calibration is OFF or overrided. \n");
	
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd20c4:	e584812c 	str	r8, [r4, #300]	; 0x12c
	TmpReg32 = READ_REG (UNIQUIFY_IO_2);
fffd20c8:	e5945174 	ldr	r5, [r4, #372]	; 0x174
	LogMessage ("> UNIQUIFY_IO_2 (0x5D) = 0x%08lX: \n",TmpReg32);
fffd20cc:	e08f0000 	add	r0, pc, r0
fffd20d0:	e1a01005 	mov	r1, r5
fffd20d4:	eb000988 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> ZQ Values:  nfet_cal:0x%lX, pfet_cal:0x%lX \n",(TmpReg32>>24)&0xf, (TmpReg32>>16)&0xf);
fffd20d8:	e59f0680 	ldr	r0, [pc, #1664]	; fffd2760 <DisplayInfo+0xcf0>
fffd20dc:	e7e32855 	ubfx	r2, r5, #16, #4
fffd20e0:	e7e31c55 	ubfx	r1, r5, #24, #4
fffd20e4:	e08f0000 	add	r0, pc, r0
fffd20e8:	eb000983 	bl	fffd46fc <LogMessage>
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
fffd20ec:	e584812c 	str	r8, [r4, #300]	; 0x12c
	TmpReg32 = READ_REG (PHY_PAD_CTRL);
	LogMessage ("> PHY_PAD_CTRL (0x48) = 0x%08lX: \n",TmpReg32);
fffd20f0:	e59f066c 	ldr	r0, [pc, #1644]	; fffd2764 <DisplayInfo+0xcf4>
	TmpReg32 = READ_REG (UNIQUIFY_IO_2);
	LogMessage ("> UNIQUIFY_IO_2 (0x5D) = 0x%08lX: \n",TmpReg32);
	LogMessage ("  >> ZQ Values:  nfet_cal:0x%lX, pfet_cal:0x%lX \n",(TmpReg32>>24)&0xf, (TmpReg32>>16)&0xf);
	//---------------------------------------------------------------
	WRITE_REG (PHY_LANE_SEL,0); // just for case
	TmpReg32 = READ_REG (PHY_PAD_CTRL);
fffd20f4:	e5945120 	ldr	r5, [r4, #288]	; 0x120
	LogMessage ("> PHY_PAD_CTRL (0x48) = 0x%08lX: \n",TmpReg32);
fffd20f8:	e08f0000 	add	r0, pc, r0
fffd20fc:	e1a01005 	mov	r1, r5
fffd2100:	eb00097d 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> DQ/DQS input dynamic termination (ODT): ");
fffd2104:	e59f065c 	ldr	r0, [pc, #1628]	; fffd2768 <DisplayInfo+0xcf8>
fffd2108:	e08f0000 	add	r0, pc, r0
fffd210c:	eb00097a 	bl	fffd46fc <LogMessage>
	switch (TmpReg32&0x7)
fffd2110:	e2053007 	and	r3, r5, #7
fffd2114:	e3530005 	cmp	r3, #5
fffd2118:	908ff103 	addls	pc, pc, r3, lsl #2
fffd211c:	ea000018 	b	fffd2184 <DisplayInfo+0x714>
fffd2120:	ea000004 	b	fffd2138 <DisplayInfo+0x6c8>
fffd2124:	ea000006 	b	fffd2144 <DisplayInfo+0x6d4>
fffd2128:	ea000009 	b	fffd2154 <DisplayInfo+0x6e4>
fffd212c:	ea00000b 	b	fffd2160 <DisplayInfo+0x6f0>
fffd2130:	ea00000d 	b	fffd216c <DisplayInfo+0x6fc>
fffd2134:	ea00000f 	b	fffd2178 <DisplayInfo+0x708>
	{
		case 0: LogMessage ("No \n"); break;
fffd2138:	e59f062c 	ldr	r0, [pc, #1580]	; fffd276c <DisplayInfo+0xcfc>
fffd213c:	e08f0000 	add	r0, pc, r0
fffd2140:	ea000001 	b	fffd214c <DisplayInfo+0x6dc>
		case 1: LogMessage ("240R \n"); break;
fffd2144:	e59f0624 	ldr	r0, [pc, #1572]	; fffd2770 <DisplayInfo+0xd00>
fffd2148:	e08f0000 	add	r0, pc, r0
fffd214c:	eb00096a 	bl	fffd46fc <LogMessage>
fffd2150:	ea00000e 	b	fffd2190 <DisplayInfo+0x720>
		case 2: LogMessage ("120R \n"); break;
fffd2154:	e59f0618 	ldr	r0, [pc, #1560]	; fffd2774 <DisplayInfo+0xd04>
fffd2158:	e08f0000 	add	r0, pc, r0
fffd215c:	eafffffa 	b	fffd214c <DisplayInfo+0x6dc>
		case 3: LogMessage ("80R \n"); break;
fffd2160:	e59f0610 	ldr	r0, [pc, #1552]	; fffd2778 <DisplayInfo+0xd08>
fffd2164:	e08f0000 	add	r0, pc, r0
fffd2168:	eafffff7 	b	fffd214c <DisplayInfo+0x6dc>
		case 4: LogMessage ("60R \n"); break;
fffd216c:	e59f0608 	ldr	r0, [pc, #1544]	; fffd277c <DisplayInfo+0xd0c>
fffd2170:	e08f0000 	add	r0, pc, r0
fffd2174:	eafffff4 	b	fffd214c <DisplayInfo+0x6dc>
		case 5: LogMessage ("48R \n"); break;
fffd2178:	e59f0600 	ldr	r0, [pc, #1536]	; fffd2780 <DisplayInfo+0xd10>
fffd217c:	e08f0000 	add	r0, pc, r0
fffd2180:	eafffff1 	b	fffd214c <DisplayInfo+0x6dc>
		default: LogError ("Reserved \n"); 
fffd2184:	e59f05f8 	ldr	r0, [pc, #1528]	; fffd2784 <DisplayInfo+0xd14>
fffd2188:	e08f0000 	add	r0, pc, r0
fffd218c:	eb000986 	bl	fffd47ac <LogError>
	}
	LogMessage ("  >> DQ/DM/DQS output drive strength: ");
fffd2190:	e59f05f0 	ldr	r0, [pc, #1520]	; fffd2788 <DisplayInfo+0xd18>
fffd2194:	e08f0000 	add	r0, pc, r0
fffd2198:	eb000957 	bl	fffd46fc <LogMessage>
	if ( (TmpReg32&((UINT32)1<<4)) == 0)
fffd219c:	e3150010 	tst	r5, #16
		LogMessage ("34R. \n");
fffd21a0:	059f05e4 	ldreq	r0, [pc, #1508]	; fffd278c <DisplayInfo+0xd1c>
fffd21a4:	008f0000 	addeq	r0, pc, r0
	else
		LogMessage ("48R. \n");
fffd21a8:	159f05e0 	ldrne	r0, [pc, #1504]	; fffd2790 <DisplayInfo+0xd20>
fffd21ac:	108f0000 	addne	r0, pc, r0
fffd21b0:	eb000951 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> Address and control output drive strength: ");
fffd21b4:	e59f05d8 	ldr	r0, [pc, #1496]	; fffd2794 <DisplayInfo+0xd24>
fffd21b8:	e08f0000 	add	r0, pc, r0
fffd21bc:	eb00094e 	bl	fffd46fc <LogMessage>
	if ( (TmpReg32&((UINT32)1<<16)) == 0)
fffd21c0:	e3150801 	tst	r5, #65536	; 0x10000
		LogMessage ("34R. \n");
fffd21c4:	059f05cc 	ldreq	r0, [pc, #1484]	; fffd2798 <DisplayInfo+0xd28>
fffd21c8:	008f0000 	addeq	r0, pc, r0
	else
		LogMessage ("48R. \n");
fffd21cc:	159f05c8 	ldrne	r0, [pc, #1480]	; fffd279c <DisplayInfo+0xd2c>
fffd21d0:	108f0000 	addne	r0, pc, r0
fffd21d4:	eb000948 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> Clock Output drive strength: ");
fffd21d8:	e59f05c0 	ldr	r0, [pc, #1472]	; fffd27a0 <DisplayInfo+0xd30>
fffd21dc:	e08f0000 	add	r0, pc, r0
fffd21e0:	eb000945 	bl	fffd46fc <LogMessage>
	if ( (TmpReg32&((UINT32)1<<20)) == 0)
fffd21e4:	e3150601 	tst	r5, #1048576	; 0x100000
		LogMessage ("34R. \n");
fffd21e8:	059f05b4 	ldreq	r0, [pc, #1460]	; fffd27a4 <DisplayInfo+0xd34>
fffd21ec:	008f0000 	addeq	r0, pc, r0
	else
		LogMessage ("48R. \n");
fffd21f0:	159f05b0 	ldrne	r0, [pc, #1456]	; fffd27a8 <DisplayInfo+0xd38>
fffd21f4:	108f0000 	addne	r0, pc, r0
fffd21f8:	eb00093f 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> preamble_dly = ");
fffd21fc:	e59f05a8 	ldr	r0, [pc, #1448]	; fffd27ac <DisplayInfo+0xd3c>
	switch((TmpReg32>>29)&0x3)
fffd2200:	e7e15ed5 	ubfx	r5, r5, #29, #2
	LogMessage ("  >> Clock Output drive strength: ");
	if ( (TmpReg32&((UINT32)1<<20)) == 0)
		LogMessage ("34R. \n");
	else
		LogMessage ("48R. \n");
	LogMessage ("  >> preamble_dly = ");
fffd2204:	e08f0000 	add	r0, pc, r0
fffd2208:	eb00093b 	bl	fffd46fc <LogMessage>
	switch((TmpReg32>>29)&0x3)
fffd220c:	e3550001 	cmp	r5, #1
fffd2210:	0a000008 	beq	fffd2238 <DisplayInfo+0x7c8>
fffd2214:	3a000004 	bcc	fffd222c <DisplayInfo+0x7bc>
fffd2218:	e3550002 	cmp	r5, #2
fffd221c:	1a000009 	bne	fffd2248 <DisplayInfo+0x7d8>
	{
	case 0: LogMessage ("2 cycles. \n"); break;
	case 1: LogMessage ("1.5 cycles. \n"); break;
	case 2: LogMessage ("1 cycle. \n"); break;
fffd2220:	e59f0588 	ldr	r0, [pc, #1416]	; fffd27b0 <DisplayInfo+0xd40>
fffd2224:	e08f0000 	add	r0, pc, r0
fffd2228:	ea000004 	b	fffd2240 <DisplayInfo+0x7d0>
	else
		LogMessage ("48R. \n");
	LogMessage ("  >> preamble_dly = ");
	switch((TmpReg32>>29)&0x3)
	{
	case 0: LogMessage ("2 cycles. \n"); break;
fffd222c:	e59f0580 	ldr	r0, [pc, #1408]	; fffd27b4 <DisplayInfo+0xd44>
fffd2230:	e08f0000 	add	r0, pc, r0
fffd2234:	ea000001 	b	fffd2240 <DisplayInfo+0x7d0>
	case 1: LogMessage ("1.5 cycles. \n"); break;
fffd2238:	e59f0578 	ldr	r0, [pc, #1400]	; fffd27b8 <DisplayInfo+0xd48>
fffd223c:	e08f0000 	add	r0, pc, r0
fffd2240:	eb00092d 	bl	fffd46fc <LogMessage>
fffd2244:	ea000002 	b	fffd2254 <DisplayInfo+0x7e4>
	case 2: LogMessage ("1 cycle. \n"); break;
	default:
		LogError ("Invalid. \n");
fffd2248:	e59f056c 	ldr	r0, [pc, #1388]	; fffd27bc <DisplayInfo+0xd4c>
fffd224c:	e08f0000 	add	r0, pc, r0
fffd2250:	eb000955 	bl	fffd47ac <LogError>
		LogMessage ("Analog. \n");
	else
		LogMessage ("Digital. \n");	
	*/
	//-----------------------------------------------------------------
	LogMessage ("> PHY VREF: \n");
fffd2254:	e59f0564 	ldr	r0, [pc, #1380]	; fffd27c0 <DisplayInfo+0xd50>
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd2258:	e3a05000 	mov	r5, #0
		LogMessage ("Analog. \n");
	else
		LogMessage ("Digital. \n");	
	*/
	//-----------------------------------------------------------------
	LogMessage ("> PHY VREF: \n");
fffd225c:	e08f0000 	add	r0, pc, r0
fffd2260:	eb000925 	bl	fffd46fc <LogMessage>
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		UINT8 Step, Range;
		WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
fffd2264:	e0653185 	rsb	r3, r5, r5, lsl #3
		UINT32 Reg_VREF_TRAINING = READ_REG (VREF_TRAINING);
		Step = (UINT8)((Reg_VREF_TRAINING >> 4) & 0x3F);
		Range = (UINT8)((Reg_VREF_TRAINING >> 10) & 0x1);
		LogMessage ("  >> Lane%lu: ",ilane);
fffd2268:	e59f0554 	ldr	r0, [pc, #1364]	; fffd27c4 <DisplayInfo+0xd54>
fffd226c:	e1a01005 	mov	r1, r5
	//-----------------------------------------------------------------
	LogMessage ("> PHY VREF: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		UINT8 Step, Range;
		WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
fffd2270:	e584312c 	str	r3, [r4, #300]	; 0x12c
	else
		LogMessage ("Digital. \n");	
	*/
	//-----------------------------------------------------------------
	LogMessage ("> PHY VREF: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd2274:	e2855001 	add	r5, r5, #1
	{
		UINT8 Step, Range;
		WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
		UINT32 Reg_VREF_TRAINING = READ_REG (VREF_TRAINING);
fffd2278:	e59481c8 	ldr	r8, [r4, #456]	; 0x1c8
		Step = (UINT8)((Reg_VREF_TRAINING >> 4) & 0x3F);
		Range = (UINT8)((Reg_VREF_TRAINING >> 10) & 0x1);
		LogMessage ("  >> Lane%lu: ",ilane);
fffd227c:	e08f0000 	add	r0, pc, r0
fffd2280:	eb00091d 	bl	fffd46fc <LogMessage>
	for (ilane=0; ilane<NumOfLanes; ilane++)
	{
		UINT8 Step, Range;
		WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
		UINT32 Reg_VREF_TRAINING = READ_REG (VREF_TRAINING);
		Step = (UINT8)((Reg_VREF_TRAINING >> 4) & 0x3F);
fffd2284:	e7e59258 	ubfx	r9, r8, #4, #6
		Range = (UINT8)((Reg_VREF_TRAINING >> 10) & 0x1);
fffd2288:	e7e08558 	ubfx	r8, r8, #10, #1
		LogMessage ("  >> Lane%lu: ",ilane);
		LogMessageColor(COLOR_YELLOW,"Range:%u; Step:0x%02X; (%u mV)\n",Range+1, Step, VrefDQ_Convert_Step_to_mV(Range, Step));
fffd228c:	e1a01009 	mov	r1, r9
fffd2290:	e1a00008 	mov	r0, r8
fffd2294:	ebfffde5 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
fffd2298:	e59f1528 	ldr	r1, [pc, #1320]	; fffd27c8 <DisplayInfo+0xd58>
fffd229c:	e2882001 	add	r2, r8, #1
fffd22a0:	e58d0000 	str	r0, [sp]
fffd22a4:	e1a03009 	mov	r3, r9
fffd22a8:	e3a00003 	mov	r0, #3
fffd22ac:	e08f1001 	add	r1, pc, r1
fffd22b0:	eb00092e 	bl	fffd4770 <LogMessageColor>
	else
		LogMessage ("Digital. \n");	
	*/
	//-----------------------------------------------------------------
	LogMessage ("> PHY VREF: \n");
	for (ilane=0; ilane<NumOfLanes; ilane++)
fffd22b4:	e1550007 	cmp	r5, r7
fffd22b8:	3affffe9 	bcc	fffd2264 <DisplayInfo+0x7f4>
		Range = (UINT8)((Reg_VREF_TRAINING >> 10) & 0x1);
		LogMessage ("  >> Lane%lu: ",ilane);
		LogMessageColor(COLOR_YELLOW,"Range:%u; Step:0x%02X; (%u mV)\n",Range+1, Step, VrefDQ_Convert_Step_to_mV(Range, Step));
	}
	//---------------------------------------------------------------
	LogMessage("\n");
fffd22bc:	e59f0508 	ldr	r0, [pc, #1288]	; fffd27cc <DisplayInfo+0xd5c>

	UINT16 MPR0_Readout [8*4];
	UINT16 *pMPR0_Readout = MPR0_Readout;
	//-------------
	LogMessage ("  >> Readout MPR Page 0: \n");
	MPR_Readout_RawData (0, MPR0_Readout);
fffd22c0:	e28d9018 	add	r9, sp, #24
fffd22c4:	e28d7028 	add	r7, sp, #40	; 0x28
fffd22c8:	e3a04000 	mov	r4, #0
		Range = (UINT8)((Reg_VREF_TRAINING >> 10) & 0x1);
		LogMessage ("  >> Lane%lu: ",ilane);
		LogMessageColor(COLOR_YELLOW,"Range:%u; Step:0x%02X; (%u mV)\n",Range+1, Step, VrefDQ_Convert_Step_to_mV(Range, Step));
	}
	//---------------------------------------------------------------
	LogMessage("\n");
fffd22cc:	e08f0000 	add	r0, pc, r0
fffd22d0:	eb000909 	bl	fffd46fc <LogMessage>
	LogHeader (" DRAM Device Information ");
fffd22d4:	e59f04f4 	ldr	r0, [pc, #1268]	; fffd27d0 <DisplayInfo+0xd60>
fffd22d8:	e08f0000 	add	r0, pc, r0
fffd22dc:	eb000962 	bl	fffd486c <LogHeader>

	UINT16 MPR0_Readout [8*4];
	UINT16 *pMPR0_Readout = MPR0_Readout;
	//-------------
	LogMessage ("  >> Readout MPR Page 0: \n");
fffd22e0:	e59f04ec 	ldr	r0, [pc, #1260]	; fffd27d4 <DisplayInfo+0xd64>
fffd22e4:	e08f0000 	add	r0, pc, r0
fffd22e8:	eb000903 	bl	fffd46fc <LogMessage>
	MPR_Readout_RawData (0, MPR0_Readout);
fffd22ec:	e3a00000 	mov	r0, #0
fffd22f0:	e1a01009 	mov	r1, r9
fffd22f4:	ebfffd67 	bl	fffd1898 <MPR_Readout_RawData>
	UINT8 x_row, y_row;
	for (y_row = 0; y_row<4; y_row++)
	{
		LogMessage("      %u: ",y_row);
fffd22f8:	e59f04d8 	ldr	r0, [pc, #1240]	; fffd27d8 <DisplayInfo+0xd68>
fffd22fc:	e1a01004 	mov	r1, r4
fffd2300:	e2475010 	sub	r5, r7, #16
fffd2304:	e08f0000 	add	r0, pc, r0
fffd2308:	eb0008fb 	bl	fffd46fc <LogMessage>
		for (x_row = 0; x_row<8; x_row++)
		{
			LogMessage("0x%04X ",*pMPR0_Readout);
fffd230c:	e59f04c8 	ldr	r0, [pc, #1224]	; fffd27dc <DisplayInfo+0xd6c>
fffd2310:	e0d510b2 	ldrh	r1, [r5], #2
fffd2314:	e08f0000 	add	r0, pc, r0
fffd2318:	eb0008f7 	bl	fffd46fc <LogMessage>
	MPR_Readout_RawData (0, MPR0_Readout);
	UINT8 x_row, y_row;
	for (y_row = 0; y_row<4; y_row++)
	{
		LogMessage("      %u: ",y_row);
		for (x_row = 0; x_row<8; x_row++)
fffd231c:	e1550007 	cmp	r5, r7
fffd2320:	1afffff9 	bne	fffd230c <DisplayInfo+0x89c>
		{
			LogMessage("0x%04X ",*pMPR0_Readout);
			pMPR0_Readout++;
		}
		LogMessage ("\n");
fffd2324:	e59f84b4 	ldr	r8, [pc, #1204]	; fffd27e0 <DisplayInfo+0xd70>
fffd2328:	e2844001 	add	r4, r4, #1
fffd232c:	e2857010 	add	r7, r5, #16
fffd2330:	e08f8008 	add	r8, pc, r8
fffd2334:	e1a00008 	mov	r0, r8
fffd2338:	eb0008ef 	bl	fffd46fc <LogMessage>
	UINT16 *pMPR0_Readout = MPR0_Readout;
	//-------------
	LogMessage ("  >> Readout MPR Page 0: \n");
	MPR_Readout_RawData (0, MPR0_Readout);
	UINT8 x_row, y_row;
	for (y_row = 0; y_row<4; y_row++)
fffd233c:	e3540004 	cmp	r4, #4
fffd2340:	1affffec 	bne	fffd22f8 <DisplayInfo+0x888>
			LogMessage("0x%04X ",*pMPR0_Readout);
			pMPR0_Readout++;
		}
		LogMessage ("\n");
	}
	if (MemoryCompare(DDR_MPR2_Expected,MPR0_Readout,32)!=0)
fffd2344:	e59f3498 	ldr	r3, [pc, #1176]	; fffd27e4 <DisplayInfo+0xd74>
fffd2348:	e1a01009 	mov	r1, r9
fffd234c:	e3a02020 	mov	r2, #32
fffd2350:	e7963003 	ldr	r3, [r6, r3]
fffd2354:	e1a00003 	mov	r0, r3
fffd2358:	e58d300c 	str	r3, [sp, #12]
fffd235c:	eb000348 	bl	fffd3084 <MemoryCompare>
fffd2360:	e3500000 	cmp	r0, #0
	{
		LogError ((" Error: Values are not as expected. \n"));
fffd2364:	159f047c 	ldrne	r0, [pc, #1148]	; fffd27e8 <DisplayInfo+0xd78>
fffd2368:	108f0000 	addne	r0, pc, r0
fffd236c:	1a00000e 	bne	fffd23ac <DisplayInfo+0x93c>
		return (1);
	}
	//--------------
	UINT8 MPR2[4];
	status = MPR_Page2_Readout (MPR2);
fffd2370:	e28d0014 	add	r0, sp, #20
fffd2374:	ebfffd7e 	bl	fffd1974 <MPR_Page2_Readout>
fffd2378:	e1a04000 	mov	r4, r0
	LogMessage ("  >> Readout MPR Page 2 => 0: 0x%02X, 1: 0x%02X, 2: 0x%02X, 3: 0x%02X. ",MPR2[0],MPR2[1],MPR2[2],MPR2[3]);
fffd237c:	e5dd0017 	ldrb	r0, [sp, #23]
fffd2380:	e5dd1014 	ldrb	r1, [sp, #20]
fffd2384:	e5dd2015 	ldrb	r2, [sp, #21]
fffd2388:	e58d0000 	str	r0, [sp]
fffd238c:	e59f0458 	ldr	r0, [pc, #1112]	; fffd27ec <DisplayInfo+0xd7c>
fffd2390:	e5dd3016 	ldrb	r3, [sp, #22]
fffd2394:	e08f0000 	add	r0, pc, r0
fffd2398:	eb0008d7 	bl	fffd46fc <LogMessage>
	if (status == (-1))
fffd239c:	e3740001 	cmn	r4, #1
fffd23a0:	1a000004 	bne	fffd23b8 <DisplayInfo+0x948>
	{
		LogError (" (Error: values may be invalid) \n");
fffd23a4:	e59f0444 	ldr	r0, [pc, #1092]	; fffd27f0 <DisplayInfo+0xd80>
fffd23a8:	e08f0000 	add	r0, pc, r0
fffd23ac:	eb0008fe 	bl	fffd47ac <LogError>
		return (1);
fffd23b0:	e3a00001 	mov	r0, #1
fffd23b4:	ea00009f 	b	fffd2638 <DisplayInfo+0xbc8>
	}
	else
		//LogPass (" (values are valid) \n");
		LogPass ("\n");
fffd23b8:	e1a00008 	mov	r0, r8
fffd23bc:	eb00091a 	bl	fffd482c <LogPass>
	//--------------------------------
	LogMessage ("  >> VREF DQ: ");
fffd23c0:	e59f042c 	ldr	r0, [pc, #1068]	; fffd27f4 <DisplayInfo+0xd84>
fffd23c4:	e08f0000 	add	r0, pc, r0
fffd23c8:	eb0008cb 	bl	fffd46fc <LogMessage>
	LogMessageColor(COLOR_YELLOW,"Range:%u; Step:0x%02X; (%u mV)\n",(MPR2[1]>>7) + 1, (MPR2[1]>>1)&0x3F, VrefDQ_Convert_Step_to_mV(MPR2[1]>>7,(MPR2[1]>>1)&0x3F));
fffd23cc:	e5dd4015 	ldrb	r4, [sp, #21]
fffd23d0:	e1a053a4 	lsr	r5, r4, #7
fffd23d4:	e7e540d4 	ubfx	r4, r4, #1, #6
fffd23d8:	e1a01004 	mov	r1, r4
fffd23dc:	e1a00005 	mov	r0, r5
fffd23e0:	ebfffd92 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
fffd23e4:	e59f140c 	ldr	r1, [pc, #1036]	; fffd27f8 <DisplayInfo+0xd88>
fffd23e8:	e1a03004 	mov	r3, r4
fffd23ec:	e58d0000 	str	r0, [sp]
fffd23f0:	e2852001 	add	r2, r5, #1
fffd23f4:	e3a00003 	mov	r0, #3
fffd23f8:	e08f1001 	add	r1, pc, r1
fffd23fc:	eb0008db 	bl	fffd4770 <LogMessageColor>
	LogMessage ("  >> Output drive strength: ");
fffd2400:	e59f03f4 	ldr	r0, [pc, #1012]	; fffd27fc <DisplayInfo+0xd8c>
fffd2404:	e08f0000 	add	r0, pc, r0
fffd2408:	eb0008bb 	bl	fffd46fc <LogMessage>
	switch (MPR2[3]&0x03)
fffd240c:	e5dd3017 	ldrb	r3, [sp, #23]
fffd2410:	e2133003 	ands	r3, r3, #3
fffd2414:	0a000004 	beq	fffd242c <DisplayInfo+0x9bc>
fffd2418:	e3530001 	cmp	r3, #1
fffd241c:	1a000006 	bne	fffd243c <DisplayInfo+0x9cc>
	{
		case 0:  LogMessage ("34R. \n"); break;
		case 1:  LogMessage ("48R. \n"); break;
fffd2420:	e59f03d8 	ldr	r0, [pc, #984]	; fffd2800 <DisplayInfo+0xd90>
fffd2424:	e08f0000 	add	r0, pc, r0
fffd2428:	ea000001 	b	fffd2434 <DisplayInfo+0x9c4>
	LogMessage ("  >> VREF DQ: ");
	LogMessageColor(COLOR_YELLOW,"Range:%u; Step:0x%02X; (%u mV)\n",(MPR2[1]>>7) + 1, (MPR2[1]>>1)&0x3F, VrefDQ_Convert_Step_to_mV(MPR2[1]>>7,(MPR2[1]>>1)&0x3F));
	LogMessage ("  >> Output drive strength: ");
	switch (MPR2[3]&0x03)
	{
		case 0:  LogMessage ("34R. \n"); break;
fffd242c:	e59f03d0 	ldr	r0, [pc, #976]	; fffd2804 <DisplayInfo+0xd94>
fffd2430:	e08f0000 	add	r0, pc, r0
		case 1:  LogMessage ("48R. \n"); break;
fffd2434:	eb0008b0 	bl	fffd46fc <LogMessage>
fffd2438:	ea000002 	b	fffd2448 <DisplayInfo+0x9d8>
		default: LogError ("Reserved \n"); break;
fffd243c:	e59f03c4 	ldr	r0, [pc, #964]	; fffd2808 <DisplayInfo+0xd98>
fffd2440:	e08f0000 	add	r0, pc, r0
fffd2444:	eb0008d8 	bl	fffd47ac <LogError>
	}
	LogMessage ("  >> RTT_NOM: ");
fffd2448:	e59f03bc 	ldr	r0, [pc, #956]	; fffd280c <DisplayInfo+0xd9c>
fffd244c:	e08f0000 	add	r0, pc, r0
fffd2450:	eb0008a9 	bl	fffd46fc <LogMessage>
	switch (MPR2[3]>>5)
fffd2454:	e5dd3017 	ldrb	r3, [sp, #23]
fffd2458:	e1a032a3 	lsr	r3, r3, #5
fffd245c:	e3530007 	cmp	r3, #7
fffd2460:	908ff103 	addls	pc, pc, r3, lsl #2
fffd2464:	ea000020 	b	fffd24ec <DisplayInfo+0xa7c>
fffd2468:	ea000006 	b	fffd2488 <DisplayInfo+0xa18>
fffd246c:	ea000008 	b	fffd2494 <DisplayInfo+0xa24>
fffd2470:	ea00000b 	b	fffd24a4 <DisplayInfo+0xa34>
fffd2474:	ea00000d 	b	fffd24b0 <DisplayInfo+0xa40>
fffd2478:	ea00000f 	b	fffd24bc <DisplayInfo+0xa4c>
fffd247c:	ea000011 	b	fffd24c8 <DisplayInfo+0xa58>
fffd2480:	ea000013 	b	fffd24d4 <DisplayInfo+0xa64>
fffd2484:	ea000015 	b	fffd24e0 <DisplayInfo+0xa70>
	{
		case 0: LogMessage ("Off \n"); break;
fffd2488:	e59f0380 	ldr	r0, [pc, #896]	; fffd2810 <DisplayInfo+0xda0>
fffd248c:	e08f0000 	add	r0, pc, r0
fffd2490:	ea000001 	b	fffd249c <DisplayInfo+0xa2c>
		case 1: LogMessage ("60R \n"); break;
fffd2494:	e59f0378 	ldr	r0, [pc, #888]	; fffd2814 <DisplayInfo+0xda4>
fffd2498:	e08f0000 	add	r0, pc, r0
fffd249c:	eb000896 	bl	fffd46fc <LogMessage>
fffd24a0:	ea000014 	b	fffd24f8 <DisplayInfo+0xa88>
		case 2: LogMessage ("120R \n"); break;
fffd24a4:	e59f036c 	ldr	r0, [pc, #876]	; fffd2818 <DisplayInfo+0xda8>
fffd24a8:	e08f0000 	add	r0, pc, r0
fffd24ac:	eafffffa 	b	fffd249c <DisplayInfo+0xa2c>
		case 3: LogMessage ("40R \n"); break;
fffd24b0:	e59f0364 	ldr	r0, [pc, #868]	; fffd281c <DisplayInfo+0xdac>
fffd24b4:	e08f0000 	add	r0, pc, r0
fffd24b8:	eafffff7 	b	fffd249c <DisplayInfo+0xa2c>
		case 4: LogMessage ("240R \n"); break;
fffd24bc:	e59f035c 	ldr	r0, [pc, #860]	; fffd2820 <DisplayInfo+0xdb0>
fffd24c0:	e08f0000 	add	r0, pc, r0
fffd24c4:	eafffff4 	b	fffd249c <DisplayInfo+0xa2c>
		case 5: LogMessage ("48R \n"); break;
fffd24c8:	e59f0354 	ldr	r0, [pc, #852]	; fffd2824 <DisplayInfo+0xdb4>
fffd24cc:	e08f0000 	add	r0, pc, r0
fffd24d0:	eafffff1 	b	fffd249c <DisplayInfo+0xa2c>
		case 6: LogMessage ("80R \n"); break;
fffd24d4:	e59f034c 	ldr	r0, [pc, #844]	; fffd2828 <DisplayInfo+0xdb8>
fffd24d8:	e08f0000 	add	r0, pc, r0
fffd24dc:	eaffffee 	b	fffd249c <DisplayInfo+0xa2c>
		case 7: LogMessage ("34R \n"); break;
fffd24e0:	e59f0344 	ldr	r0, [pc, #836]	; fffd282c <DisplayInfo+0xdbc>
fffd24e4:	e08f0000 	add	r0, pc, r0
fffd24e8:	eaffffeb 	b	fffd249c <DisplayInfo+0xa2c>
		default: LogError ("Reserved \n"); 
fffd24ec:	e59f033c 	ldr	r0, [pc, #828]	; fffd2830 <DisplayInfo+0xdc0>
fffd24f0:	e08f0000 	add	r0, pc, r0
fffd24f4:	eb0008ac 	bl	fffd47ac <LogError>
	}
	LogMessage ("  >> RTT_PARK: ");
fffd24f8:	e59f0334 	ldr	r0, [pc, #820]	; fffd2834 <DisplayInfo+0xdc4>
fffd24fc:	e08f0000 	add	r0, pc, r0
fffd2500:	eb00087d 	bl	fffd46fc <LogMessage>
	switch ((MPR2[3]>>2) & 0x7)
fffd2504:	e5dd3017 	ldrb	r3, [sp, #23]
fffd2508:	e7e23153 	ubfx	r3, r3, #2, #3
fffd250c:	e2433001 	sub	r3, r3, #1
fffd2510:	e3530006 	cmp	r3, #6
fffd2514:	908ff103 	addls	pc, pc, r3, lsl #2
fffd2518:	ea000006 	b	fffd2538 <DisplayInfo+0xac8>
fffd251c:	ea000008 	b	fffd2544 <DisplayInfo+0xad4>
fffd2520:	ea00000a 	b	fffd2550 <DisplayInfo+0xae0>
fffd2524:	ea00000c 	b	fffd255c <DisplayInfo+0xaec>
fffd2528:	ea00000e 	b	fffd2568 <DisplayInfo+0xaf8>
fffd252c:	ea000010 	b	fffd2574 <DisplayInfo+0xb04>
fffd2530:	ea000012 	b	fffd2580 <DisplayInfo+0xb10>
fffd2534:	ea000014 	b	fffd258c <DisplayInfo+0xb1c>
	{
		case 0: LogMessage ("Off \n"); break;
fffd2538:	e59f02f8 	ldr	r0, [pc, #760]	; fffd2838 <DisplayInfo+0xdc8>
fffd253c:	e08f0000 	add	r0, pc, r0
fffd2540:	ea000013 	b	fffd2594 <DisplayInfo+0xb24>
		case 1: LogMessage ("60R \n"); break; // RZQ/4
fffd2544:	e59f02f0 	ldr	r0, [pc, #752]	; fffd283c <DisplayInfo+0xdcc>
fffd2548:	e08f0000 	add	r0, pc, r0
fffd254c:	ea000010 	b	fffd2594 <DisplayInfo+0xb24>
		case 2: LogMessage ("120R \n"); break; // RZQ/2
fffd2550:	e59f02e8 	ldr	r0, [pc, #744]	; fffd2840 <DisplayInfo+0xdd0>
fffd2554:	e08f0000 	add	r0, pc, r0
fffd2558:	ea00000d 	b	fffd2594 <DisplayInfo+0xb24>
		case 3: LogMessage ("40R \n"); break; // RZQ/6
fffd255c:	e59f02e0 	ldr	r0, [pc, #736]	; fffd2844 <DisplayInfo+0xdd4>
fffd2560:	e08f0000 	add	r0, pc, r0
fffd2564:	ea00000a 	b	fffd2594 <DisplayInfo+0xb24>
		case 4: LogMessage ("240R \n"); break; // RZQ/1
fffd2568:	e59f02d8 	ldr	r0, [pc, #728]	; fffd2848 <DisplayInfo+0xdd8>
fffd256c:	e08f0000 	add	r0, pc, r0
fffd2570:	ea000007 	b	fffd2594 <DisplayInfo+0xb24>
		case 5: LogMessage ("48R \n"); break; // RZQ/5
fffd2574:	e59f02d0 	ldr	r0, [pc, #720]	; fffd284c <DisplayInfo+0xddc>
fffd2578:	e08f0000 	add	r0, pc, r0
fffd257c:	ea000004 	b	fffd2594 <DisplayInfo+0xb24>
		case 6: LogMessage ("80R \n"); break; // RZQ/3
fffd2580:	e59f02c8 	ldr	r0, [pc, #712]	; fffd2850 <DisplayInfo+0xde0>
fffd2584:	e08f0000 	add	r0, pc, r0
fffd2588:	ea000001 	b	fffd2594 <DisplayInfo+0xb24>
		case 7: LogMessage ("34R \n"); break; // RZQ/7
fffd258c:	e59f02c0 	ldr	r0, [pc, #704]	; fffd2854 <DisplayInfo+0xde4>
fffd2590:	e08f0000 	add	r0, pc, r0
fffd2594:	eb000858 	bl	fffd46fc <LogMessage>
		default: LogError ("Reserved \n"); 
	}
	LogMessage ("  >> RTT_WR: ");
fffd2598:	e59f02b8 	ldr	r0, [pc, #696]	; fffd2858 <DisplayInfo+0xde8>
fffd259c:	e08f0000 	add	r0, pc, r0
fffd25a0:	eb000855 	bl	fffd46fc <LogMessage>
	switch ((MPR2[0]>>0) & 0x3)
fffd25a4:	e5dd3014 	ldrb	r3, [sp, #20]
fffd25a8:	e2033003 	and	r3, r3, #3
fffd25ac:	e3530001 	cmp	r3, #1
fffd25b0:	0a000008 	beq	fffd25d8 <DisplayInfo+0xb68>
fffd25b4:	3a000004 	bcc	fffd25cc <DisplayInfo+0xb5c>
fffd25b8:	e3530002 	cmp	r3, #2
fffd25bc:	1a000009 	bne	fffd25e8 <DisplayInfo+0xb78>
	{
		case 0: LogMessage ("Off \n"); break;
		case 1: LogMessage ("120R \n"); break; // RZQ/2
		case 2: LogMessage ("240R \n"); break; // RZQ/1
fffd25c0:	e59f0294 	ldr	r0, [pc, #660]	; fffd285c <DisplayInfo+0xdec>
fffd25c4:	e08f0000 	add	r0, pc, r0
fffd25c8:	ea000004 	b	fffd25e0 <DisplayInfo+0xb70>
		default: LogError ("Reserved \n"); 
	}
	LogMessage ("  >> RTT_WR: ");
	switch ((MPR2[0]>>0) & 0x3)
	{
		case 0: LogMessage ("Off \n"); break;
fffd25cc:	e59f028c 	ldr	r0, [pc, #652]	; fffd2860 <DisplayInfo+0xdf0>
fffd25d0:	e08f0000 	add	r0, pc, r0
fffd25d4:	ea000001 	b	fffd25e0 <DisplayInfo+0xb70>
		case 1: LogMessage ("120R \n"); break; // RZQ/2
fffd25d8:	e59f0284 	ldr	r0, [pc, #644]	; fffd2864 <DisplayInfo+0xdf4>
fffd25dc:	e08f0000 	add	r0, pc, r0
fffd25e0:	eb000845 	bl	fffd46fc <LogMessage>
fffd25e4:	ea000002 	b	fffd25f4 <DisplayInfo+0xb84>
		case 2: LogMessage ("240R \n"); break; // RZQ/1
		default: LogError ("Reserved \n"); 
fffd25e8:	e59f0278 	ldr	r0, [pc, #632]	; fffd2868 <DisplayInfo+0xdf8>
fffd25ec:	e08f0000 	add	r0, pc, r0
fffd25f0:	eb00086d 	bl	fffd47ac <LogError>
	}
	LogMessage ("  >> CAS Latency (CL): 0x%x (%u) \n",MPR2[2]>>4, CL[MPR2[2]>>4]);  // 09/03/2016: added more info
fffd25f4:	e5dd1016 	ldrb	r1, [sp, #22]
fffd25f8:	e59f326c 	ldr	r3, [pc, #620]	; fffd286c <DisplayInfo+0xdfc>
fffd25fc:	e59f026c 	ldr	r0, [pc, #620]	; fffd2870 <DisplayInfo+0xe00>
fffd2600:	e1a01221 	lsr	r1, r1, #4
fffd2604:	e08f3003 	add	r3, pc, r3
fffd2608:	e08f0000 	add	r0, pc, r0
fffd260c:	e7d32001 	ldrb	r2, [r3, r1]
fffd2610:	eb000839 	bl	fffd46fc <LogMessage>
	LogMessage ("  >> CAS Write Latency (CWL): 0x%x (%u) \n", MPR2[2]&0x07, CWL[MPR2[2]&0x07]); // 09/03/2016: fixed a bug in the shift and added more info
fffd2614:	e5dd1016 	ldrb	r1, [sp, #22]
fffd2618:	e59f3254 	ldr	r3, [pc, #596]	; fffd2874 <DisplayInfo+0xe04>
fffd261c:	e59f0254 	ldr	r0, [pc, #596]	; fffd2878 <DisplayInfo+0xe08>
fffd2620:	e2011007 	and	r1, r1, #7
fffd2624:	e08f3003 	add	r3, pc, r3
fffd2628:	e08f0000 	add	r0, pc, r0
fffd262c:	e7d32001 	ldrb	r2, [r3, r1]
fffd2630:	eb000831 	bl	fffd46fc <LogMessage>

	return (0);
fffd2634:	e3a00000 	mov	r0, #0
}
fffd2638:	e28dd05c 	add	sp, sp, #92	; 0x5c
fffd263c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
fffd2640:	0000424c 	.word	0x0000424c
fffd2644:	f05f0000 	.word	0xf05f0000
fffd2648:	00004388 	.word	0x00004388
fffd264c:	f0824000 	.word	0xf0824000
fffd2650:	000057d8 	.word	0x000057d8
fffd2654:	0000438f 	.word	0x0000438f
fffd2658:	f0801000 	.word	0xf0801000
fffd265c:	00004384 	.word	0x00004384
fffd2660:	00004382 	.word	0x00004382
fffd2664:	00004382 	.word	0x00004382
fffd2668:	00004371 	.word	0x00004371
fffd266c:	00004389 	.word	0x00004389
fffd2670:	0000438d 	.word	0x0000438d
fffd2674:	000043b6 	.word	0x000043b6
fffd2678:	000043b8 	.word	0x000043b8
fffd267c:	000043b2 	.word	0x000043b2
fffd2680:	000043bc 	.word	0x000043bc
fffd2684:	000043c7 	.word	0x000043c7
fffd2688:	000043d1 	.word	0x000043d1
fffd268c:	000043ef 	.word	0x000043ef
fffd2690:	000043fc 	.word	0x000043fc
fffd2694:	0000442c 	.word	0x0000442c
fffd2698:	0000444a 	.word	0x0000444a
fffd269c:	00004459 	.word	0x00004459
fffd26a0:	00004481 	.word	0x00004481
fffd26a4:	00004496 	.word	0x00004496
fffd26a8:	000044a3 	.word	0x000044a3
fffd26ac:	000044e2 	.word	0x000044e2
fffd26b0:	00004525 	.word	0x00004525
fffd26b4:	0000456c 	.word	0x0000456c
fffd26b8:	00004566 	.word	0x00004566
fffd26bc:	000044f7 	.word	0x000044f7
fffd26c0:	00004540 	.word	0x00004540
fffd26c4:	00004555 	.word	0x00004555
fffd26c8:	0000451c 	.word	0x0000451c
fffd26cc:	00004516 	.word	0x00004516
fffd26d0:	000044a7 	.word	0x000044a7
fffd26d4:	0000457b 	.word	0x0000457b
fffd26d8:	00004591 	.word	0x00004591
fffd26dc:	000044cc 	.word	0x000044cc
fffd26e0:	000044c6 	.word	0x000044c6
fffd26e4:	0000444f 	.word	0x0000444f
fffd26e8:	0000459e 	.word	0x0000459e
fffd26ec:	000045ac 	.word	0x000045ac
fffd26f0:	000045b6 	.word	0x000045b6
fffd26f4:	000045c5 	.word	0x000045c5
fffd26f8:	000045c4 	.word	0x000045c4
fffd26fc:	000045a7 	.word	0x000045a7
fffd2700:	0000457e 	.word	0x0000457e
fffd2704:	000045d9 	.word	0x000045d9
fffd2708:	0000454a 	.word	0x0000454a
fffd270c:	0000454f 	.word	0x0000454f
fffd2710:	0000453c 	.word	0x0000453c
fffd2714:	00004531 	.word	0x00004531
fffd2718:	00004521 	.word	0x00004521
fffd271c:	00003db0 	.word	0x00003db0
fffd2720:	0000450a 	.word	0x0000450a
fffd2724:	0000447c 	.word	0x0000447c
fffd2728:	00004467 	.word	0x00004467
fffd272c:	000044b8 	.word	0x000044b8
fffd2730:	0000449f 	.word	0x0000449f
fffd2734:	000044a4 	.word	0x000044a4
fffd2738:	00004495 	.word	0x00004495
fffd273c:	0000448a 	.word	0x0000448a
fffd2740:	00004484 	.word	0x00004484
fffd2744:	00004480 	.word	0x00004480
fffd2748:	00003c70 	.word	0x00003c70
fffd274c:	00004467 	.word	0x00004467
fffd2750:	00808001 	.word	0x00808001
fffd2754:	00004463 	.word	0x00004463
fffd2758:	00004492 	.word	0x00004492
fffd275c:	000044aa 	.word	0x000044aa
fffd2760:	000044b6 	.word	0x000044b6
fffd2764:	000044d4 	.word	0x000044d4
fffd2768:	000044e7 	.word	0x000044e7
fffd276c:	000044e1 	.word	0x000044e1
fffd2770:	000044da 	.word	0x000044da
fffd2774:	000044d1 	.word	0x000044d1
fffd2778:	000044cc 	.word	0x000044cc
fffd277c:	000044c6 	.word	0x000044c6
fffd2780:	000044c0 	.word	0x000044c0
fffd2784:	000044ba 	.word	0x000044ba
fffd2788:	000044b9 	.word	0x000044b9
fffd278c:	000044d0 	.word	0x000044d0
fffd2790:	000044cf 	.word	0x000044cf
fffd2794:	000044ca 	.word	0x000044ca
fffd2798:	000044ac 	.word	0x000044ac
fffd279c:	000044ab 	.word	0x000044ab
fffd27a0:	000044d7 	.word	0x000044d7
fffd27a4:	00004488 	.word	0x00004488
fffd27a8:	00004487 	.word	0x00004487
fffd27ac:	000044d2 	.word	0x000044d2
fffd27b0:	000044e1 	.word	0x000044e1
fffd27b4:	000044bb 	.word	0x000044bb
fffd27b8:	000044bb 	.word	0x000044bb
fffd27bc:	000044c4 	.word	0x000044c4
fffd27c0:	000044bf 	.word	0x000044bf
fffd27c4:	00004150 	.word	0x00004150
fffd27c8:	0000447d 	.word	0x0000447d
fffd27cc:	00003a00 	.word	0x00003a00
fffd27d0:	00004471 	.word	0x00004471
fffd27d4:	0000447f 	.word	0x0000447f
fffd27d8:	0000447a 	.word	0x0000447a
fffd27dc:	00004475 	.word	0x00004475
fffd27e0:	0000399c 	.word	0x0000399c
fffd27e4:	00000000 	.word	0x00000000
fffd27e8:	00004429 	.word	0x00004429
fffd27ec:	00004423 	.word	0x00004423
fffd27f0:	00004457 	.word	0x00004457
fffd27f4:	0000445d 	.word	0x0000445d
fffd27f8:	00004331 	.word	0x00004331
fffd27fc:	0000442c 	.word	0x0000442c
fffd2800:	00004257 	.word	0x00004257
fffd2804:	00004244 	.word	0x00004244
fffd2808:	00004202 	.word	0x00004202
fffd280c:	00004401 	.word	0x00004401
fffd2810:	000043d0 	.word	0x000043d0
fffd2814:	0000419e 	.word	0x0000419e
fffd2818:	00004181 	.word	0x00004181
fffd281c:	0000416f 	.word	0x0000416f
fffd2820:	00004162 	.word	0x00004162
fffd2824:	00004170 	.word	0x00004170
fffd2828:	00004158 	.word	0x00004158
fffd282c:	0000437e 	.word	0x0000437e
fffd2830:	00004152 	.word	0x00004152
fffd2834:	0000436c 	.word	0x0000436c
fffd2838:	00004320 	.word	0x00004320
fffd283c:	000040ee 	.word	0x000040ee
fffd2840:	000040d5 	.word	0x000040d5
fffd2844:	000040c3 	.word	0x000040c3
fffd2848:	000040b6 	.word	0x000040b6
fffd284c:	000040c4 	.word	0x000040c4
fffd2850:	000040ac 	.word	0x000040ac
fffd2854:	000042d2 	.word	0x000042d2
fffd2858:	000042dc 	.word	0x000042dc
fffd285c:	0000405e 	.word	0x0000405e
fffd2860:	0000428c 	.word	0x0000428c
fffd2864:	0000404d 	.word	0x0000404d
fffd2868:	00004056 	.word	0x00004056
fffd286c:	00003479 	.word	0x00003479
fffd2870:	0000427e 	.word	0x0000427e
fffd2874:	0000461f 	.word	0x0000461f
fffd2878:	00004281 	.word	0x00004281

fffd287c <VrefDQ_Convert_to_Step>:
UINT8 VrefDQ_Convert_to_Step (UINT8 Range, UINT16 VrefDQ_mV)
{
	UINT8 Step;
	UINT16 VrefDQ_Percent;

	VrefDQ_Percent = (UINT16)( (((UINT32)VrefDQ_mV * (UINT32)10000) + 600)  / (UINT32)1200); 
fffd287c:	e3022710 	movw	r2, #10000	; 0x2710
	VrefDQ_mV = (UINT16)( (((UINT32)1200 * (UINT32)VrefDQ_Percent) + 5000) / (UINT32)10000); 
	return (VrefDQ_mV);
}
//-------------------------------------------------------------------------------
UINT8 VrefDQ_Convert_to_Step (UINT8 Range, UINT16 VrefDQ_mV)
{
fffd2880:	e92d4008 	push	{r3, lr}
	UINT8 Step;
	UINT16 VrefDQ_Percent;

	VrefDQ_Percent = (UINT16)( (((UINT32)VrefDQ_mV * (UINT32)10000) + 600)  / (UINT32)1200); 
fffd2884:	e0010192 	mul	r1, r2, r1

	if (Range==0) // range 1
fffd2888:	e3500000 	cmp	r0, #0
UINT8 VrefDQ_Convert_to_Step (UINT8 Range, UINT16 VrefDQ_mV)
{
	UINT8 Step;
	UINT16 VrefDQ_Percent;

	VrefDQ_Percent = (UINT16)( (((UINT32)VrefDQ_mV * (UINT32)10000) + 600)  / (UINT32)1200); 
fffd288c:	e2812f96 	add	r2, r1, #600	; 0x258
fffd2890:	e59f105c 	ldr	r1, [pc, #92]	; fffd28f4 <VrefDQ_Convert_to_Step+0x78>
fffd2894:	e0832192 	umull	r2, r3, r2, r1
fffd2898:	e3001cb2 	movw	r1, #3250	; 0xcb2
fffd289c:	e7ef33d3 	ubfx	r3, r3, #7, #16

	if (Range==0) // range 1
fffd28a0:	1a000006 	bne	fffd28c0 <VrefDQ_Convert_to_Step+0x44>
		if ((VrefDQ_Percent >= 6000)&& (VrefDQ_Percent <= 9250))
fffd28a4:	e2430d5d 	sub	r0, r3, #5952	; 0x1740
fffd28a8:	e2403030 	sub	r3, r0, #48	; 0x30
fffd28ac:	e6ff3073 	uxth	r3, r3
fffd28b0:	e1530001 	cmp	r3, r1
			Step = (UINT8)(((VrefDQ_Percent - (UINT16)6000) + 32) / (UINT16)65);
fffd28b4:	92400010 	subls	r0, r0, #16
	UINT16 VrefDQ_Percent;

	VrefDQ_Percent = (UINT16)( (((UINT32)VrefDQ_mV * (UINT32)10000) + 600)  / (UINT32)1200); 

	if (Range==0) // range 1
		if ((VrefDQ_Percent >= 6000)&& (VrefDQ_Percent <= 9250))
fffd28b8:	8a00000b 	bhi	fffd28ec <VrefDQ_Convert_to_Step+0x70>
fffd28bc:	ea000006 	b	fffd28dc <VrefDQ_Convert_to_Step+0x60>
			Step = (UINT8)(((VrefDQ_Percent - (UINT16)6000) + 32) / (UINT16)65);
		else
			Step = (UINT8)(-1); // out-of-range
	else // range 2
		if ((VrefDQ_Percent >= 4500) && (VrefDQ_Percent <= 7750))
fffd28c0:	e2432d46 	sub	r2, r3, #4480	; 0x1180
fffd28c4:	e2422014 	sub	r2, r2, #20
fffd28c8:	e6ff2072 	uxth	r2, r2
fffd28cc:	e1520001 	cmp	r2, r1
fffd28d0:	8a000005 	bhi	fffd28ec <VrefDQ_Convert_to_Step+0x70>
			Step = (UINT8)(((VrefDQ_Percent - (UINT16)4500) + 32) / (UINT16)65);
fffd28d4:	e2430d45 	sub	r0, r3, #4416	; 0x1140
fffd28d8:	e2400034 	sub	r0, r0, #52	; 0x34
fffd28dc:	e3a01041 	mov	r1, #65	; 0x41
fffd28e0:	fa00099e 	blx	fffd4f60 <__aeabi_idiv>
fffd28e4:	e6ef0070 	uxtb	r0, r0
fffd28e8:	e8bd8008 	pop	{r3, pc}

	if (Range==0) // range 1
		if ((VrefDQ_Percent >= 6000)&& (VrefDQ_Percent <= 9250))
			Step = (UINT8)(((VrefDQ_Percent - (UINT16)6000) + 32) / (UINT16)65);
		else
			Step = (UINT8)(-1); // out-of-range
fffd28ec:	e3a000ff 	mov	r0, #255	; 0xff
			Step = (UINT8)(((VrefDQ_Percent - (UINT16)4500) + 32) / (UINT16)65);
		else 
			Step = (UINT8)(-1); // out-of-range

	return (Step);
}
fffd28f0:	e8bd8008 	pop	{r3, pc}
fffd28f4:	1b4e81b5 	.word	0x1b4e81b5

fffd28f8 <VrefDQ_Convert_mV_to_Step_Range>:
//-------------------------------------------------------------------------------
int VrefDQ_Convert_mV_to_Step_Range (UINT16 VrefDQ_mV, UINT8 *Range, UINT8 *Step)
{
fffd28f8:	e92d4070 	push	{r4, r5, r6, lr}
fffd28fc:	e1a05000 	mov	r5, r0
fffd2900:	e1a04001 	mov	r4, r1
	*Step = VrefDQ_Convert_to_Step(*Range, VrefDQ_mV);
fffd2904:	e5d10000 	ldrb	r0, [r1]
fffd2908:	e1a01005 	mov	r1, r5

	return (Step);
}
//-------------------------------------------------------------------------------
int VrefDQ_Convert_mV_to_Step_Range (UINT16 VrefDQ_mV, UINT8 *Range, UINT8 *Step)
{
fffd290c:	e1a06002 	mov	r6, r2
	*Step = VrefDQ_Convert_to_Step(*Range, VrefDQ_mV);
fffd2910:	ebffffd9 	bl	fffd287c <VrefDQ_Convert_to_Step>
	if (*Step == (UINT8)(-1))
fffd2914:	e35000ff 	cmp	r0, #255	; 0xff
	return (Step);
}
//-------------------------------------------------------------------------------
int VrefDQ_Convert_mV_to_Step_Range (UINT16 VrefDQ_mV, UINT8 *Range, UINT8 *Step)
{
	*Step = VrefDQ_Convert_to_Step(*Range, VrefDQ_mV);
fffd2918:	e5c60000 	strb	r0, [r6]
	if (*Step == (UINT8)(-1))
fffd291c:	1a00001a 	bne	fffd298c <VrefDQ_Convert_mV_to_Step_Range+0x94>
	{
		// swap range and try again 
		if (*Range == 0) 
fffd2920:	e5d43000 	ldrb	r3, [r4]
			*Range = 1;
		else
			*Range = 0;

		*Step = VrefDQ_Convert_to_Step(*Range, VrefDQ_mV);	
fffd2924:	e1a01005 	mov	r1, r5
{
	*Step = VrefDQ_Convert_to_Step(*Range, VrefDQ_mV);
	if (*Step == (UINT8)(-1))
	{
		// swap range and try again 
		if (*Range == 0) 
fffd2928:	e3530000 	cmp	r3, #0
			*Range = 1;
fffd292c:	03a03001 	moveq	r3, #1
		else
			*Range = 0;
fffd2930:	13a03000 	movne	r3, #0
fffd2934:	e5c43000 	strb	r3, [r4]

		*Step = VrefDQ_Convert_to_Step(*Range, VrefDQ_mV);	
fffd2938:	e5d40000 	ldrb	r0, [r4]
fffd293c:	ebffffce 	bl	fffd287c <VrefDQ_Convert_to_Step>
		if (*Step == (UINT8)(-1))
fffd2940:	e35000ff 	cmp	r0, #255	; 0xff
		if (*Range == 0) 
			*Range = 1;
		else
			*Range = 0;

		*Step = VrefDQ_Convert_to_Step(*Range, VrefDQ_mV);	
fffd2944:	e5c60000 	strb	r0, [r6]
		if (*Step == (UINT8)(-1))
fffd2948:	1a00000f 	bne	fffd298c <VrefDQ_Convert_mV_to_Step_Range+0x94>
		{
			LOG_ERROR (("Failed to set DRAM VrefDQ. Out-Of-Range on both ranges. VrefDQ_mV=%u",VrefDQ_mV));
fffd294c:	e59f0040 	ldr	r0, [pc, #64]	; fffd2994 <VrefDQ_Convert_mV_to_Step_Range+0x9c>
fffd2950:	e300267d 	movw	r2, #1661	; 0x67d
fffd2954:	e59f103c 	ldr	r1, [pc, #60]	; fffd2998 <VrefDQ_Convert_mV_to_Step_Range+0xa0>
fffd2958:	e59f303c 	ldr	r3, [pc, #60]	; fffd299c <VrefDQ_Convert_mV_to_Step_Range+0xa4>
fffd295c:	e08f0000 	add	r0, pc, r0
fffd2960:	e08f1001 	add	r1, pc, r1
fffd2964:	e08f3003 	add	r3, pc, r3
fffd2968:	eb00078f 	bl	fffd47ac <LogError>
fffd296c:	e59f002c 	ldr	r0, [pc, #44]	; fffd29a0 <VrefDQ_Convert_mV_to_Step_Range+0xa8>
fffd2970:	e1a01005 	mov	r1, r5
fffd2974:	e08f0000 	add	r0, pc, r0
fffd2978:	eb00078b 	bl	fffd47ac <LogError>
fffd297c:	e59f0020 	ldr	r0, [pc, #32]	; fffd29a4 <VrefDQ_Convert_mV_to_Step_Range+0xac>
fffd2980:	e08f0000 	add	r0, pc, r0
fffd2984:	eb00075c 	bl	fffd46fc <LogMessage>
fffd2988:	eafffffe 	b	fffd2988 <VrefDQ_Convert_mV_to_Step_Range+0x90>
			while (1);
			return (-1);
		}
	}
	return (0);
}
fffd298c:	e3a00000 	mov	r0, #0
fffd2990:	e8bd8070 	pop	{r4, r5, r6, pc}
fffd2994:	000028f2 	.word	0x000028f2
fffd2998:	0000317f 	.word	0x0000317f
fffd299c:	00003129 	.word	0x00003129
fffd29a0:	00003f5f 	.word	0x00003f5f
fffd29a4:	0000334c 	.word	0x0000334c

fffd29a8 <VrefDQ_Set_DRAM>:
//-------------------------------------------------------------------------------
void VrefDQ_Set_DRAM (UINT8 Range, UINT8 Step)
{
	// We need to find DDR.MR6 origin value (note that in this register only the tCCD_L filed is needed (CAS_n to CAS_n command	delay for same bank group), typically it should be 5 for 800MHz).
	// Since DDR.MR6 is write only we can try read MC register but can never be sure if this was the last value written.
	UINT32 MR6_origin = IOR32(MC_BASE_ADDR + (MR6_DATA_F0_0_ADDR*4)) & 0x1FFFF ; // DENALI_CTL_92
fffd29a8:	e59f3038 	ldr	r3, [pc, #56]	; fffd29e8 <VrefDQ_Set_DRAM+0x40>
fffd29ac:	e1810300 	orr	r0, r1, r0, lsl #6
	}
	return (0);
}
//-------------------------------------------------------------------------------
void VrefDQ_Set_DRAM (UINT8 Range, UINT8 Step)
{
fffd29b0:	e92d4010 	push	{r4, lr}
	// We need to find DDR.MR6 origin value (note that in this register only the tCCD_L filed is needed (CAS_n to CAS_n command	delay for same bank group), typically it should be 5 for 800MHz).
	// Since DDR.MR6 is write only we can try read MC register but can never be sure if this was the last value written.
	UINT32 MR6_origin = IOR32(MC_BASE_ADDR + (MR6_DATA_F0_0_ADDR*4)) & 0x1FFFF ; // DENALI_CTL_92
fffd29b4:	e5932170 	ldr	r2, [r3, #368]	; 0x170
	UINT32 MR6_mask = MR6_origin & ~(UINT32)0x7F; // remove VrefDQ Training Range (bit 6) and VrefDQ Training Value (bits 5:0)
fffd29b8:	e59f302c 	ldr	r3, [pc, #44]	; fffd29ec <VrefDQ_Set_DRAM+0x44>
fffd29bc:	e0033002 	and	r3, r3, r2
	WriteModeReg (6, MR6_mask | (UINT32)Step |  (UINT32)Range<<6 | (UINT32)1<<7 /*place in VrefDQ training mode*/ );
fffd29c0:	e1804003 	orr	r4, r0, r3
fffd29c4:	e3a00006 	mov	r0, #6
fffd29c8:	e3841080 	orr	r1, r4, #128	; 0x80
fffd29cc:	ebfffb8c 	bl	fffd1804 <WriteModeReg>
	Sleep (10);
fffd29d0:	e3a0000a 	mov	r0, #10
fffd29d4:	eb000839 	bl	fffd4ac0 <Sleep>
	WriteModeReg (6, MR6_mask | (UINT32)Step |  (UINT32)Range<<6 );
fffd29d8:	e1a01004 	mov	r1, r4
fffd29dc:	e3a00006 	mov	r0, #6
};
fffd29e0:	e8bd4010 	pop	{r4, lr}
	// Since DDR.MR6 is write only we can try read MC register but can never be sure if this was the last value written.
	UINT32 MR6_origin = IOR32(MC_BASE_ADDR + (MR6_DATA_F0_0_ADDR*4)) & 0x1FFFF ; // DENALI_CTL_92
	UINT32 MR6_mask = MR6_origin & ~(UINT32)0x7F; // remove VrefDQ Training Range (bit 6) and VrefDQ Training Value (bits 5:0)
	WriteModeReg (6, MR6_mask | (UINT32)Step |  (UINT32)Range<<6 | (UINT32)1<<7 /*place in VrefDQ training mode*/ );
	Sleep (10);
	WriteModeReg (6, MR6_mask | (UINT32)Step |  (UINT32)Range<<6 );
fffd29e4:	eafffb86 	b	fffd1804 <WriteModeReg>
fffd29e8:	f0824000 	.word	0xf0824000
fffd29ec:	0001ff80 	.word	0x0001ff80

fffd29f0 <TestOutputMargin>:
	return (status);
}	

//---------------------------------------------------------------------------------------------------------------------
BOOL TestOutputMargin (void)
{
fffd29f0:	e92d47ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, lr}
	UINT8 DRAM_VrefDQ_Step_Qrigin, DRAM_VrefDQ_Range_Origin;
	UINT16 VrefDQ_mV_Qrigin;
	UINT8 DRAM_VrefDQ_Step, DRAM_VrefDQ_Range;
	UINT16 VrefDQ_mV;
	UINT32 DqMask[3] = {0,0,0};
fffd29f4:	e3a05000 	mov	r5, #0
	BOOL status = 0;
	

	//--------------------------------------------------------------------------
	// Get VrefDQ default value
	VrefDQ_Get_DRAM (&DRAM_VrefDQ_Range_Origin, &DRAM_VrefDQ_Step_Qrigin);
fffd29f8:	e28d0001 	add	r0, sp, #1
fffd29fc:	e1a0100d 	mov	r1, sp
	//-------------------------------------------------------------------------
	// Sweep output parameters
	//status |= Sweep_Trim_OutputDQ_Offset (DqMask, 4, "@VrefDQ:default");
	//-------------------------------------------------------------------------
	DRAM_VrefDQ_Step = 0;
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
fffd2a00:	e28d8010 	add	r8, sp, #16
	VrefDQ_mV = VrefDQ_mV_Qrigin + VrefDQ_Margin; 
	VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &DRAM_VrefDQ_Range, &DRAM_VrefDQ_Step);
fffd2a04:	e28d7002 	add	r7, sp, #2
{
	UINT8 DRAM_VrefDQ_Step_Qrigin, DRAM_VrefDQ_Range_Origin;
	UINT16 VrefDQ_mV_Qrigin;
	UINT8 DRAM_VrefDQ_Step, DRAM_VrefDQ_Range;
	UINT16 VrefDQ_mV;
	UINT32 DqMask[3] = {0,0,0};
fffd2a08:	e58d5004 	str	r5, [sp, #4]
	LogHeader (" Set DRAM VrefDQ: SetPoint+%umV", VrefDQ_Margin);
	LogMessage ("> %u mv (range: %u, step %u)\n", VrefDQ_mV, DRAM_VrefDQ_Range+1, DRAM_VrefDQ_Step);
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range, DRAM_VrefDQ_Step); // Set new VrefDQ values 
	//--------------------------------------------------------------------------
	// Sweep output parameters
	status |= Sweep_Trim_OutputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
fffd2a0c:	e28da004 	add	r10, sp, #4
{
	UINT8 DRAM_VrefDQ_Step_Qrigin, DRAM_VrefDQ_Range_Origin;
	UINT16 VrefDQ_mV_Qrigin;
	UINT8 DRAM_VrefDQ_Step, DRAM_VrefDQ_Range;
	UINT16 VrefDQ_mV;
	UINT32 DqMask[3] = {0,0,0};
fffd2a10:	e58d5008 	str	r5, [sp, #8]
fffd2a14:	e58d500c 	str	r5, [sp, #12]
	BOOL status = 0;
	

	//--------------------------------------------------------------------------
	// Get VrefDQ default value
	VrefDQ_Get_DRAM (&DRAM_VrefDQ_Range_Origin, &DRAM_VrefDQ_Step_Qrigin);
fffd2a18:	ebfffbf5 	bl	fffd19f4 <VrefDQ_Get_DRAM>
	VrefDQ_mV_Qrigin = VrefDQ_Convert_Step_to_mV(DRAM_VrefDQ_Range_Origin, DRAM_VrefDQ_Step_Qrigin);
fffd2a1c:	e5dd1000 	ldrb	r1, [sp]
fffd2a20:	e5dd0001 	ldrb	r0, [sp, #1]
fffd2a24:	ebfffc01 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
fffd2a28:	e1a04000 	mov	r4, r0
	LogHeader (" DRAM VrefDQ: Default SetPoint");
fffd2a2c:	e59f0144 	ldr	r0, [pc, #324]	; fffd2b78 <TestOutputMargin+0x188>
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
	VrefDQ_mV = VrefDQ_mV_Qrigin + VrefDQ_Margin; 
	VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &DRAM_VrefDQ_Range, &DRAM_VrefDQ_Step);
	VrefDQ_mV = VrefDQ_Convert_Step_to_mV(DRAM_VrefDQ_Range, DRAM_VrefDQ_Step);
	LogHeader (" Set DRAM VrefDQ: SetPoint+%umV", VrefDQ_Margin);
	LogMessage ("> %u mv (range: %u, step %u)\n", VrefDQ_mV, DRAM_VrefDQ_Range+1, DRAM_VrefDQ_Step);
fffd2a30:	e59f6144 	ldr	r6, [pc, #324]	; fffd2b7c <TestOutputMargin+0x18c>

	//--------------------------------------------------------------------------
	// Get VrefDQ default value
	VrefDQ_Get_DRAM (&DRAM_VrefDQ_Range_Origin, &DRAM_VrefDQ_Step_Qrigin);
	VrefDQ_mV_Qrigin = VrefDQ_Convert_Step_to_mV(DRAM_VrefDQ_Range_Origin, DRAM_VrefDQ_Step_Qrigin);
	LogHeader (" DRAM VrefDQ: Default SetPoint");
fffd2a34:	e08f0000 	add	r0, pc, r0
fffd2a38:	eb00078b 	bl	fffd486c <LogHeader>
	LogMessage ("> %u mv (range: %u, step %u)\n\n", VrefDQ_mV_Qrigin, DRAM_VrefDQ_Range_Origin+1, DRAM_VrefDQ_Step_Qrigin);
fffd2a3c:	e5dd2001 	ldrb	r2, [sp, #1]
fffd2a40:	e1a01004 	mov	r1, r4
fffd2a44:	e59f0134 	ldr	r0, [pc, #308]	; fffd2b80 <TestOutputMargin+0x190>
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
	VrefDQ_mV = VrefDQ_mV_Qrigin + VrefDQ_Margin; 
	VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &DRAM_VrefDQ_Range, &DRAM_VrefDQ_Step);
	VrefDQ_mV = VrefDQ_Convert_Step_to_mV(DRAM_VrefDQ_Range, DRAM_VrefDQ_Step);
	LogHeader (" Set DRAM VrefDQ: SetPoint+%umV", VrefDQ_Margin);
	LogMessage ("> %u mv (range: %u, step %u)\n", VrefDQ_mV, DRAM_VrefDQ_Range+1, DRAM_VrefDQ_Step);
fffd2a48:	e08f6006 	add	r6, pc, r6
	//--------------------------------------------------------------------------
	// Get VrefDQ default value
	VrefDQ_Get_DRAM (&DRAM_VrefDQ_Range_Origin, &DRAM_VrefDQ_Step_Qrigin);
	VrefDQ_mV_Qrigin = VrefDQ_Convert_Step_to_mV(DRAM_VrefDQ_Range_Origin, DRAM_VrefDQ_Step_Qrigin);
	LogHeader (" DRAM VrefDQ: Default SetPoint");
	LogMessage ("> %u mv (range: %u, step %u)\n\n", VrefDQ_mV_Qrigin, DRAM_VrefDQ_Range_Origin+1, DRAM_VrefDQ_Step_Qrigin);
fffd2a4c:	e5dd3000 	ldrb	r3, [sp]
fffd2a50:	e2822001 	add	r2, r2, #1
fffd2a54:	e08f0000 	add	r0, pc, r0
fffd2a58:	eb000727 	bl	fffd46fc <LogMessage>
	//-------------------------------------------------------------------------
	// Sweep output parameters
	//status |= Sweep_Trim_OutputDQ_Offset (DqMask, 4, "@VrefDQ:default");
	//-------------------------------------------------------------------------
	DRAM_VrefDQ_Step = 0;
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
fffd2a5c:	e5dd3001 	ldrb	r3, [sp, #1]
	VrefDQ_mV = VrefDQ_mV_Qrigin + VrefDQ_Margin; 
fffd2a60:	e2840032 	add	r0, r4, #50	; 0x32
	VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &DRAM_VrefDQ_Range, &DRAM_VrefDQ_Step);
fffd2a64:	e1a02007 	mov	r2, r7
fffd2a68:	e6ff0070 	uxth	r0, r0
	LogMessage ("> %u mv (range: %u, step %u)\n\n", VrefDQ_mV_Qrigin, DRAM_VrefDQ_Range_Origin+1, DRAM_VrefDQ_Step_Qrigin);
	//-------------------------------------------------------------------------
	// Sweep output parameters
	//status |= Sweep_Trim_OutputDQ_Offset (DqMask, 4, "@VrefDQ:default");
	//-------------------------------------------------------------------------
	DRAM_VrefDQ_Step = 0;
fffd2a6c:	e5cd5002 	strb	r5, [sp, #2]
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
fffd2a70:	e568300d 	strb	r3, [r8, #-13]!
	VrefDQ_mV = VrefDQ_mV_Qrigin + VrefDQ_Margin; 
	VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &DRAM_VrefDQ_Range, &DRAM_VrefDQ_Step);
fffd2a74:	e1a01008 	mov	r1, r8
fffd2a78:	ebffff9e 	bl	fffd28f8 <VrefDQ_Convert_mV_to_Step_Range>
	VrefDQ_mV = VrefDQ_Convert_Step_to_mV(DRAM_VrefDQ_Range, DRAM_VrefDQ_Step);
fffd2a7c:	e5dd1002 	ldrb	r1, [sp, #2]
fffd2a80:	e5dd0003 	ldrb	r0, [sp, #3]
fffd2a84:	ebfffbe9 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
fffd2a88:	e1a09000 	mov	r9, r0
	LogHeader (" Set DRAM VrefDQ: SetPoint+%umV", VrefDQ_Margin);
fffd2a8c:	e59f00f0 	ldr	r0, [pc, #240]	; fffd2b84 <TestOutputMargin+0x194>
fffd2a90:	e3a01032 	mov	r1, #50	; 0x32
fffd2a94:	e08f0000 	add	r0, pc, r0
fffd2a98:	eb000773 	bl	fffd486c <LogHeader>
	LogMessage ("> %u mv (range: %u, step %u)\n", VrefDQ_mV, DRAM_VrefDQ_Range+1, DRAM_VrefDQ_Step);
fffd2a9c:	e5dd2003 	ldrb	r2, [sp, #3]
fffd2aa0:	e1a00006 	mov	r0, r6
fffd2aa4:	e5dd3002 	ldrb	r3, [sp, #2]
fffd2aa8:	e1a01009 	mov	r1, r9
fffd2aac:	e2822001 	add	r2, r2, #1
fffd2ab0:	eb000711 	bl	fffd46fc <LogMessage>
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range, DRAM_VrefDQ_Step); // Set new VrefDQ values 
fffd2ab4:	e5dd0003 	ldrb	r0, [sp, #3]
fffd2ab8:	e5dd1002 	ldrb	r1, [sp, #2]
fffd2abc:	ebffffb9 	bl	fffd29a8 <VrefDQ_Set_DRAM>
	//--------------------------------------------------------------------------
	// Sweep output parameters
	status |= Sweep_Trim_OutputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
fffd2ac0:	e59f20c0 	ldr	r2, [pc, #192]	; fffd2b88 <TestOutputMargin+0x198>
fffd2ac4:	e1a0000a 	mov	r0, r10
fffd2ac8:	e3a01003 	mov	r1, #3
fffd2acc:	e08f2002 	add	r2, pc, r2
fffd2ad0:	ebfffa5b 	bl	fffd1444 <Sweep_Trim_OutputDQ_Offset>
	//---------------------------------------------------------------------------
	DRAM_VrefDQ_Step = 0;
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
fffd2ad4:	e5dd3001 	ldrb	r3, [sp, #1]
	LogHeader (" Set DRAM VrefDQ: SetPoint+%umV", VrefDQ_Margin);
	LogMessage ("> %u mv (range: %u, step %u)\n", VrefDQ_mV, DRAM_VrefDQ_Range+1, DRAM_VrefDQ_Step);
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range, DRAM_VrefDQ_Step); // Set new VrefDQ values 
	//--------------------------------------------------------------------------
	// Sweep output parameters
	status |= Sweep_Trim_OutputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
fffd2ad8:	e1a09000 	mov	r9, r0
	//---------------------------------------------------------------------------
	DRAM_VrefDQ_Step = 0;
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
	VrefDQ_mV = VrefDQ_mV_Qrigin - VrefDQ_Margin; 
fffd2adc:	e2440032 	sub	r0, r4, #50	; 0x32
	VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &DRAM_VrefDQ_Range, &DRAM_VrefDQ_Step);
fffd2ae0:	e1a02007 	mov	r2, r7
fffd2ae4:	e1a01008 	mov	r1, r8
fffd2ae8:	e6ff0070 	uxth	r0, r0
	//--------------------------------------------------------------------------
	// Sweep output parameters
	status |= Sweep_Trim_OutputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
	//---------------------------------------------------------------------------
	DRAM_VrefDQ_Step = 0;
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
fffd2aec:	e5cd3003 	strb	r3, [sp, #3]
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range, DRAM_VrefDQ_Step); // Set new VrefDQ values 
	//--------------------------------------------------------------------------
	// Sweep output parameters
	status |= Sweep_Trim_OutputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
	//---------------------------------------------------------------------------
	DRAM_VrefDQ_Step = 0;
fffd2af0:	e5cd5002 	strb	r5, [sp, #2]
	DRAM_VrefDQ_Range = DRAM_VrefDQ_Range_Origin;
	VrefDQ_mV = VrefDQ_mV_Qrigin - VrefDQ_Margin; 
	VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &DRAM_VrefDQ_Range, &DRAM_VrefDQ_Step);
fffd2af4:	ebffff7f 	bl	fffd28f8 <VrefDQ_Convert_mV_to_Step_Range>
	VrefDQ_mV = VrefDQ_Convert_Step_to_mV(DRAM_VrefDQ_Range, DRAM_VrefDQ_Step);
fffd2af8:	e5dd1002 	ldrb	r1, [sp, #2]
fffd2afc:	e5dd0003 	ldrb	r0, [sp, #3]
fffd2b00:	ebfffbca 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
fffd2b04:	e1a04000 	mov	r4, r0
	LogHeader (" Set DRAM VrefDQ: SetPoint-%umV", VrefDQ_Margin);
fffd2b08:	e59f007c 	ldr	r0, [pc, #124]	; fffd2b8c <TestOutputMargin+0x19c>
fffd2b0c:	e3a01032 	mov	r1, #50	; 0x32
fffd2b10:	e08f0000 	add	r0, pc, r0
fffd2b14:	eb000754 	bl	fffd486c <LogHeader>
	LogMessage ("> %u mv (range: %u, step %u)\n", VrefDQ_mV, DRAM_VrefDQ_Range+1, DRAM_VrefDQ_Step);
fffd2b18:	e5dd2003 	ldrb	r2, [sp, #3]
fffd2b1c:	e1a00006 	mov	r0, r6
fffd2b20:	e5dd3002 	ldrb	r3, [sp, #2]
fffd2b24:	e1a01004 	mov	r1, r4
fffd2b28:	e2822001 	add	r2, r2, #1
fffd2b2c:	eb0006f2 	bl	fffd46fc <LogMessage>
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range, DRAM_VrefDQ_Step); // Set new VrefDQ values 
fffd2b30:	e5dd0003 	ldrb	r0, [sp, #3]
fffd2b34:	e5dd1002 	ldrb	r1, [sp, #2]
fffd2b38:	ebffff9a 	bl	fffd29a8 <VrefDQ_Set_DRAM>
	//--------------------------------------------------------------------------
	// Sweep output parameters
	status |= Sweep_Trim_OutputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:-dV");
fffd2b3c:	e59f204c 	ldr	r2, [pc, #76]	; fffd2b90 <TestOutputMargin+0x1a0>
fffd2b40:	e1a0000a 	mov	r0, r10
fffd2b44:	e3a01003 	mov	r1, #3
fffd2b48:	e08f2002 	add	r2, pc, r2
fffd2b4c:	ebfffa3c 	bl	fffd1444 <Sweep_Trim_OutputDQ_Offset>
	//--------------------------------------------------------------------------
	// restore trim values 
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range_Origin, DRAM_VrefDQ_Step_Qrigin); 
fffd2b50:	e5dd1000 	ldrb	r1, [sp]
	LogHeader (" Set DRAM VrefDQ: SetPoint-%umV", VrefDQ_Margin);
	LogMessage ("> %u mv (range: %u, step %u)\n", VrefDQ_mV, DRAM_VrefDQ_Range+1, DRAM_VrefDQ_Step);
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range, DRAM_VrefDQ_Step); // Set new VrefDQ values 
	//--------------------------------------------------------------------------
	// Sweep output parameters
	status |= Sweep_Trim_OutputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:-dV");
fffd2b54:	e1809009 	orr	r9, r0, r9
	//--------------------------------------------------------------------------
	// restore trim values 
	VrefDQ_Set_DRAM (DRAM_VrefDQ_Range_Origin, DRAM_VrefDQ_Step_Qrigin); 
fffd2b58:	e5dd0001 	ldrb	r0, [sp, #1]
fffd2b5c:	ebffff91 	bl	fffd29a8 <VrefDQ_Set_DRAM>
	//--------------------------------------------------------------------------
	LogMessage ("\n");
fffd2b60:	e59f002c 	ldr	r0, [pc, #44]	; fffd2b94 <TestOutputMargin+0x1a4>
fffd2b64:	e08f0000 	add	r0, pc, r0
fffd2b68:	eb0006e3 	bl	fffd46fc <LogMessage>

	return (status);
}
fffd2b6c:	e1a00009 	mov	r0, r9
fffd2b70:	e28dd010 	add	sp, sp, #16
fffd2b74:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, r10, pc}
fffd2b78:	00003ee4 	.word	0x00003ee4
fffd2b7c:	00003f2e 	.word	0x00003f2e
fffd2b80:	00003ee3 	.word	0x00003ee3
fffd2b84:	00003ec2 	.word	0x00003ec2
fffd2b88:	00003ec8 	.word	0x00003ec8
fffd2b8c:	00003e90 	.word	0x00003e90
fffd2b90:	00003e78 	.word	0x00003e78
fffd2b94:	00003168 	.word	0x00003168

fffd2b98 <VrefDQ_Get_PHY>:
	WriteModeReg (6, MR6_mask | (UINT32)Step |  (UINT32)Range<<6 );
};
//-------------------------------------------------------------------------------
void VrefDQ_Get_PHY (UINT8 ilane, UINT8 *Range, UINT8 *Step)
{
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
fffd2b98:	e59f301c 	ldr	r3, [pc, #28]	; fffd2bbc <VrefDQ_Get_PHY+0x24>
fffd2b9c:	e0600180 	rsb	r0, r0, r0, lsl #3
fffd2ba0:	e583012c 	str	r0, [r3, #300]	; 0x12c
	UINT32 Reg_VREF_TRAINING = READ_REG (VREF_TRAINING);
fffd2ba4:	e59331c8 	ldr	r3, [r3, #456]	; 0x1c8
	*Step = (UINT8)((Reg_VREF_TRAINING >> 4) & 0x3F);
fffd2ba8:	e7e50253 	ubfx	r0, r3, #4, #6
	*Range = (UINT8)((Reg_VREF_TRAINING >> 10) & 0x1);
fffd2bac:	e7e03553 	ubfx	r3, r3, #10, #1
//-------------------------------------------------------------------------------
void VrefDQ_Get_PHY (UINT8 ilane, UINT8 *Range, UINT8 *Step)
{
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
	UINT32 Reg_VREF_TRAINING = READ_REG (VREF_TRAINING);
	*Step = (UINT8)((Reg_VREF_TRAINING >> 4) & 0x3F);
fffd2bb0:	e5c20000 	strb	r0, [r2]
	*Range = (UINT8)((Reg_VREF_TRAINING >> 10) & 0x1);
fffd2bb4:	e5c13000 	strb	r3, [r1]
fffd2bb8:	e12fff1e 	bx	lr
fffd2bbc:	f05f0000 	.word	0xf05f0000

fffd2bc0 <VrefDQ_Set_PHY>:

		internally shift register look like this: <6,5,4,3,2,1,0><6,5,4,3,2,1,0><6,5,4,3,2,1,0>; 7 bit for each lane. 

	*/

	UINT32 vref_value = (UINT32)Range<<6 | (UINT32)Step;
fffd2bc0:	e1822301 	orr	r2, r2, r1, lsl #6

	// update vref_value; this step use to write vref_value.0
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
fffd2bc4:	e59f302c 	ldr	r3, [pc, #44]	; fffd2bf8 <VrefDQ_Set_PHY+0x38>
fffd2bc8:	e0600180 	rsb	r0, r0, r0, lsl #3
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);  
fffd2bcc:	e1a01202 	lsl	r1, r2, #4

	// update vref_value ; this step use to write vref_value.6..1 
	vref_value = vref_value >> 1;
fffd2bd0:	e1a020a2 	lsr	r2, r2, #1
	*/

	UINT32 vref_value = (UINT32)Range<<6 | (UINT32)Step;

	// update vref_value; this step use to write vref_value.0
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
fffd2bd4:	e583012c 	str	r0, [r3, #300]	; 0x12c
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);  

	// update vref_value ; this step use to write vref_value.6..1 
	vref_value = vref_value >> 1;
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7)+1/*shift by 1*/);	
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);   
fffd2bd8:	e1a02202 	lsl	r2, r2, #4

	UINT32 vref_value = (UINT32)Range<<6 | (UINT32)Step;

	// update vref_value; this step use to write vref_value.0
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);  
fffd2bdc:	e3811004 	orr	r1, r1, #4

	// update vref_value ; this step use to write vref_value.6..1 
	vref_value = vref_value >> 1;
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7)+1/*shift by 1*/);	
fffd2be0:	e2800001 	add	r0, r0, #1

	UINT32 vref_value = (UINT32)Range<<6 | (UINT32)Step;

	// update vref_value; this step use to write vref_value.0
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);  
fffd2be4:	e58311c8 	str	r1, [r3, #456]	; 0x1c8

	// update vref_value ; this step use to write vref_value.6..1 
	vref_value = vref_value >> 1;
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7)+1/*shift by 1*/);	
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);   
fffd2be8:	e3822004 	orr	r2, r2, #4
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7));	
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);  

	// update vref_value ; this step use to write vref_value.6..1 
	vref_value = vref_value >> 1;
	WRITE_REG (PHY_LANE_SEL,((UINT32)ilane*7)+1/*shift by 1*/);	
fffd2bec:	e583012c 	str	r0, [r3, #300]	; 0x12c
	WRITE_REG (VREF_TRAINING, vref_value<<4 | 0x04/*vref_output_enable*/);   
fffd2bf0:	e58321c8 	str	r2, [r3, #456]	; 0x1c8
fffd2bf4:	e12fff1e 	bx	lr
fffd2bf8:	f05f0000 	.word	0xf05f0000

fffd2bfc <TestInputMargin>:
	return (0);
}
//---------------------------------------------------------------------------------------------------------------------
static UINT32 GetNumOfLanes (void)
{ // check in MC registers if ECC is enabled, if not 2 lanes are used
	UINT32 TmpReg32 = IOR32(MC_BASE_ADDR + (93*4)); // DENALI_CTL_93_DATA
fffd2bfc:	e59f3284 	ldr	r3, [pc, #644]	; fffd2e88 <TestInputMargin+0x28c>
	UINT16 VrefDQ_mV;
	UINT8 NumOfLane = GetNumOfLanes();
	UINT32 DqMask[3] = {0,0,0};
	BOOL status = 0;

	LogMessage ("\n");
fffd2c00:	e59f0284 	ldr	r0, [pc, #644]	; fffd2e8c <TestInputMargin+0x290>
				
	return (status);
}
//---------------------------------------------------------------------------------------------------------------------
BOOL TestInputMargin (void)
{
fffd2c04:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
	UINT8 PHY_VrefDQ_Step_Qrigin[3], PHY_VrefDQ_Range_Origin[3];
	UINT16 VrefDQ_mV_Qrigin[3];
	UINT8 PHY_VrefDQ_Step, PHY_VrefDQ_Range;
	UINT16 VrefDQ_mV;
	UINT8 NumOfLane = GetNumOfLanes();
	UINT32 DqMask[3] = {0,0,0};
fffd2c08:	e3a04000 	mov	r4, #0
	return (0);
}
//---------------------------------------------------------------------------------------------------------------------
static UINT32 GetNumOfLanes (void)
{ // check in MC registers if ECC is enabled, if not 2 lanes are used
	UINT32 TmpReg32 = IOR32(MC_BASE_ADDR + (93*4)); // DENALI_CTL_93_DATA
fffd2c0c:	e5933174 	ldr	r3, [r3, #372]	; 0x174
				
	return (status);
}
//---------------------------------------------------------------------------------------------------------------------
BOOL TestInputMargin (void)
{
fffd2c10:	e24dd03c 	sub	sp, sp, #60	; 0x3c
	UINT16 VrefDQ_mV;
	UINT8 NumOfLane = GetNumOfLanes();
	UINT32 DqMask[3] = {0,0,0};
	BOOL status = 0;

	LogMessage ("\n");
fffd2c14:	e08f0000 	add	r0, pc, r0
	UINT8 PHY_VrefDQ_Step_Qrigin[3], PHY_VrefDQ_Range_Origin[3];
	UINT16 VrefDQ_mV_Qrigin[3];
	UINT8 PHY_VrefDQ_Step, PHY_VrefDQ_Range;
	UINT16 VrefDQ_mV;
	UINT8 NumOfLane = GetNumOfLanes();
	UINT32 DqMask[3] = {0,0,0};
fffd2c18:	e58d402c 	str	r4, [sp, #44]	; 0x2c
{ // check in MC registers if ECC is enabled, if not 2 lanes are used
	UINT32 TmpReg32 = IOR32(MC_BASE_ADDR + (93*4)); // DENALI_CTL_93_DATA
	if (((TmpReg32>>24)&0x01)==0)
		return (2); // ECC is not used.

	return (3); // ECC is used.
fffd2c1c:	e3130401 	tst	r3, #16777216	; 0x1000000
	UINT8 PHY_VrefDQ_Step_Qrigin[3], PHY_VrefDQ_Range_Origin[3];
	UINT16 VrefDQ_mV_Qrigin[3];
	UINT8 PHY_VrefDQ_Step, PHY_VrefDQ_Range;
	UINT16 VrefDQ_mV;
	UINT8 NumOfLane = GetNumOfLanes();
	UINT32 DqMask[3] = {0,0,0};
fffd2c20:	e58d4030 	str	r4, [sp, #48]	; 0x30
	UINT8 ilane;
	UINT8 PHY_VrefDQ_Step_Qrigin[3], PHY_VrefDQ_Range_Origin[3];
	UINT16 VrefDQ_mV_Qrigin[3];
	UINT8 PHY_VrefDQ_Step, PHY_VrefDQ_Range;
	UINT16 VrefDQ_mV;
	UINT8 NumOfLane = GetNumOfLanes();
fffd2c24:	13a07003 	movne	r7, #3
fffd2c28:	03a07002 	moveq	r7, #2
	UINT32 DqMask[3] = {0,0,0};
fffd2c2c:	e58d4034 	str	r4, [sp, #52]	; 0x34
	BOOL status = 0;

	LogMessage ("\n");
fffd2c30:	eb0006b1 	bl	fffd46fc <LogMessage>
	//--------------------------------------------------------------------------
	// Get VrefDQ default value
	LogHeader (" PHY VrefDQ: Default SetPoint");
fffd2c34:	e59f0254 	ldr	r0, [pc, #596]	; fffd2e90 <TestInputMargin+0x294>
fffd2c38:	e08f0000 	add	r0, pc, r0
fffd2c3c:	eb00070a 	bl	fffd486c <LogHeader>
fffd2c40:	e28d6020 	add	r6, sp, #32
fffd2c44:	e28d901c 	add	r9, sp, #28
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		VrefDQ_Get_PHY (ilane, &PHY_VrefDQ_Range_Origin[ilane], &PHY_VrefDQ_Step_Qrigin[ilane]);
fffd2c48:	e0892004 	add	r2, r9, r4
fffd2c4c:	e6ef0074 	uxtb	r0, r4
fffd2c50:	e0861004 	add	r1, r6, r4
fffd2c54:	ebffffcf 	bl	fffd2b98 <VrefDQ_Get_PHY>
		VrefDQ_mV_Qrigin[ilane] = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range_Origin[ilane], PHY_VrefDQ_Step_Qrigin[ilane]);
fffd2c58:	e7d45006 	ldrb	r5, [r4, r6]
fffd2c5c:	e28db024 	add	r11, sp, #36	; 0x24
fffd2c60:	e7d48009 	ldrb	r8, [r4, r9]
fffd2c64:	e1a00005 	mov	r0, r5
fffd2c68:	e1a01008 	mov	r1, r8
fffd2c6c:	ebfffb6f 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
fffd2c70:	e1a03084 	lsl	r3, r4, #1
fffd2c74:	e1a02000 	mov	r2, r0
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV_Qrigin[ilane], PHY_VrefDQ_Range_Origin[ilane]+1, PHY_VrefDQ_Step_Qrigin[ilane]);
fffd2c78:	e1a01004 	mov	r1, r4
	// Get VrefDQ default value
	LogHeader (" PHY VrefDQ: Default SetPoint");
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		VrefDQ_Get_PHY (ilane, &PHY_VrefDQ_Range_Origin[ilane], &PHY_VrefDQ_Step_Qrigin[ilane]);
		VrefDQ_mV_Qrigin[ilane] = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range_Origin[ilane], PHY_VrefDQ_Step_Qrigin[ilane]);
fffd2c7c:	e18300bb 	strh	r0, [r3, r11]
fffd2c80:	e2844001 	add	r4, r4, #1
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV_Qrigin[ilane], PHY_VrefDQ_Range_Origin[ilane]+1, PHY_VrefDQ_Step_Qrigin[ilane]);
fffd2c84:	e59f0208 	ldr	r0, [pc, #520]	; fffd2e94 <TestInputMargin+0x298>
fffd2c88:	e2853001 	add	r3, r5, #1
fffd2c8c:	e58d8000 	str	r8, [sp]
fffd2c90:	e08f0000 	add	r0, pc, r0
fffd2c94:	eb000698 	bl	fffd46fc <LogMessage>

	LogMessage ("\n");
	//--------------------------------------------------------------------------
	// Get VrefDQ default value
	LogHeader (" PHY VrefDQ: Default SetPoint");
	for (ilane=0; ilane<NumOfLane; ilane++)
fffd2c98:	e6ef3074 	uxtb	r3, r4
fffd2c9c:	e1530007 	cmp	r3, r7
fffd2ca0:	3affffe6 	bcc	fffd2c40 <TestInputMargin+0x44>
		VrefDQ_mV_Qrigin[ilane] = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range_Origin[ilane], PHY_VrefDQ_Step_Qrigin[ilane]);
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV_Qrigin[ilane], PHY_VrefDQ_Range_Origin[ilane]+1, PHY_VrefDQ_Step_Qrigin[ilane]);
	}
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQS_Offset (DqMask, 8, "@VrefDQ:default");
fffd2ca4:	e59f21ec 	ldr	r2, [pc, #492]	; fffd2e98 <TestInputMargin+0x29c>
fffd2ca8:	e28da02c 	add	r10, sp, #44	; 0x2c
fffd2cac:	e3a01008 	mov	r1, #8
fffd2cb0:	e1a0000a 	mov	r0, r10
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint+%umV ", VrefDQ_Margin);
fffd2cb4:	e3a05000 	mov	r5, #0
		VrefDQ_mV_Qrigin[ilane] = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range_Origin[ilane], PHY_VrefDQ_Step_Qrigin[ilane]);
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV_Qrigin[ilane], PHY_VrefDQ_Range_Origin[ilane]+1, PHY_VrefDQ_Step_Qrigin[ilane]);
	}
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQS_Offset (DqMask, 8, "@VrefDQ:default");
fffd2cb8:	e08f2002 	add	r2, pc, r2
fffd2cbc:	ebfff90d 	bl	fffd10f8 <Sweep_Trim_InputDQS_Offset>
fffd2cc0:	e58d000c 	str	r0, [sp, #12]
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint+%umV ", VrefDQ_Margin);
fffd2cc4:	e3a01032 	mov	r1, #50	; 0x32
fffd2cc8:	e59f01cc 	ldr	r0, [pc, #460]	; fffd2e9c <TestInputMargin+0x2a0>
fffd2ccc:	e08f0000 	add	r0, pc, r0
fffd2cd0:	eb0006e5 	bl	fffd486c <LogHeader>
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		PHY_VrefDQ_Step = 0;
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
fffd2cd4:	e7d63005 	ldrb	r3, [r6, r5]
fffd2cd8:	e28d8038 	add	r8, sp, #56	; 0x38
	status |= Sweep_Trim_InputDQS_Offset (DqMask, 8, "@VrefDQ:default");
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint+%umV ", VrefDQ_Margin);
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		PHY_VrefDQ_Step = 0;
fffd2cdc:	e3a04000 	mov	r4, #0
fffd2ce0:	e5cd401a 	strb	r4, [sp, #26]
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
fffd2ce4:	e568301d 	strb	r3, [r8, #-29]!
fffd2ce8:	e1a03085 	lsl	r3, r5, #1
		VrefDQ_mV = VrefDQ_mV_Qrigin[ilane] + VrefDQ_Margin;
		VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &PHY_VrefDQ_Range, &PHY_VrefDQ_Step); // look for best range/step that meet mV. Try first with current range. 
fffd2cec:	e1a01008 	mov	r1, r8
	LogHeader (" Set PHY VrefDQ: SetPoint+%umV ", VrefDQ_Margin);
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		PHY_VrefDQ_Step = 0;
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
		VrefDQ_mV = VrefDQ_mV_Qrigin[ilane] + VrefDQ_Margin;
fffd2cf0:	e19b00b3 	ldrh	r0, [r11, r3]
		VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &PHY_VrefDQ_Range, &PHY_VrefDQ_Step); // look for best range/step that meet mV. Try first with current range. 
fffd2cf4:	e28d301a 	add	r3, sp, #26
fffd2cf8:	e1a02003 	mov	r2, r3
fffd2cfc:	e58d3008 	str	r3, [sp, #8]
	LogHeader (" Set PHY VrefDQ: SetPoint+%umV ", VrefDQ_Margin);
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		PHY_VrefDQ_Step = 0;
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
		VrefDQ_mV = VrefDQ_mV_Qrigin[ilane] + VrefDQ_Margin;
fffd2d00:	e2800032 	add	r0, r0, #50	; 0x32
		VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &PHY_VrefDQ_Range, &PHY_VrefDQ_Step); // look for best range/step that meet mV. Try first with current range. 
fffd2d04:	e6ff0070 	uxth	r0, r0
fffd2d08:	ebfffefa 	bl	fffd28f8 <VrefDQ_Convert_mV_to_Step_Range>
		VrefDQ_mV = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range, PHY_VrefDQ_Step);
fffd2d0c:	e5dd301b 	ldrb	r3, [sp, #27]
fffd2d10:	e5dd201a 	ldrb	r2, [sp, #26]
fffd2d14:	e1a00003 	mov	r0, r3
fffd2d18:	e58d3014 	str	r3, [sp, #20]
fffd2d1c:	e1a01002 	mov	r1, r2
fffd2d20:	e58d2010 	str	r2, [sp, #16]
fffd2d24:	ebfffb41 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
fffd2d28:	e59d2010 	ldr	r2, [sp, #16]
	{
		PHY_VrefDQ_Step = 0;
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
		VrefDQ_mV = VrefDQ_mV_Qrigin[ilane] + VrefDQ_Margin;
		VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &PHY_VrefDQ_Range, &PHY_VrefDQ_Step); // look for best range/step that meet mV. Try first with current range. 
		VrefDQ_mV = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range, PHY_VrefDQ_Step);
fffd2d2c:	e1a0e000 	mov	lr, r0
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
fffd2d30:	e59d3014 	ldr	r3, [sp, #20]
fffd2d34:	e1a01005 	mov	r1, r5
fffd2d38:	e59f0160 	ldr	r0, [pc, #352]	; fffd2ea0 <TestInputMargin+0x2a4>
fffd2d3c:	e58d2000 	str	r2, [sp]
fffd2d40:	e1a0200e 	mov	r2, lr
fffd2d44:	e2833001 	add	r3, r3, #1
fffd2d48:	e08f0000 	add	r0, pc, r0
fffd2d4c:	eb00066a 	bl	fffd46fc <LogMessage>
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range, PHY_VrefDQ_Step); // Set new VrefDQ values 
fffd2d50:	e6ef0075 	uxtb	r0, r5
fffd2d54:	e5dd101b 	ldrb	r1, [sp, #27]
fffd2d58:	e5dd201a 	ldrb	r2, [sp, #26]
fffd2d5c:	e2855001 	add	r5, r5, #1
fffd2d60:	ebffff96 	bl	fffd2bc0 <VrefDQ_Set_PHY>
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQS_Offset (DqMask, 8, "@VrefDQ:default");
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint+%umV ", VrefDQ_Margin);
	for (ilane=0; ilane<NumOfLane; ilane++)
fffd2d64:	e6ef3075 	uxtb	r3, r5
fffd2d68:	e1530007 	cmp	r3, r7
fffd2d6c:	3affffd8 	bcc	fffd2cd4 <TestInputMargin+0xd8>
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range, PHY_VrefDQ_Step); // Set new VrefDQ values 
	}
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
fffd2d70:	e59f212c 	ldr	r2, [pc, #300]	; fffd2ea4 <TestInputMargin+0x2a8>
fffd2d74:	e3a01003 	mov	r1, #3
fffd2d78:	e1a0000a 	mov	r0, r10
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint-%umV", VrefDQ_Margin);
fffd2d7c:	e1a05004 	mov	r5, r4
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range, PHY_VrefDQ_Step); // Set new VrefDQ values 
	}
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
fffd2d80:	e08f2002 	add	r2, pc, r2
fffd2d84:	ebfff7ef 	bl	fffd0d48 <Sweep_Trim_InputDQ_Offset>
fffd2d88:	e59d300c 	ldr	r3, [sp, #12]
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint-%umV", VrefDQ_Margin);
fffd2d8c:	e3a01032 	mov	r1, #50	; 0x32
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range, PHY_VrefDQ_Step); // Set new VrefDQ values 
	}
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
fffd2d90:	e1803003 	orr	r3, r0, r3
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint-%umV", VrefDQ_Margin);
fffd2d94:	e59f010c 	ldr	r0, [pc, #268]	; fffd2ea8 <TestInputMargin+0x2ac>
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range, PHY_VrefDQ_Step); // Set new VrefDQ values 
	}
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
fffd2d98:	e58d300c 	str	r3, [sp, #12]
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint-%umV", VrefDQ_Margin);
fffd2d9c:	e08f0000 	add	r0, pc, r0
fffd2da0:	eb0006b1 	bl	fffd486c <LogHeader>
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		PHY_VrefDQ_Step = 0;
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
fffd2da4:	e7d63005 	ldrb	r3, [r6, r5]
		VrefDQ_mV = VrefDQ_mV_Qrigin[ilane] - VrefDQ_Margin; 
		VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &PHY_VrefDQ_Range, &PHY_VrefDQ_Step); // look for best range/step that meet mV. Try first with current range. 
fffd2da8:	e1a01008 	mov	r1, r8
fffd2dac:	e59d2008 	ldr	r2, [sp, #8]
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint-%umV", VrefDQ_Margin);
	for (ilane=0; ilane<NumOfLane; ilane++)
	{
		PHY_VrefDQ_Step = 0;
fffd2db0:	e3a04000 	mov	r4, #0
fffd2db4:	e5cd401a 	strb	r4, [sp, #26]
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
fffd2db8:	e5cd301b 	strb	r3, [sp, #27]
fffd2dbc:	e1a03085 	lsl	r3, r5, #1
		VrefDQ_mV = VrefDQ_mV_Qrigin[ilane] - VrefDQ_Margin; 
fffd2dc0:	e19b00b3 	ldrh	r0, [r11, r3]
fffd2dc4:	e2400032 	sub	r0, r0, #50	; 0x32
		VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &PHY_VrefDQ_Range, &PHY_VrefDQ_Step); // look for best range/step that meet mV. Try first with current range. 
fffd2dc8:	e6ff0070 	uxth	r0, r0
fffd2dcc:	ebfffec9 	bl	fffd28f8 <VrefDQ_Convert_mV_to_Step_Range>
		VrefDQ_mV = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range, PHY_VrefDQ_Step);
fffd2dd0:	e5dd301b 	ldrb	r3, [sp, #27]
fffd2dd4:	e5dd201a 	ldrb	r2, [sp, #26]
fffd2dd8:	e1a00003 	mov	r0, r3
fffd2ddc:	e58d3014 	str	r3, [sp, #20]
fffd2de0:	e1a01002 	mov	r1, r2
fffd2de4:	e58d2010 	str	r2, [sp, #16]
fffd2de8:	ebfffb10 	bl	fffd1a30 <VrefDQ_Convert_Step_to_mV>
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
fffd2dec:	e59d2010 	ldr	r2, [sp, #16]
	{
		PHY_VrefDQ_Step = 0;
		PHY_VrefDQ_Range = PHY_VrefDQ_Range_Origin[ilane];
		VrefDQ_mV = VrefDQ_mV_Qrigin[ilane] - VrefDQ_Margin; 
		VrefDQ_Convert_mV_to_Step_Range (VrefDQ_mV, &PHY_VrefDQ_Range, &PHY_VrefDQ_Step); // look for best range/step that meet mV. Try first with current range. 
		VrefDQ_mV = VrefDQ_Convert_Step_to_mV(PHY_VrefDQ_Range, PHY_VrefDQ_Step);
fffd2df0:	e1a0e000 	mov	lr, r0
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
fffd2df4:	e59d3014 	ldr	r3, [sp, #20]
fffd2df8:	e1a01005 	mov	r1, r5
fffd2dfc:	e59f00a8 	ldr	r0, [pc, #168]	; fffd2eac <TestInputMargin+0x2b0>
fffd2e00:	e58d2000 	str	r2, [sp]
fffd2e04:	e1a0200e 	mov	r2, lr
fffd2e08:	e2833001 	add	r3, r3, #1
fffd2e0c:	e08f0000 	add	r0, pc, r0
fffd2e10:	eb000639 	bl	fffd46fc <LogMessage>
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range, PHY_VrefDQ_Step); // Set new VrefDQ values 
fffd2e14:	e6ef0075 	uxtb	r0, r5
fffd2e18:	e5dd101b 	ldrb	r1, [sp, #27]
fffd2e1c:	e5dd201a 	ldrb	r2, [sp, #26]
fffd2e20:	e2855001 	add	r5, r5, #1
fffd2e24:	ebffff65 	bl	fffd2bc0 <VrefDQ_Set_PHY>
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:+dV");
	//--------------------------------------------------------------------------
	LogHeader (" Set PHY VrefDQ: SetPoint-%umV", VrefDQ_Margin);
	for (ilane=0; ilane<NumOfLane; ilane++)
fffd2e28:	e6ef3075 	uxtb	r3, r5
fffd2e2c:	e1530007 	cmp	r3, r7
fffd2e30:	3affffdb 	bcc	fffd2da4 <TestInputMargin+0x1a8>
		LogMessage ("> Lane%u: %u mv (range: %u, step %u)\n", ilane, VrefDQ_mV, PHY_VrefDQ_Range+1, PHY_VrefDQ_Step);
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range, PHY_VrefDQ_Step); // Set new VrefDQ values 
	}
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:-dV");
fffd2e34:	e59f2074 	ldr	r2, [pc, #116]	; fffd2eb0 <TestInputMargin+0x2b4>
fffd2e38:	e1a0000a 	mov	r0, r10
fffd2e3c:	e3a01003 	mov	r1, #3
fffd2e40:	e08f2002 	add	r2, pc, r2
fffd2e44:	ebfff7bf 	bl	fffd0d48 <Sweep_Trim_InputDQ_Offset>
fffd2e48:	e59d300c 	ldr	r3, [sp, #12]
fffd2e4c:	e1835000 	orr	r5, r3, r0
	//--------------------------------------------------------------------------
	// restore trim values 
	for (ilane=0; ilane<NumOfLane; ilane++)
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range_Origin[ilane], PHY_VrefDQ_Step_Qrigin[ilane]); // Set new VrefDQ values 
fffd2e50:	e6ef0074 	uxtb	r0, r4
fffd2e54:	e7d61004 	ldrb	r1, [r6, r4]
fffd2e58:	e7d92004 	ldrb	r2, [r9, r4]
fffd2e5c:	e2844001 	add	r4, r4, #1
fffd2e60:	ebffff56 	bl	fffd2bc0 <VrefDQ_Set_PHY>
	//--------------------------------------------------------------------------
	// Sweep input parameters
	status |= Sweep_Trim_InputDQ_Offset (DqMask, TimeDQ_Margin, "@VrefDQ:-dV");
	//--------------------------------------------------------------------------
	// restore trim values 
	for (ilane=0; ilane<NumOfLane; ilane++)
fffd2e64:	e6ef3074 	uxtb	r3, r4
fffd2e68:	e1530007 	cmp	r3, r7
fffd2e6c:	3afffff7 	bcc	fffd2e50 <TestInputMargin+0x254>
		VrefDQ_Set_PHY (ilane, PHY_VrefDQ_Range_Origin[ilane], PHY_VrefDQ_Step_Qrigin[ilane]); // Set new VrefDQ values 
	//--------------------------------------------------------------------------
	
	LogMessage ("\n");
fffd2e70:	e59f003c 	ldr	r0, [pc, #60]	; fffd2eb4 <TestInputMargin+0x2b8>
fffd2e74:	e08f0000 	add	r0, pc, r0
fffd2e78:	eb00061f 	bl	fffd46fc <LogMessage>

	return (status);
}	
fffd2e7c:	e1a00005 	mov	r0, r5
fffd2e80:	e28dd03c 	add	sp, sp, #60	; 0x3c
fffd2e84:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
fffd2e88:	f0824000 	.word	0xf0824000
fffd2e8c:	000030b8 	.word	0x000030b8
fffd2e90:	00003d94 	.word	0x00003d94
fffd2e94:	00003d5a 	.word	0x00003d5a
fffd2e98:	00003d58 	.word	0x00003d58
fffd2e9c:	00003d54 	.word	0x00003d54
fffd2ea0:	00003ca2 	.word	0x00003ca2
fffd2ea4:	00003c14 	.word	0x00003c14
fffd2ea8:	00003ca4 	.word	0x00003ca4
fffd2eac:	00003bde 	.word	0x00003bde
fffd2eb0:	00003b80 	.word	0x00003b80
fffd2eb4:	00002e58 	.word	0x00002e58

fffd2eb8 <MainMenu>:
const char g_Text_InvalidFormat [] = {"--- Invalid format or value, retry.\n"};
//---------------------------------------------------------------------------------------------------------------------
extern int MainMenu (void)
{
	int status = 0;
	LogMessage ("\n");
fffd2eb8:	e59f017c 	ldr	r0, [pc, #380]	; fffd303c <MainMenu+0x184>
//------------------------------------------------------------------------------
const char g_Text_AbortedByUser [] = {"\n --- aborted by user.\n"};
const char g_Text_InvalidFormat [] = {"--- Invalid format or value, retry.\n"};
//---------------------------------------------------------------------------------------------------------------------
extern int MainMenu (void)
{
fffd2ebc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	int status = 0;
	LogMessage ("\n");

	if ( (READ_BIT_REG(INTCR2,19)==0) || (READ_BIT_REG(IPSRST1,12)==1) )
fffd2ec0:	e59f8178 	ldr	r8, [pc, #376]	; fffd3040 <MainMenu+0x188>
const char g_Text_InvalidFormat [] = {"--- Invalid format or value, retry.\n"};
//---------------------------------------------------------------------------------------------------------------------
extern int MainMenu (void)
{
	int status = 0;
	LogMessage ("\n");
fffd2ec4:	e08f0000 	add	r0, pc, r0
fffd2ec8:	eb00060b 	bl	fffd46fc <LogMessage>

	if ( (READ_BIT_REG(INTCR2,19)==0) || (READ_BIT_REG(IPSRST1,12)==1) )
fffd2ecc:	e5983060 	ldr	r3, [r8, #96]	; 0x60
//------------------------------------------------------------------------------
const char g_Text_AbortedByUser [] = {"\n --- aborted by user.\n"};
const char g_Text_InvalidFormat [] = {"--- Invalid format or value, retry.\n"};
//---------------------------------------------------------------------------------------------------------------------
extern int MainMenu (void)
{
fffd2ed0:	e59f616c 	ldr	r6, [pc, #364]	; fffd3044 <MainMenu+0x18c>
	int status = 0;
	LogMessage ("\n");

	if ( (READ_BIT_REG(INTCR2,19)==0) || (READ_BIT_REG(IPSRST1,12)==1) )
fffd2ed4:	e3130702 	tst	r3, #524288	; 0x80000
//------------------------------------------------------------------------------
const char g_Text_AbortedByUser [] = {"\n --- aborted by user.\n"};
const char g_Text_InvalidFormat [] = {"--- Invalid format or value, retry.\n"};
//---------------------------------------------------------------------------------------------------------------------
extern int MainMenu (void)
{
fffd2ed8:	e08f6006 	add	r6, pc, r6
	int status = 0;
	LogMessage ("\n");

	if ( (READ_BIT_REG(INTCR2,19)==0) || (READ_BIT_REG(IPSRST1,12)==1) )
fffd2edc:	0a000004 	beq	fffd2ef4 <MainMenu+0x3c>
fffd2ee0:	e59f3160 	ldr	r3, [pc, #352]	; fffd3048 <MainMenu+0x190>
fffd2ee4:	e5934020 	ldr	r4, [r3, #32]
fffd2ee8:	e7e04654 	ubfx	r4, r4, #12, #1
fffd2eec:	e3540000 	cmp	r4, #0
fffd2ef0:	0a000002 	beq	fffd2f00 <MainMenu+0x48>
	{
		LogError ("\n ***** Error: Memory Controller was not initialized ****** \n");
fffd2ef4:	e59f0150 	ldr	r0, [pc, #336]	; fffd304c <MainMenu+0x194>
fffd2ef8:	e08f0000 	add	r0, pc, r0
fffd2efc:	ea00001d 	b	fffd2f78 <MainMenu+0xc0>
		return (1);
	}

	RelocateTlbs(0); //  If MMU is enabled, relocate TLBs to SRAM	
fffd2f00:	e1a00004 	mov	r0, r4
fffd2f04:	ebfff6f9 	bl	fffd0af0 <RelocateTlbs>

	status |= DisplayInfo();
fffd2f08:	ebfffad8 	bl	fffd1a70 <DisplayInfo>
fffd2f0c:	e1a05000 	mov	r5, r0

	LogWarning ("\nNOTE:\n");
fffd2f10:	e59f0138 	ldr	r0, [pc, #312]	; fffd3050 <MainMenu+0x198>
fffd2f14:	e08f0000 	add	r0, pc, r0
fffd2f18:	eb000633 	bl	fffd47ec <LogWarning>
	LogWarning ("* DDR4 memory is not valid while sweeping, in case host use BMC graphics, it may stuck. \n");
fffd2f1c:	e59f0130 	ldr	r0, [pc, #304]	; fffd3054 <MainMenu+0x19c>
fffd2f20:	e08f0000 	add	r0, pc, r0
fffd2f24:	eb000630 	bl	fffd47ec <LogWarning>
	LogWarning ("* Press 'ESC' to abort the sweep. \n");
fffd2f28:	e59f0128 	ldr	r0, [pc, #296]	; fffd3058 <MainMenu+0x1a0>
fffd2f2c:	e08f0000 	add	r0, pc, r0
fffd2f30:	eb00062d 	bl	fffd47ec <LogWarning>
		WRITE_REG (HW_DWORD(0xF001000C), 0);

	}
	*/

	WRITE_REG (SCRPAD,(UINT32)(&CPU1_Toggle));
fffd2f34:	e59f3120 	ldr	r3, [pc, #288]	; fffd305c <MainMenu+0x1a4>
fffd2f38:	e7963003 	ldr	r3, [r6, r3]
fffd2f3c:	e588313c 	str	r3, [r8, #316]	; 0x13c
	CPU1_Cmd = 0; 
fffd2f40:	e59f3118 	ldr	r3, [pc, #280]	; fffd3060 <MainMenu+0x1a8>
fffd2f44:	e7963003 	ldr	r3, [r6, r3]
fffd2f48:	e5834000 	str	r4, [r3]
	CPU1_Rev = 0;
fffd2f4c:	e59f3110 	ldr	r3, [pc, #272]	; fffd3064 <MainMenu+0x1ac>
fffd2f50:	e7966003 	ldr	r6, [r6, r3]
fffd2f54:	e5864000 	str	r4, [r6]
	__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
fffd2f58:	e320f004 	sev
	Sleep (1000);
fffd2f5c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
fffd2f60:	eb0006d6 	bl	fffd4ac0 <Sleep>
	if (CPU1_Rev == 0)
fffd2f64:	e5963000 	ldr	r3, [r6]
fffd2f68:	e3530000 	cmp	r3, #0
fffd2f6c:	1a000004 	bne	fffd2f84 <MainMenu+0xcc>
	{
		LogError ("\n ***** Error: CPU1 may already running. Issue hardware reset before running this test !!! ***** \n");
fffd2f70:	e59f00f0 	ldr	r0, [pc, #240]	; fffd3068 <MainMenu+0x1b0>
fffd2f74:	e08f0000 	add	r0, pc, r0
fffd2f78:	eb00060b 	bl	fffd47ac <LogError>
		return (1);
fffd2f7c:	e3a00001 	mov	r0, #1
fffd2f80:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	}
	//LogMessage ("> CPU1 run toggle test (jump to address 0x%08lx, Rev 0x%08lx). \n", READ_REG(SCRPAD), CPU1_Rev);


	UINT32 TmpDsclCnt = 0;
	TmpDsclCnt = READ_REG(DSCL_CNT);
fffd2f84:	e59f40e0 	ldr	r4, [pc, #224]	; fffd306c <MainMenu+0x1b4>
fffd2f88:	e1a07008 	mov	r7, r8
fffd2f8c:	e594819c 	ldr	r8, [r4, #412]	; 0x19c
	if (((TmpDsclCnt>>24)&0x01)==0x01)
fffd2f90:	e3180401 	tst	r8, #16777216	; 0x1000000
fffd2f94:	0a000004 	beq	fffd2fac <MainMenu+0xf4>
	{
		LogWarning ("> Disable DSCL before sweeping.\n");
fffd2f98:	e59f00d0 	ldr	r0, [pc, #208]	; fffd3070 <MainMenu+0x1b8>
fffd2f9c:	e08f0000 	add	r0, pc, r0
fffd2fa0:	eb000611 	bl	fffd47ec <LogWarning>
		WRITE_REG (DSCL_CNT,TmpDsclCnt & (~((UINT32)1<<24)));
fffd2fa4:	e3c83401 	bic	r3, r8, #16777216	; 0x1000000
fffd2fa8:	e584319c 	str	r3, [r4, #412]	; 0x19c
	}

	status |= TestInputMargin();
fffd2fac:	ebffff12 	bl	fffd2bfc <TestInputMargin>
fffd2fb0:	e1a06000 	mov	r6, r0
	status |= TestOutputMargin();
fffd2fb4:	ebfffe8d 	bl	fffd29f0 <TestOutputMargin>
fffd2fb8:	e1860000 	orr	r0, r6, r0

	if (status == 0)
fffd2fbc:	e1905005 	orrs	r5, r0, r5
fffd2fc0:	1a000009 	bne	fffd2fec <MainMenu+0x134>
	{
		LogPass (" ****************************\n");
fffd2fc4:	e59f60a8 	ldr	r6, [pc, #168]	; fffd3074 <MainMenu+0x1bc>
fffd2fc8:	e08f6006 	add	r6, pc, r6
fffd2fcc:	e1a00006 	mov	r0, r6
fffd2fd0:	eb000615 	bl	fffd482c <LogPass>
		LogPass (" *** Test Completed: PASS ***\n");
fffd2fd4:	e59f009c 	ldr	r0, [pc, #156]	; fffd3078 <MainMenu+0x1c0>
fffd2fd8:	e08f0000 	add	r0, pc, r0
fffd2fdc:	eb000612 	bl	fffd482c <LogPass>
		LogPass (" ****************************\n");
fffd2fe0:	e1a00006 	mov	r0, r6
fffd2fe4:	eb000610 	bl	fffd482c <LogPass>
fffd2fe8:	ea000008 	b	fffd3010 <MainMenu+0x158>
	}
	else
	{
		LogError (" ****************************\n");
fffd2fec:	e59f6088 	ldr	r6, [pc, #136]	; fffd307c <MainMenu+0x1c4>
fffd2ff0:	e08f6006 	add	r6, pc, r6
fffd2ff4:	e1a00006 	mov	r0, r6
fffd2ff8:	eb0005eb 	bl	fffd47ac <LogError>
		LogError (" *** Test Completed: FAIL ***\n");
fffd2ffc:	e59f007c 	ldr	r0, [pc, #124]	; fffd3080 <MainMenu+0x1c8>
fffd3000:	e08f0000 	add	r0, pc, r0
fffd3004:	eb0005e8 	bl	fffd47ac <LogError>
		LogError (" ****************************\n");
fffd3008:	e1a00006 	mov	r0, r6
fffd300c:	eb0005e6 	bl	fffd47ac <LogError>
	}
	

	// restore DSCL to default 
	WRITE_REG (DSCL_CNT,TmpDsclCnt); 
fffd3010:	e584819c 	str	r8, [r4, #412]	; 0x19c

	// JumpToUboot ();
	
	RelocateTlbs(1); // if MMU is enabled, return TLBs to DDR
fffd3014:	e3a00001 	mov	r0, #1
fffd3018:	ebfff6b4 	bl	fffd0af0 <RelocateTlbs>

	// 15/09/2015: add RAM-V and vector table return to normal
	UINT32 SCTLR_reg;
	CLEAR_BIT_REG (FLOCKR1,18); // disable RAM2 first 256 bytes mapping (TBD: I assume boot-block always disable it so UBOOT expected this to be disabled)
fffd301c:	e5973074 	ldr	r3, [r7, #116]	; 0x74
fffd3020:	e3c33701 	bic	r3, r3, #262144	; 0x40000
fffd3024:	e5873074 	str	r3, [r7, #116]	; 0x74
	CP15_READ (SCTLR_reg, 0, c1, c0, 0);
fffd3028:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
	SCTLR_reg &= ~((UINT32)1<<13); // set vector table into address 0x0000_0000 (TBD: I assume boot-block always set vector table to 0x0000_0000 so UBOOT expected this)
fffd302c:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
	CP15_WRITE (SCTLR_reg, 0, c1, c0, 0);
fffd3030:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
		LogWarning ("> Disable DSCL before sweeping.\n");
		WRITE_REG (DSCL_CNT,TmpDsclCnt & (~((UINT32)1<<24)));
	}

	status |= TestInputMargin();
	status |= TestOutputMargin();
fffd3034:	e1a00005 	mov	r0, r5
	CP15_READ (SCTLR_reg, 0, c1, c0, 0);
	SCTLR_reg &= ~((UINT32)1<<13); // set vector table into address 0x0000_0000 (TBD: I assume boot-block always set vector table to 0x0000_0000 so UBOOT expected this)
	CP15_WRITE (SCTLR_reg, 0, c1, c0, 0);
				
	return (status);
}
fffd3038:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
fffd303c:	00002e08 	.word	0x00002e08
fffd3040:	f0800000 	.word	0xf0800000
fffd3044:	000043a0 	.word	0x000043a0
fffd3048:	f0801000 	.word	0xf0801000
fffd304c:	00003b67 	.word	0x00003b67
fffd3050:	00003b89 	.word	0x00003b89
fffd3054:	00003b85 	.word	0x00003b85
fffd3058:	00003bd3 	.word	0x00003bd3
fffd305c:	00000004 	.word	0x00000004
fffd3060:	00000050 	.word	0x00000050
fffd3064:	00000008 	.word	0x00000008
fffd3068:	00003baf 	.word	0x00003baf
fffd306c:	f05f0000 	.word	0xf05f0000
fffd3070:	00003bea 	.word	0x00003bea
fffd3074:	00003bdf 	.word	0x00003bdf
fffd3078:	00003bee 	.word	0x00003bee
fffd307c:	00003bb7 	.word	0x00003bb7
fffd3080:	00003be5 	.word	0x00003be5

fffd3084 <MemoryCompare>:
//--------------------------------------------------------------------------------------------------------
extern UINT16 MemoryCompare (const UINT16 *ptr1, const UINT16 *ptr2, UINT32 SizeInWord)
{
	UINT16 result;
	result = 0;
	while ( (SizeInWord!=0) && (result!=0xFFFF) )
fffd3084:	e3520000 	cmp	r2, #0
fffd3088:	0a000011 	beq	fffd30d4 <MemoryCompare+0x50>
}
//-------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------
extern UINT16 MemoryCompare (const UINT16 *ptr1, const UINT16 *ptr2, UINT32 SizeInWord)
{
fffd308c:	e92d4030 	push	{r4, r5, lr}
fffd3090:	e240e002 	sub	lr, r0, #2
	UINT16 result;
	result = 0;
	while ( (SizeInWord!=0) && (result!=0xFFFF) )
fffd3094:	e30f5fff 	movw	r5, #65535	; 0xffff
fffd3098:	e3a00000 	mov	r0, #0
fffd309c:	e2522001 	subs	r2, r2, #1
	{
		SizeInWord--;
		result |= *ptr1 ^ *ptr2;
fffd30a0:	e0d140b2 	ldrh	r4, [r1], #2
//--------------------------------------------------------------------------------------------------------
extern UINT16 MemoryCompare (const UINT16 *ptr1, const UINT16 *ptr2, UINT32 SizeInWord)
{
	UINT16 result;
	result = 0;
	while ( (SizeInWord!=0) && (result!=0xFFFF) )
fffd30a4:	13a03001 	movne	r3, #1
	{
		SizeInWord--;
		result |= *ptr1 ^ *ptr2;
fffd30a8:	e1fec0b2 	ldrh	r12, [lr, #2]!
//--------------------------------------------------------------------------------------------------------
extern UINT16 MemoryCompare (const UINT16 *ptr1, const UINT16 *ptr2, UINT32 SizeInWord)
{
	UINT16 result;
	result = 0;
	while ( (SizeInWord!=0) && (result!=0xFFFF) )
fffd30ac:	03a03000 	moveq	r3, #0
	{
		SizeInWord--;
		result |= *ptr1 ^ *ptr2;
fffd30b0:	e02cc004 	eor	r12, r12, r4
fffd30b4:	e180000c 	orr	r0, r0, r12
fffd30b8:	e6ff0070 	uxth	r0, r0
//--------------------------------------------------------------------------------------------------------
extern UINT16 MemoryCompare (const UINT16 *ptr1, const UINT16 *ptr2, UINT32 SizeInWord)
{
	UINT16 result;
	result = 0;
	while ( (SizeInWord!=0) && (result!=0xFFFF) )
fffd30bc:	e1500005 	cmp	r0, r5
fffd30c0:	03a03000 	moveq	r3, #0
fffd30c4:	12033001 	andne	r3, r3, #1
fffd30c8:	e3530000 	cmp	r3, #0
fffd30cc:	1afffff2 	bne	fffd309c <MemoryCompare+0x18>
fffd30d0:	e8bd8030 	pop	{r4, r5, pc}

//--------------------------------------------------------------------------------------------------------
extern UINT16 MemoryCompare (const UINT16 *ptr1, const UINT16 *ptr2, UINT32 SizeInWord)
{
	UINT16 result;
	result = 0;
fffd30d4:	e1a00002 	mov	r0, r2
fffd30d8:	e12fff1e 	bx	lr

fffd30dc <MemStressTest>:
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd30dc:	e59f1fa4 	ldr	r1, [pc, #4004]	; fffd4088 <MemStressTest+0xfac>
extern UINT16 MemStressTest (void)
{
	UINT16 status;
	
	g_SkipDataAbort = TRUE;
	srand(0);
fffd30e0:	e3a00000 	mov	r0, #0
}
//-------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------
extern UINT16 MemStressTest (void)
{
fffd30e4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
fffd30e8:	e24dd04c 	sub	sp, sp, #76	; 0x4c
fffd30ec:	e59f4f98 	ldr	r4, [pc, #3992]	; fffd408c <MemStressTest+0xfb0>
	UINT16 status;
	
	g_SkipDataAbort = TRUE;
fffd30f0:	e3a02001 	mov	r2, #1
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd30f4:	e08f1001 	add	r1, pc, r1
fffd30f8:	e58d103c 	str	r1, [sp, #60]	; 0x3c
fffd30fc:	e59fcf8c 	ldr	r12, [pc, #3980]	; fffd4090 <MemStressTest+0xfb4>
}
//-------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------
extern UINT16 MemStressTest (void)
{
fffd3100:	e08f4004 	add	r4, pc, r4
		else if ((l_NumOfLoops&7) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3104:	e59f1f88 	ldr	r1, [pc, #3976]	; fffd4094 <MemStressTest+0xfb8>
//---------------------------------------------------------------------------------
extern UINT16 MemStressTest (void)
{
	UINT16 status;
	
	g_SkipDataAbort = TRUE;
fffd3108:	e59f3f88 	ldr	r3, [pc, #3976]	; fffd4098 <MemStressTest+0xfbc>
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd310c:	e08fc00c 	add	r12, pc, r12
//-------------------------------------------------------------------------------------------------
// This memory test use address/data pairs. 
static UINT16 Run_MemTest_Type5_dword (UINT32 NumOfLoops, BYTE IsSilent)
{
	UINT32 l_NumOfLoops = 0; 
	UINT16 result_16=0,temp_result_16;
fffd3110:	e58d0020 	str	r0, [sp, #32]
		else if ((l_NumOfLoops&7) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3114:	e08f1001 	add	r1, pc, r1

//-------------------------------------------------------------------------------------------------
// This memory test use address/data pairs. 
static UINT16 Run_MemTest_Type5_dword (UINT32 NumOfLoops, BYTE IsSilent)
{
	UINT32 l_NumOfLoops = 0; 
fffd3118:	e58d001c 	str	r0, [sp, #28]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd311c:	e58dc038 	str	r12, [sp, #56]	; 0x38
//---------------------------------------------------------------------------------
extern UINT16 MemStressTest (void)
{
	UINT16 status;
	
	g_SkipDataAbort = TRUE;
fffd3120:	e7943003 	ldr	r3, [r4, r3]
		else if ((l_NumOfLoops&7) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3124:	e58d1008 	str	r1, [sp, #8]
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3128:	e59f1f6c 	ldr	r1, [pc, #3948]	; fffd409c <MemStressTest+0xfc0>
//---------------------------------------------------------------------------------
extern UINT16 MemStressTest (void)
{
	UINT16 status;
	
	g_SkipDataAbort = TRUE;
fffd312c:	e5832000 	str	r2, [r3]
fffd3130:	e58d3034 	str	r3, [sp, #52]	; 0x34
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3134:	e08f1001 	add	r1, pc, r1
fffd3138:	e1a05001 	mov	r5, r1
extern UINT16 MemStressTest (void)
{
	UINT16 status;
	
	g_SkipDataAbort = TRUE;
	srand(0);
fffd313c:	eb0006a0 	bl	fffd4bc4 <srand>
fffd3140:	e59f0f58 	ldr	r0, [pc, #3928]	; fffd40a0 <MemStressTest+0xfc4>
fffd3144:	e59f2f58 	ldr	r2, [pc, #3928]	; fffd40a4 <MemStressTest+0xfc8>
fffd3148:	e59f1f58 	ldr	r1, [pc, #3928]	; fffd40a8 <MemStressTest+0xfcc>
fffd314c:	e7940000 	ldr	r0, [r4, r0]
fffd3150:	e59f3f54 	ldr	r3, [pc, #3924]	; fffd40ac <MemStressTest+0xfd0>
fffd3154:	e58d0004 	str	r0, [sp, #4]
fffd3158:	e7942002 	ldr	r2, [r4, r2]
fffd315c:	e794b001 	ldr	r11, [r4, r1]
fffd3160:	e58d2010 	str	r2, [sp, #16]
fffd3164:	e7943003 	ldr	r3, [r4, r3]
fffd3168:	e1a04000 	mov	r4, r0
fffd316c:	e58d3018 	str	r3, [sp, #24]
		}
		*/

		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&7) == 0)
fffd3170:	e59d301c 	ldr	r3, [sp, #28]
fffd3174:	e213a007 	ands	r10, r3, #7
fffd3178:	1a000154 	bne	fffd36d0 <MemStressTest+0x5f4>
fffd317c:	e1a03005 	mov	r3, r5
fffd3180:	e1a08004 	mov	r8, r4
fffd3184:	e58d400c 	str	r4, [sp, #12]
fffd3188:	e1a0500a 	mov	r5, r10
fffd318c:	e1a0400a 	mov	r4, r10
fffd3190:	e1a0900b 	mov	r9, r11
fffd3194:	e1a0a003 	mov	r10, r3
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3198:	eb000674 	bl	fffd4b70 <rand_8bit>
fffd319c:	e59d300c 	ldr	r3, [sp, #12]
fffd31a0:	e2847601 	add	r7, r4, #1048576	; 0x100000
fffd31a4:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd31a8:	e2656078 	rsb	r6, r5, #120	; 0x78
fffd31ac:	f5d8f028 	pld	[r8, #40]	; 0x28
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd31b0:	e2844020 	add	r4, r4, #32
fffd31b4:	f5d9f028 	pld	[r9, #40]	; 0x28
fffd31b8:	e2888020 	add	r8, r8, #32
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd31bc:	e7832105 	str	r2, [r3, r5, lsl #2]
fffd31c0:	e2899020 	add	r9, r9, #32
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd31c4:	e78b7105 	str	r7, [r11, r5, lsl #2]
fffd31c8:	e2855008 	add	r5, r5, #8
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd31cc:	eb000667 	bl	fffd4b70 <rand_8bit>
fffd31d0:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd31d4:	e2871004 	add	r1, r7, #4
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd31d8:	e509101c 	str	r1, [r9, #-28]
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd31dc:	e508201c 	str	r2, [r8, #-28]
fffd31e0:	eb000662 	bl	fffd4b70 <rand_8bit>
fffd31e4:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd31e8:	e2871008 	add	r1, r7, #8
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd31ec:	e5091018 	str	r1, [r9, #-24]
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd31f0:	e5082018 	str	r2, [r8, #-24]
fffd31f4:	eb00065d 	bl	fffd4b70 <rand_8bit>
fffd31f8:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd31fc:	e287100c 	add	r1, r7, #12
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd3200:	e5091014 	str	r1, [r9, #-20]
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3204:	e5082014 	str	r2, [r8, #-20]
fffd3208:	eb000658 	bl	fffd4b70 <rand_8bit>
fffd320c:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd3210:	e2871010 	add	r1, r7, #16
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd3214:	e5091010 	str	r1, [r9, #-16]
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3218:	e5082010 	str	r2, [r8, #-16]
fffd321c:	eb000653 	bl	fffd4b70 <rand_8bit>
fffd3220:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd3224:	e2871014 	add	r1, r7, #20
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd3228:	e509100c 	str	r1, [r9, #-12]
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd322c:	e508200c 	str	r2, [r8, #-12]
fffd3230:	eb00064e 	bl	fffd4b70 <rand_8bit>
fffd3234:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd3238:	e2871018 	add	r1, r7, #24
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd323c:	e5091008 	str	r1, [r9, #-8]
fffd3240:	e287701c 	add	r7, r7, #28
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3244:	e5082008 	str	r2, [r8, #-8]
fffd3248:	eb000648 	bl	fffd4b70 <rand_8bit>
fffd324c:	e79a2100 	ldr	r2, [r10, r0, lsl #2]
fffd3250:	e3550078 	cmp	r5, #120	; 0x78
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd3254:	e5097004 	str	r7, [r9, #-4]
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3258:	e5082004 	str	r2, [r8, #-4]
fffd325c:	1affffcd 	bne	fffd3198 <MemStressTest+0xbc>
fffd3260:	e59d400c 	ldr	r4, [sp, #12]
fffd3264:	e1a0500a 	mov	r5, r10
fffd3268:	e59f9e40 	ldr	r9, [pc, #3648]	; fffd40b0 <MemStressTest+0xfd4>
fffd326c:	e28b8f77 	add	r8, r11, #476	; 0x1dc
fffd3270:	e2847f77 	add	r7, r4, #476	; 0x1dc
fffd3274:	e08f9009 	add	r9, pc, r9
fffd3278:	eb00063c 	bl	fffd4b70 <rand_8bit>
fffd327c:	e2873601 	add	r3, r7, #1048576	; 0x100000
fffd3280:	e7992100 	ldr	r2, [r9, r0, lsl #2]
fffd3284:	e2833004 	add	r3, r3, #4
		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3288:	e2566001 	subs	r6, r6, #1
fffd328c:	e0643003 	rsb	r3, r4, r3
fffd3290:	e2877004 	add	r7, r7, #4
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3294:	e5872000 	str	r2, [r7]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
fffd3298:	e5a83004 	str	r3, [r8, #4]!
		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&7) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd329c:	1afffff5 	bne	fffd3278 <MemStressTest+0x19c>
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
			}
		}
		//-------------------------------------------------------------------------------------------------------
		CPU1_Cmd = l_NumOfLoops&0xFF;
fffd32a0:	e5dd301c 	ldrb	r3, [sp, #28]
fffd32a4:	e59d2010 	ldr	r2, [sp, #16]
fffd32a8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
fffd32ac:	e5823000 	str	r3, [r2]
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
fffd32b0:	e320f004 	sev
fffd32b4:	e28b7f7f 	add	r7, r11, #508	; 0x1fc
fffd32b8:	e24b3004 	sub	r3, r11, #4
fffd32bc:	e2442004 	sub	r2, r4, #4
fffd32c0:	e58d300c 	str	r3, [sp, #12]
fffd32c4:	e58d2030 	str	r2, [sp, #48]	; 0x30
		// write (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			HW_DWORD(g_AddrBuff[index]) = g_DataWrite1Buff[index];
fffd32c8:	e5b31004 	ldr	r1, [r3, #4]!
fffd32cc:	e5b20004 	ldr	r0, [r2, #4]!
		}
		//-------------------------------------------------------------------------------------------------------
		CPU1_Cmd = l_NumOfLoops&0xFF;
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// write (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd32d0:	e1530007 	cmp	r3, r7
			HW_DWORD(g_AddrBuff[index]) = g_DataWrite1Buff[index];
fffd32d4:	e5810000 	str	r0, [r1]
		}
		//-------------------------------------------------------------------------------------------------------
		CPU1_Cmd = l_NumOfLoops&0xFF;
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// write (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd32d8:	1afffffa 	bne	fffd32c8 <MemStressTest+0x1ec>
			HW_DWORD(g_AddrBuff[index]) = g_DataWrite1Buff[index];

		CPU1_Cmd = l_NumOfLoops&0xFF;
fffd32dc:	e59d3010 	ldr	r3, [sp, #16]
fffd32e0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
fffd32e4:	e5832000 	str	r2, [r3]
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
fffd32e8:	e320f004 	sev
fffd32ec:	e59d3018 	ldr	r3, [sp, #24]
fffd32f0:	e2433004 	sub	r3, r3, #4
fffd32f4:	e1a00003 	mov	r0, r3
fffd32f8:	e58d3024 	str	r3, [sp, #36]	; 0x24
fffd32fc:	e59d300c 	ldr	r3, [sp, #12]
		// read & write anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			 g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);
fffd3300:	e5b32004 	ldr	r2, [r3, #4]!
fffd3304:	e5921000 	ldr	r1, [r2]
			HW_DWORD(g_AddrBuff[index]) = g_DataWrite1Buff[index];

		CPU1_Cmd = l_NumOfLoops&0xFF;
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read & write anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3308:	e1530007 	cmp	r3, r7
		{
			 g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);
			 HW_DWORD(g_AddrBuff[index]) = ~g_DataReadBuff[index];
fffd330c:	e1e0c001 	mvn	r12, r1
		CPU1_Cmd = l_NumOfLoops&0xFF;
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read & write anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			 g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);
fffd3310:	e5a01004 	str	r1, [r0, #4]!
			 HW_DWORD(g_AddrBuff[index]) = ~g_DataReadBuff[index];
fffd3314:	e582c000 	str	r12, [r2]
			HW_DWORD(g_AddrBuff[index]) = g_DataWrite1Buff[index];

		CPU1_Cmd = l_NumOfLoops&0xFF;
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read & write anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3318:	1afffff8 	bne	fffd3300 <MemStressTest+0x224>
fffd331c:	e59d3018 	ldr	r3, [sp, #24]
fffd3320:	e284804c 	add	r8, r4, #76	; 0x4c
fffd3324:	e3a09000 	mov	r9, #0
fffd3328:	e58d4014 	str	r4, [sp, #20]
fffd332c:	e283604c 	add	r6, r3, #76	; 0x4c
fffd3330:	e59d3020 	ldr	r3, [sp, #32]
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd3334:	e518e04c 	ldr	lr, [r8, #-76]	; 0x4c
fffd3338:	e2694078 	rsb	r4, r9, #120	; 0x78
			UINT32 l_actual = g_DataReadBuff[index];
fffd333c:	e516a04c 	ldr	r10, [r6, #-76]	; 0x4c
fffd3340:	e2899008 	add	r9, r9, #8
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd3344:	e518c048 	ldr	r12, [r8, #-72]	; 0x48
			UINT32 l_actual = g_DataReadBuff[index];
fffd3348:	e5161048 	ldr	r1, [r6, #-72]	; 0x48
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd334c:	e02a000e 	eor	r0, r10, lr
fffd3350:	e15e000a 	cmp	lr, r10
fffd3354:	e1832000 	orr	r2, r3, r0
fffd3358:	01a0e003 	moveq	lr, r3
fffd335c:	e6ff2072 	uxth	r2, r2
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd3360:	e5183044 	ldr	r3, [r8, #-68]	; 0x44
			UINT32 l_actual = g_DataReadBuff[index];
fffd3364:	e516a044 	ldr	r10, [r6, #-68]	; 0x44
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3368:	e1820820 	orr	r0, r2, r0, lsr #16
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd336c:	e021200c 	eor	r2, r1, r12
fffd3370:	e1822822 	orr	r2, r2, r2, lsr #16
fffd3374:	f5d8f000 	pld	[r8]
fffd3378:	11a0e000 	movne	lr, r0
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd337c:	e5180040 	ldr	r0, [r8, #-64]	; 0x40
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3380:	e18e2002 	orr	r2, lr, r2
fffd3384:	e15c0001 	cmp	r12, r1
fffd3388:	e6ff2072 	uxth	r2, r2

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd338c:	e5161040 	ldr	r1, [r6, #-64]	; 0x40
fffd3390:	f5d6f000 	pld	[r6]
fffd3394:	e2888020 	add	r8, r8, #32
fffd3398:	11a0e002 	movne	lr, r2
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd339c:	e02a2003 	eor	r2, r10, r3
fffd33a0:	e1822822 	orr	r2, r2, r2, lsr #16
fffd33a4:	e153000a 	cmp	r3, r10
fffd33a8:	01a0300e 	moveq	r3, lr
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd33ac:	e518a05c 	ldr	r10, [r8, #-92]	; 0x5c
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd33b0:	e18ec002 	orr	r12, lr, r2
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd33b4:	e0212000 	eor	r2, r1, r0
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd33b8:	e6ffc07c 	uxth	r12, r12
fffd33bc:	e1822822 	orr	r2, r2, r2, lsr #16

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd33c0:	e516e03c 	ldr	lr, [r6, #-60]	; 0x3c
fffd33c4:	11a0300c 	movne	r3, r12
fffd33c8:	e1500001 	cmp	r0, r1
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd33cc:	e1832002 	orr	r2, r3, r2
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd33d0:	e518c058 	ldr	r12, [r8, #-88]	; 0x58
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd33d4:	e6ff2072 	uxth	r2, r2
fffd33d8:	e2866020 	add	r6, r6, #32
fffd33dc:	11a03002 	movne	r3, r2
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd33e0:	e02e200a 	eor	r2, lr, r10
fffd33e4:	e1820822 	orr	r0, r2, r2, lsr #16

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd33e8:	e5162058 	ldr	r2, [r6, #-88]	; 0x58
fffd33ec:	e15a000e 	cmp	r10, lr
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd33f0:	e518a054 	ldr	r10, [r8, #-84]	; 0x54
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd33f4:	e1830000 	orr	r0, r3, r0
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd33f8:	e518e050 	ldr	lr, [r8, #-80]	; 0x50
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd33fc:	e022100c 	eor	r1, r2, r12
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3400:	e6ff0070 	uxth	r0, r0
fffd3404:	e1811821 	orr	r1, r1, r1, lsr #16
fffd3408:	01a00003 	moveq	r0, r3

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd340c:	e5163054 	ldr	r3, [r6, #-84]	; 0x54
fffd3410:	e15c0002 	cmp	r12, r2
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3414:	e1801001 	orr	r1, r0, r1

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd3418:	e516c050 	ldr	r12, [r6, #-80]	; 0x50
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd341c:	e6ff1071 	uxth	r1, r1
fffd3420:	01a02000 	moveq	r2, r0
fffd3424:	11a02001 	movne	r2, r1
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3428:	e023100a 	eor	r1, r3, r10
fffd342c:	e1811821 	orr	r1, r1, r1, lsr #16
fffd3430:	e15a0003 	cmp	r10, r3
fffd3434:	01a03002 	moveq	r3, r2
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3438:	e1820001 	orr	r0, r2, r1
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd343c:	e02c100e 	eor	r1, r12, lr
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3440:	e6ff0070 	uxth	r0, r0
fffd3444:	e1811821 	orr	r1, r1, r1, lsr #16
fffd3448:	11a03000 	movne	r3, r0
fffd344c:	e15e000c 	cmp	lr, r12
fffd3450:	e1831001 	orr	r1, r3, r1
fffd3454:	e6ff1071 	uxth	r1, r1
fffd3458:	11a03001 	movne	r3, r1
fffd345c:	e3590078 	cmp	r9, #120	; 0x78
fffd3460:	1affffb3 	bne	fffd3334 <MemStressTest+0x258>
fffd3464:	e1a02004 	mov	r2, r4
fffd3468:	e59d4014 	ldr	r4, [sp, #20]
fffd346c:	e59d1018 	ldr	r1, [sp, #24]
fffd3470:	e282c101 	add	r12, r2, #1073741824	; 0x40000000
fffd3474:	e28cc077 	add	r12, r12, #119	; 0x77
			 g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);
			 HW_DWORD(g_AddrBuff[index]) = ~g_DataReadBuff[index];
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3478:	e1a0a003 	mov	r10, r3
fffd347c:	e2842f77 	add	r2, r4, #476	; 0x1dc
fffd3480:	e2811f77 	add	r1, r1, #476	; 0x1dc
fffd3484:	e084c10c 	add	r12, r4, r12, lsl #2
fffd3488:	e1a0e001 	mov	lr, r1
fffd348c:	e58d2014 	str	r2, [sp, #20]
fffd3490:	e58d1028 	str	r1, [sp, #40]	; 0x28
		{
			UINT32 l_expected = g_DataWrite1Buff[index];
fffd3494:	e5b20004 	ldr	r0, [r2, #4]!
			UINT32 l_actual = g_DataReadBuff[index];
fffd3498:	e5be1004 	ldr	r1, [lr, #4]!
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd349c:	e0213000 	eor	r3, r1, r0
fffd34a0:	e1500001 	cmp	r0, r1
fffd34a4:	e1833823 	orr	r3, r3, r3, lsr #16
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd34a8:	e18a3003 	orr	r3, r10, r3
fffd34ac:	e6ff3073 	uxth	r3, r3
fffd34b0:	11a0a003 	movne	r10, r3
			 g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);
			 HW_DWORD(g_AddrBuff[index]) = ~g_DataReadBuff[index];
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd34b4:	e152000c 	cmp	r2, r12
fffd34b8:	1afffff5 	bne	fffd3494 <MemStressTest+0x3b8>
				}
			}
		}

		
		CPU1_Cmd = l_NumOfLoops&0xFF;
fffd34bc:	e59d3010 	ldr	r3, [sp, #16]
fffd34c0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
fffd34c4:	e5832000 	str	r2, [r3]
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
fffd34c8:	e320f004 	sev
fffd34cc:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
fffd34d0:	e59d300c 	ldr	r3, [sp, #12]

		// read anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);
fffd34d4:	e5b31004 	ldr	r1, [r3, #4]!
fffd34d8:	e5911000 	ldr	r1, [r1]
		
		CPU1_Cmd = l_NumOfLoops&0xFF;
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	

		// read anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd34dc:	e1530007 	cmp	r3, r7
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);
fffd34e0:	e5a21004 	str	r1, [r2, #4]!
		
		CPU1_Cmd = l_NumOfLoops&0xFF;
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	

		// read anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd34e4:	1afffffa 	bne	fffd34d4 <MemStressTest+0x3f8>
fffd34e8:	e59d3018 	ldr	r3, [sp, #24]
fffd34ec:	e2848044 	add	r8, r4, #68	; 0x44
fffd34f0:	e3a09000 	mov	r9, #0
fffd34f4:	e58d4020 	str	r4, [sp, #32]
fffd34f8:	e2836044 	add	r6, r3, #68	; 0x44
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd34fc:	e518c044 	ldr	r12, [r8, #-68]	; 0x44
fffd3500:	e2694078 	rsb	r4, r9, #120	; 0x78
			UINT32 l_actual = g_DataReadBuff[index];
fffd3504:	e516e044 	ldr	lr, [r6, #-68]	; 0x44
fffd3508:	e2899008 	add	r9, r9, #8
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd350c:	e5180040 	ldr	r0, [r8, #-64]	; 0x40
fffd3510:	e1e0c00c 	mvn	r12, r12
			UINT32 l_actual = g_DataReadBuff[index];
fffd3514:	e5161040 	ldr	r1, [r6, #-64]	; 0x40
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3518:	e02c200e 	eor	r2, r12, lr
fffd351c:	e15c000e 	cmp	r12, lr
fffd3520:	e18a3002 	orr	r3, r10, r2
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3524:	e1e00000 	mvn	r0, r0
fffd3528:	e6ff3073 	uxth	r3, r3
			UINT32 l_actual = g_DataReadBuff[index];
fffd352c:	e516e03c 	ldr	lr, [r6, #-60]	; 0x3c
fffd3530:	f5d8f000 	pld	[r8]
fffd3534:	e2888020 	add	r8, r8, #32
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3538:	e1832822 	orr	r2, r3, r2, lsr #16
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd353c:	e0203001 	eor	r3, r0, r1
fffd3540:	e1833823 	orr	r3, r3, r3, lsr #16
fffd3544:	01a0200a 	moveq	r2, r10
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3548:	e518a05c 	ldr	r10, [r8, #-92]	; 0x5c
fffd354c:	e1500001 	cmp	r0, r1
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3550:	e1823003 	orr	r3, r2, r3
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3554:	e5181058 	ldr	r1, [r8, #-88]	; 0x58
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3558:	e6ff3073 	uxth	r3, r3

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd355c:	e5160038 	ldr	r0, [r6, #-56]	; 0x38
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3560:	e1e0a00a 	mvn	r10, r10
fffd3564:	f5d6f000 	pld	[r6]
fffd3568:	11a02003 	movne	r2, r3
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd356c:	e02a300e 	eor	r3, r10, lr
fffd3570:	e6ffc072 	uxth	r12, r2
fffd3574:	e1832823 	orr	r2, r3, r3, lsr #16
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3578:	e1e01001 	mvn	r1, r1
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd357c:	e18c2002 	orr	r2, r12, r2
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3580:	e0213000 	eor	r3, r1, r0
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3584:	e6ff2072 	uxth	r2, r2
fffd3588:	e15a000e 	cmp	r10, lr
fffd358c:	e1833823 	orr	r3, r3, r3, lsr #16
fffd3590:	11a0c002 	movne	r12, r2
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3594:	e518e054 	ldr	lr, [r8, #-84]	; 0x54
			UINT32 l_actual = g_DataReadBuff[index];
fffd3598:	e5162034 	ldr	r2, [r6, #-52]	; 0x34
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd359c:	e18c3003 	orr	r3, r12, r3
fffd35a0:	e6ff3073 	uxth	r3, r3
fffd35a4:	e1510000 	cmp	r1, r0
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd35a8:	e1e0e00e 	mvn	lr, lr
fffd35ac:	e5181050 	ldr	r1, [r8, #-80]	; 0x50
fffd35b0:	11a0c003 	movne	r12, r3
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd35b4:	e02e3002 	eor	r3, lr, r2
fffd35b8:	e1833823 	orr	r3, r3, r3, lsr #16

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd35bc:	e5160030 	ldr	r0, [r6, #-48]	; 0x30
fffd35c0:	e15e0002 	cmp	lr, r2
fffd35c4:	e516a02c 	ldr	r10, [r6, #-44]	; 0x2c
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd35c8:	e18c3003 	orr	r3, r12, r3
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd35cc:	e1e01001 	mvn	r1, r1
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd35d0:	e6ff3073 	uxth	r3, r3
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd35d4:	e0212000 	eor	r2, r1, r0
fffd35d8:	e1822822 	orr	r2, r2, r2, lsr #16
fffd35dc:	e2866020 	add	r6, r6, #32
fffd35e0:	11a0c003 	movne	r12, r3
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd35e4:	e518304c 	ldr	r3, [r8, #-76]	; 0x4c
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd35e8:	e18c2002 	orr	r2, r12, r2
fffd35ec:	e1510000 	cmp	r1, r0
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd35f0:	e5181048 	ldr	r1, [r8, #-72]	; 0x48
fffd35f4:	e1e0e003 	mvn	lr, r3
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd35f8:	e6ff3072 	uxth	r3, r2
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd35fc:	e02e200a 	eor	r2, lr, r10

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
fffd3600:	e5160048 	ldr	r0, [r6, #-72]	; 0x48
fffd3604:	e1822822 	orr	r2, r2, r2, lsr #16
fffd3608:	11a0c003 	movne	r12, r3
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd360c:	e1e01001 	mvn	r1, r1
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3610:	e18c2002 	orr	r2, r12, r2
fffd3614:	e15e000a 	cmp	lr, r10
fffd3618:	e6ff3072 	uxth	r3, r2
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd361c:	e0212000 	eor	r2, r1, r0
fffd3620:	e1822822 	orr	r2, r2, r2, lsr #16
fffd3624:	01a0300c 	moveq	r3, r12
fffd3628:	e1510000 	cmp	r1, r0
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd362c:	e1832002 	orr	r2, r3, r2
fffd3630:	01a0a003 	moveq	r10, r3
fffd3634:	e6ff2072 	uxth	r2, r2
fffd3638:	11a0a002 	movne	r10, r2
fffd363c:	e3590078 	cmp	r9, #120	; 0x78
fffd3640:	1affffad 	bne	fffd34fc <MemStressTest+0x420>
fffd3644:	e1a03004 	mov	r3, r4
fffd3648:	e59d4020 	ldr	r4, [sp, #32]
fffd364c:	e283e101 	add	lr, r3, #1073741824	; 0x40000000
		// read anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3650:	e59dc028 	ldr	r12, [sp, #40]	; 0x28
fffd3654:	e28ee077 	add	lr, lr, #119	; 0x77
fffd3658:	e59d1014 	ldr	r1, [sp, #20]
fffd365c:	e084e10e 	add	lr, r4, lr, lsl #2
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3660:	e5b12004 	ldr	r2, [r1, #4]!
			UINT32 l_actual = g_DataReadBuff[index];
fffd3664:	e5bc0004 	ldr	r0, [r12, #4]!
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = ~g_DataWrite1Buff[index];
fffd3668:	e1e02002 	mvn	r2, r2
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd366c:	e0223000 	eor	r3, r2, r0
fffd3670:	e1520000 	cmp	r2, r0
fffd3674:	e1833823 	orr	r3, r3, r3, lsr #16
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				result_16 |= temp_result_16;
fffd3678:	e18a3003 	orr	r3, r10, r3
fffd367c:	e6ff3073 	uxth	r3, r3
fffd3680:	11a0a003 	movne	r10, r3
		// read anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3684:	e151000e 	cmp	r1, lr
fffd3688:	1afffff4 	bne	fffd3660 <MemStressTest+0x584>
						LogPass  (" Retry read:0x%08lX; \n",l_actual);
				}
			}
		}
	
		l_NumOfLoops++;
fffd368c:	e59d301c 	ldr	r3, [sp, #28]
		// read anti-pattern (~ 100 usec)
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_DWORD(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3690:	e58da020 	str	r10, [sp, #32]
						LogPass  (" Retry read:0x%08lX; \n",l_actual);
				}
			}
		}
	
		l_NumOfLoops++;
fffd3694:	e2833001 	add	r3, r3, #1
fffd3698:	e1a02003 	mov	r2, r3
fffd369c:	e58d301c 	str	r3, [sp, #28]
	UINT32 temp_result_32;
	UINT32 Temp_addr;

	while (1)
	{
		if (l_NumOfLoops>=NumOfLoops)
fffd36a0:	e3003bb8 	movw	r3, #3000	; 0xbb8
fffd36a4:	e1520003 	cmp	r2, r3
fffd36a8:	0a000071 	beq	fffd3874 <MemStressTest+0x798>
			break;

		// stop the test in scan mode (Silent mode) when all bits are with errors 
		if ((IsSilent==TRUE) && (result_16==0xFFFF))
fffd36ac:	e30f3fff 	movw	r3, #65535	; 0xffff
fffd36b0:	e15a0003 	cmp	r10, r3
fffd36b4:	1afffead 	bne	fffd3170 <MemStressTest+0x94>

	//------------------------------------------------------
	status |= Run_MemTest_Type5_dword (3000, TRUE);
	if (status==0xFFFF)
	{
		g_SkipDataAbort = FALSE;
fffd36b8:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
fffd36bc:	e3a03000 	mov	r3, #0
		return (status);
fffd36c0:	e30f0fff 	movw	r0, #65535	; 0xffff

	//------------------------------------------------------
	status |= Run_MemTest_Type5_dword (3000, TRUE);
	if (status==0xFFFF)
	{
		g_SkipDataAbort = FALSE;
fffd36c4:	e5823000 	str	r3, [r2]
	}
	//------------------------------------------------------

	g_SkipDataAbort = FALSE;
	return (status);
}
fffd36c8:	e28dd04c 	add	sp, sp, #76	; 0x4c
fffd36cc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
			}
		}
		else if ((l_NumOfLoops&7) == 1)
fffd36d0:	e35a0001 	cmp	r10, #1
fffd36d4:	0a000047 	beq	fffd37f8 <MemStressTest+0x71c>
fffd36d8:	e1a08004 	mov	r8, r4
fffd36dc:	e1a06004 	mov	r6, r4
fffd36e0:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
fffd36e4:	e3a09000 	mov	r9, #0
fffd36e8:	e1a0a009 	mov	r10, r9
fffd36ec:	e1a0700b 	mov	r7, r11
fffd36f0:	e58d5014 	str	r5, [sp, #20]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd36f4:	eb00051d 	bl	fffd4b70 <rand_8bit>
fffd36f8:	e7941100 	ldr	r1, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd36fc:	e2892601 	add	r2, r9, #1048576	; 0x100000
fffd3700:	e26a3078 	rsb	r3, r10, #120	; 0x78
fffd3704:	f5d8f028 	pld	[r8, #40]	; 0x28
fffd3708:	f5d7f028 	pld	[r7, #40]	; 0x28
fffd370c:	e2895501 	add	r5, r9, #4194304	; 0x400000
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3710:	e786110a 	str	r1, [r6, r10, lsl #2]
fffd3714:	e2877020 	add	r7, r7, #32
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd3718:	e78b210a 	str	r2, [r11, r10, lsl #2]
fffd371c:	e28aa008 	add	r10, r10, #8
fffd3720:	e58d300c 	str	r3, [sp, #12]
fffd3724:	e2888020 	add	r8, r8, #32
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3728:	eb000510 	bl	fffd4b70 <rand_8bit>
fffd372c:	e7942100 	ldr	r2, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd3730:	e2891706 	add	r1, r9, #1572864	; 0x180000
fffd3734:	e507101c 	str	r1, [r7, #-28]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3738:	e508201c 	str	r2, [r8, #-28]
fffd373c:	eb00050b 	bl	fffd4b70 <rand_8bit>
fffd3740:	e7942100 	ldr	r2, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd3744:	e2891602 	add	r1, r9, #2097152	; 0x200000
fffd3748:	e5071018 	str	r1, [r7, #-24]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd374c:	e5082018 	str	r2, [r8, #-24]
fffd3750:	eb000506 	bl	fffd4b70 <rand_8bit>
fffd3754:	e7942100 	ldr	r2, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd3758:	e289170a 	add	r1, r9, #2621440	; 0x280000
fffd375c:	e5071014 	str	r1, [r7, #-20]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3760:	e5082014 	str	r2, [r8, #-20]
fffd3764:	eb000501 	bl	fffd4b70 <rand_8bit>
fffd3768:	e7942100 	ldr	r2, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd376c:	e2891603 	add	r1, r9, #3145728	; 0x300000
fffd3770:	e5071010 	str	r1, [r7, #-16]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3774:	e5082010 	str	r2, [r8, #-16]
fffd3778:	eb0004fc 	bl	fffd4b70 <rand_8bit>
fffd377c:	e7942100 	ldr	r2, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd3780:	e289170e 	add	r1, r9, #3670016	; 0x380000
fffd3784:	e507100c 	str	r1, [r7, #-12]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3788:	e508200c 	str	r2, [r8, #-12]
fffd378c:	eb0004f7 	bl	fffd4b70 <rand_8bit>
fffd3790:	e7942100 	ldr	r2, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd3794:	e5075008 	str	r5, [r7, #-8]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3798:	e5082008 	str	r2, [r8, #-8]
fffd379c:	eb0004f3 	bl	fffd4b70 <rand_8bit>
fffd37a0:	e7942100 	ldr	r2, [r4, r0, lsl #2]
fffd37a4:	e35a0078 	cmp	r10, #120	; 0x78
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd37a8:	e2891712 	add	r1, r9, #4718592	; 0x480000
fffd37ac:	e1a09005 	mov	r9, r5
fffd37b0:	e5071004 	str	r1, [r7, #-4]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd37b4:	e5082004 	str	r2, [r8, #-4]
fffd37b8:	1affffcd 	bne	fffd36f4 <MemStressTest+0x618>
fffd37bc:	e1a04006 	mov	r4, r6
fffd37c0:	e59d5014 	ldr	r5, [sp, #20]
fffd37c4:	e59d600c 	ldr	r6, [sp, #12]
fffd37c8:	e2849f77 	add	r9, r4, #476	; 0x1dc
			}
		}
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd37cc:	e59da03c 	ldr	r10, [sp, #60]	; 0x3c
fffd37d0:	e28b8f77 	add	r8, r11, #476	; 0x1dc
fffd37d4:	e3a0763d 	mov	r7, #63963136	; 0x3d00000
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd37d8:	eb0004e4 	bl	fffd4b70 <rand_8bit>
fffd37dc:	e79a3100 	ldr	r3, [r10, r0, lsl #2]
			}
		}
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd37e0:	e2566001 	subs	r6, r6, #1
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index);
fffd37e4:	e5a87004 	str	r7, [r8, #4]!
fffd37e8:	e2877702 	add	r7, r7, #524288	; 0x80000
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd37ec:	e5a93004 	str	r3, [r9, #4]!
			}
		}
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd37f0:	1afffff8 	bne	fffd37d8 <MemStressTest+0x6fc>
fffd37f4:	eafffea9 	b	fffd32a0 <MemStressTest+0x1c4>
fffd37f8:	e2447004 	sub	r7, r4, #4
fffd37fc:	e24b8004 	sub	r8, r11, #4
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + 4*index;
			}
		}
		else if ((l_NumOfLoops&7) == 1)
fffd3800:	e3a06000 	mov	r6, #0
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = Golden_Numbers[rand_8bit()]; 
fffd3804:	eb0004d9 	bl	fffd4b70 <rand_8bit>
fffd3808:	e59d3008 	ldr	r3, [sp, #8]
fffd380c:	e7933100 	ldr	r3, [r3, r0, lsl #2]
fffd3810:	e5a73004 	str	r3, [r7, #4]!
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				// get random address and verify it does not exist in the buffer. 
				UINT32 index2 = (-1);
				while (index2 == (-1))
				{
					Temp_addr = ((rand_32bit()&DDR_ADDR_MASK) + DDR_ADDR_BASE) & 0xFFFFFFFC/*aline to DWORD*/;
fffd3814:	eb0004e0 	bl	fffd4b9c <rand_32bit>
					// make sure this new address is not in the list
					for (index2=0; index2<index; index2++)
fffd3818:	e3560000 	cmp	r6, #0
				//g_DataWrite2Buff[index] = ~g_DataWrite1Buff[index];
				// get random address and verify it does not exist in the buffer. 
				UINT32 index2 = (-1);
				while (index2 == (-1))
				{
					Temp_addr = ((rand_32bit()&DDR_ADDR_MASK) + DDR_ADDR_BASE) & 0xFFFFFFFC/*aline to DWORD*/;
fffd381c:	e3c0033f 	bic	r0, r0, #-67108864	; 0xfc000000
fffd3820:	e2800601 	add	r0, r0, #1048576	; 0x100000
fffd3824:	e3c00003 	bic	r0, r0, #3
					// make sure this new address is not in the list
					for (index2=0; index2<index; index2++)
fffd3828:	0a00000e 	beq	fffd3868 <MemStressTest+0x78c>
					{
						if (g_AddrBuff[index2]==Temp_addr)
fffd382c:	e59b3000 	ldr	r3, [r11]
fffd3830:	e1500003 	cmp	r0, r3
fffd3834:	0afffff6 	beq	fffd3814 <MemStressTest+0x738>
fffd3838:	e1a0300b 	mov	r3, r11
fffd383c:	ea000002 	b	fffd384c <MemStressTest+0x770>
fffd3840:	e5b32004 	ldr	r2, [r3, #4]!
fffd3844:	e1500002 	cmp	r0, r2
fffd3848:	0afffff1 	beq	fffd3814 <MemStressTest+0x738>
				UINT32 index2 = (-1);
				while (index2 == (-1))
				{
					Temp_addr = ((rand_32bit()&DDR_ADDR_MASK) + DDR_ADDR_BASE) & 0xFFFFFFFC/*aline to DWORD*/;
					// make sure this new address is not in the list
					for (index2=0; index2<index; index2++)
fffd384c:	e1530008 	cmp	r3, r8
fffd3850:	1afffffa 	bne	fffd3840 <MemStressTest+0x764>
			}
		}
		else if ((l_NumOfLoops&7) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3854:	e2866001 	add	r6, r6, #1
							index2 = (-1);
							break;
						}
					}
				}
				g_AddrBuff[index] = Temp_addr;  // add this random address to the list
fffd3858:	e5a80004 	str	r0, [r8, #4]!
			}
		}
		else if ((l_NumOfLoops&7) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd385c:	e3560080 	cmp	r6, #128	; 0x80
fffd3860:	1affffe7 	bne	fffd3804 <MemStressTest+0x728>
fffd3864:	eafffe8d 	b	fffd32a0 <MemStressTest+0x1c4>
							index2 = (-1);
							break;
						}
					}
				}
				g_AddrBuff[index] = Temp_addr;  // add this random address to the list
fffd3868:	e5a80004 	str	r0, [r8, #4]!
			}
		}
		else if ((l_NumOfLoops&7) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd386c:	e3a06001 	mov	r6, #1
fffd3870:	eaffffe3 	b	fffd3804 <MemStressTest+0x728>

	status = 0;

	//------------------------------------------------------
	status |= Run_MemTest_Type5_dword (3000, TRUE);
	if (status==0xFFFF)
fffd3874:	e30f3fff 	movw	r3, #65535	; 0xffff
fffd3878:	e15a0003 	cmp	r10, r3
fffd387c:	0affff8d 	beq	fffd36b8 <MemStressTest+0x5dc>
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3880:	e59f382c 	ldr	r3, [pc, #2092]	; fffd40b4 <MemStressTest+0xfd8>
fffd3884:	e3a09000 	mov	r9, #0
fffd3888:	e58d901c 	str	r9, [sp, #28]
fffd388c:	e58da03c 	str	r10, [sp, #60]	; 0x3c
fffd3890:	e08f3003 	add	r3, pc, r3
fffd3894:	e58d3020 	str	r3, [sp, #32]
fffd3898:	e59f3818 	ldr	r3, [pc, #2072]	; fffd40b8 <MemStressTest+0xfdc>
fffd389c:	e08f3003 	add	r3, pc, r3
fffd38a0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		else if ((l_NumOfLoops&3) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd38a4:	e59f3810 	ldr	r3, [pc, #2064]	; fffd40bc <MemStressTest+0xfe0>
fffd38a8:	e08f3003 	add	r3, pc, r3
fffd38ac:	e58d3008 	str	r3, [sp, #8]
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd38b0:	e59f3808 	ldr	r3, [pc, #2056]	; fffd40c0 <MemStressTest+0xfe4>
fffd38b4:	e08f3003 	add	r3, pc, r3
fffd38b8:	e58d3038 	str	r3, [sp, #56]	; 0x38
		}
		*/

		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&3) == 0)
fffd38bc:	e59d301c 	ldr	r3, [sp, #28]
fffd38c0:	e213a003 	ands	r10, r3, #3
fffd38c4:	1a000172 	bne	fffd3e94 <MemStressTest+0xdb8>
fffd38c8:	e59d8004 	ldr	r8, [sp, #4]
fffd38cc:	e1a0600b 	mov	r6, r11
fffd38d0:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
fffd38d4:	e58d7040 	str	r7, [sp, #64]	; 0x40
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd38d8:	eb0004a4 	bl	fffd4b70 <rand_8bit>
fffd38dc:	e59d2004 	ldr	r2, [sp, #4]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd38e0:	e28a5601 	add	r5, r10, #1048576	; 0x100000
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd38e4:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
fffd38e8:	e26a7078 	rsb	r7, r10, #120	; 0x78
fffd38ec:	f5d8f028 	pld	[r8, #40]	; 0x28
fffd38f0:	e2888020 	add	r8, r8, #32
fffd38f4:	f5d6f028 	pld	[r6, #40]	; 0x28
fffd38f8:	e2866020 	add	r6, r6, #32
fffd38fc:	e782310a 	str	r3, [r2, r10, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd3900:	e78b510a 	str	r5, [r11, r10, lsl #2]
fffd3904:	e28aa008 	add	r10, r10, #8
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3908:	eb000498 	bl	fffd4b70 <rand_8bit>
fffd390c:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd3910:	e2851001 	add	r1, r5, #1
fffd3914:	e506101c 	str	r1, [r6, #-28]
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3918:	e508301c 	str	r3, [r8, #-28]
fffd391c:	eb000493 	bl	fffd4b70 <rand_8bit>
fffd3920:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd3924:	e2851002 	add	r1, r5, #2
fffd3928:	e5061018 	str	r1, [r6, #-24]
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd392c:	e5083018 	str	r3, [r8, #-24]
fffd3930:	eb00048e 	bl	fffd4b70 <rand_8bit>
fffd3934:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd3938:	e2851003 	add	r1, r5, #3
fffd393c:	e5061014 	str	r1, [r6, #-20]
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3940:	e5083014 	str	r3, [r8, #-20]
fffd3944:	eb000489 	bl	fffd4b70 <rand_8bit>
fffd3948:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd394c:	e2851004 	add	r1, r5, #4
fffd3950:	e5061010 	str	r1, [r6, #-16]
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3954:	e5083010 	str	r3, [r8, #-16]
fffd3958:	eb000484 	bl	fffd4b70 <rand_8bit>
fffd395c:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd3960:	e2851005 	add	r1, r5, #5
fffd3964:	e506100c 	str	r1, [r6, #-12]
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3968:	e508300c 	str	r3, [r8, #-12]
fffd396c:	eb00047f 	bl	fffd4b70 <rand_8bit>
fffd3970:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd3974:	e2851006 	add	r1, r5, #6
fffd3978:	e5061008 	str	r1, [r6, #-8]
fffd397c:	e2855007 	add	r5, r5, #7
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3980:	e5083008 	str	r3, [r8, #-8]
fffd3984:	eb000479 	bl	fffd4b70 <rand_8bit>
fffd3988:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
fffd398c:	e35a0078 	cmp	r10, #120	; 0x78
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd3990:	e5065004 	str	r5, [r6, #-4]
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3994:	e5083004 	str	r3, [r8, #-4]
fffd3998:	1affffce 	bne	fffd38d8 <MemStressTest+0x7fc>
fffd399c:	e59f5720 	ldr	r5, [pc, #1824]	; fffd40c4 <MemStressTest+0xfe8>
fffd39a0:	e1a04007 	mov	r4, r7
		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd39a4:	e59d8014 	ldr	r8, [sp, #20]
fffd39a8:	e3a06078 	mov	r6, #120	; 0x78
fffd39ac:	e59d7040 	ldr	r7, [sp, #64]	; 0x40
fffd39b0:	e3406010 	movt	r6, #16
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd39b4:	e08f5005 	add	r5, pc, r5
fffd39b8:	e28baf77 	add	r10, r11, #476	; 0x1dc
fffd39bc:	eb00046b 	bl	fffd4b70 <rand_8bit>
fffd39c0:	e7d53100 	ldrb	r3, [r5, r0, lsl #2]
		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd39c4:	e2544001 	subs	r4, r4, #1
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
fffd39c8:	e5aa6004 	str	r6, [r10, #4]!
fffd39cc:	e2866001 	add	r6, r6, #1
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd39d0:	e5a83004 	str	r3, [r8, #4]!
		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&3) == 0)
		{
			// option 1: sequence address (good for DM)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd39d4:	1afffff8 	bne	fffd39bc <MemStressTest+0x8e0>
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
			}
		}
		//-------------------------------------------------------------------------------------------------------
		CPU1_Cmd = 100; 
fffd39d8:	e59d2010 	ldr	r2, [sp, #16]
fffd39dc:	e3a03064 	mov	r3, #100	; 0x64
fffd39e0:	e5823000 	str	r3, [r2]
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
fffd39e4:	e320f004 	sev
fffd39e8:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
fffd39ec:	e59d200c 	ldr	r2, [sp, #12]
		// write
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			HW_BYTE(g_AddrBuff[index]) = g_DataWrite1Buff[index];
fffd39f0:	e5b13004 	ldr	r3, [r1, #4]!
fffd39f4:	e5b20004 	ldr	r0, [r2, #4]!
fffd39f8:	e6ef3073 	uxtb	r3, r3
		}
		//-------------------------------------------------------------------------------------------------------
		CPU1_Cmd = 100; 
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// write
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd39fc:	e1520007 	cmp	r2, r7
			HW_BYTE(g_AddrBuff[index]) = g_DataWrite1Buff[index];
fffd3a00:	e5c03000 	strb	r3, [r0]
		}
		//-------------------------------------------------------------------------------------------------------
		CPU1_Cmd = 100; 
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// write
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3a04:	1afffff9 	bne	fffd39f0 <MemStressTest+0x914>
			HW_BYTE(g_AddrBuff[index]) = g_DataWrite1Buff[index];

		CPU1_Cmd = 100; 
fffd3a08:	e59d2010 	ldr	r2, [sp, #16]
fffd3a0c:	e3a03064 	mov	r3, #100	; 0x64
fffd3a10:	e5823000 	str	r3, [r2]
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
fffd3a14:	e320f004 	sev
fffd3a18:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
fffd3a1c:	e59d200c 	ldr	r2, [sp, #12]
		// read & write anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);
fffd3a20:	e5b2c004 	ldr	r12, [r2, #4]!
fffd3a24:	e5dc3000 	ldrb	r3, [r12]
			HW_BYTE(g_AddrBuff[index]) = g_DataWrite1Buff[index];

		CPU1_Cmd = 100; 
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read & write anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3a28:	e1520007 	cmp	r2, r7
		{
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);
fffd3a2c:	e6ef3073 	uxtb	r3, r3
			HW_BYTE(g_AddrBuff[index]) = (UINT8)(~g_DataReadBuff[index]);
fffd3a30:	e1e01003 	mvn	r1, r3
		CPU1_Cmd = 100; 
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read & write anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);
fffd3a34:	e5a03004 	str	r3, [r0, #4]!
			HW_BYTE(g_AddrBuff[index]) = (UINT8)(~g_DataReadBuff[index]);
fffd3a38:	e6ef3071 	uxtb	r3, r1
fffd3a3c:	e5cc3000 	strb	r3, [r12]
			HW_BYTE(g_AddrBuff[index]) = g_DataWrite1Buff[index];

		CPU1_Cmd = 100; 
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read & write anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3a40:	1afffff6 	bne	fffd3a20 <MemStressTest+0x944>
fffd3a44:	e59d3004 	ldr	r3, [sp, #4]
fffd3a48:	e283503c 	add	r5, r3, #60	; 0x3c
fffd3a4c:	e59d3018 	ldr	r3, [sp, #24]
fffd3a50:	e1a08005 	mov	r8, r5
fffd3a54:	e58d5044 	str	r5, [sp, #68]	; 0x44
fffd3a58:	e283403c 	add	r4, r3, #60	; 0x3c
fffd3a5c:	e3a03000 	mov	r3, #0
fffd3a60:	e1a06004 	mov	r6, r4
fffd3a64:	e1a0e003 	mov	lr, r3
fffd3a68:	e58d4040 	str	r4, [sp, #64]	; 0x40
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3a6c:	e518203c 	ldr	r2, [r8, #-60]	; 0x3c
fffd3a70:	e26e5078 	rsb	r5, lr, #120	; 0x78
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3a74:	e516003c 	ldr	r0, [r6, #-60]	; 0x3c
fffd3a78:	e28ee008 	add	lr, lr, #8
fffd3a7c:	e5164038 	ldr	r4, [r6, #-56]	; 0x38
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3a80:	e5183038 	ldr	r3, [r8, #-56]	; 0x38
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3a84:	e0201002 	eor	r1, r0, r2
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3a88:	e6ef2072 	uxtb	r2, r2
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3a8c:	e6ef0070 	uxtb	r0, r0
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3a90:	e6ef1071 	uxtb	r1, r1

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3a94:	e516c034 	ldr	r12, [r6, #-52]	; 0x34
fffd3a98:	e1520000 	cmp	r2, r0
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3a9c:	e1811401 	orr	r1, r1, r1, lsl #8
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3aa0:	e0240003 	eor	r0, r4, r3
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3aa4:	e518a034 	ldr	r10, [r8, #-52]	; 0x34
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3aa8:	e6ef0070 	uxtb	r0, r0
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3aac:	e1891001 	orr	r1, r9, r1
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3ab0:	e6ef3073 	uxtb	r3, r3
fffd3ab4:	11a02001 	movne	r2, r1
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3ab8:	e1800400 	orr	r0, r0, r0, lsl #8

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3abc:	e6ef1074 	uxtb	r1, r4
fffd3ac0:	e5164030 	ldr	r4, [r6, #-48]	; 0x30
fffd3ac4:	01a02009 	moveq	r2, r9
fffd3ac8:	e1530001 	cmp	r3, r1
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3acc:	e1820000 	orr	r0, r2, r0
fffd3ad0:	01a03002 	moveq	r3, r2
fffd3ad4:	11a03000 	movne	r3, r0
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3ad8:	e02c000a 	eor	r0, r12, r10
fffd3adc:	e6ef0070 	uxtb	r0, r0
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3ae0:	e5189030 	ldr	r9, [r8, #-48]	; 0x30
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3ae4:	e6ef207c 	uxtb	r2, r12
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3ae8:	e6efa07a 	uxtb	r10, r10
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3aec:	e1801400 	orr	r1, r0, r0, lsl #8
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3af0:	e518c02c 	ldr	r12, [r8, #-44]	; 0x2c
fffd3af4:	e15a0002 	cmp	r10, r2
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3af8:	e516002c 	ldr	r0, [r6, #-44]	; 0x2c
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3afc:	e1831001 	orr	r1, r3, r1
fffd3b00:	01a01003 	moveq	r1, r3
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3b04:	e0243009 	eor	r3, r4, r9
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3b08:	e6ef2079 	uxtb	r2, r9
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3b0c:	e6ef3073 	uxtb	r3, r3

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3b10:	e6ef4074 	uxtb	r4, r4
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3b14:	e518a028 	ldr	r10, [r8, #-40]	; 0x28
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3b18:	e1833403 	orr	r3, r3, r3, lsl #8
fffd3b1c:	e1520004 	cmp	r2, r4
fffd3b20:	01a02001 	moveq	r2, r1

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3b24:	e5169028 	ldr	r9, [r6, #-40]	; 0x28
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3b28:	e1813003 	orr	r3, r1, r3
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3b2c:	e020100c 	eor	r1, r0, r12
fffd3b30:	e6ef1071 	uxtb	r1, r1
fffd3b34:	11a02003 	movne	r2, r3

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3b38:	e6ef0070 	uxtb	r0, r0
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3b3c:	e6ef307c 	uxtb	r3, r12
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3b40:	e1811401 	orr	r1, r1, r1, lsl #8
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3b44:	e5184024 	ldr	r4, [r8, #-36]	; 0x24
fffd3b48:	e1530000 	cmp	r3, r0
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3b4c:	e516c024 	ldr	r12, [r6, #-36]	; 0x24
fffd3b50:	01a03002 	moveq	r3, r2
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3b54:	e1821001 	orr	r1, r2, r1
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3b58:	e029200a 	eor	r2, r9, r10
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3b5c:	e6efa07a 	uxtb	r10, r10
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3b60:	e6ef2072 	uxtb	r2, r2

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3b64:	e6ef9079 	uxtb	r9, r9
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3b68:	e5180020 	ldr	r0, [r8, #-32]
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3b6c:	e1822402 	orr	r2, r2, r2, lsl #8
fffd3b70:	11a03001 	movne	r3, r1
fffd3b74:	e15a0009 	cmp	r10, r9

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3b78:	e5161020 	ldr	r1, [r6, #-32]
fffd3b7c:	01a0a003 	moveq	r10, r3
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3b80:	e1832002 	orr	r2, r3, r2
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3b84:	e02c3004 	eor	r3, r12, r4
fffd3b88:	11a0a002 	movne	r10, r2
fffd3b8c:	e6ef3073 	uxtb	r3, r3
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3b90:	e6ef4074 	uxtb	r4, r4
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3b94:	e6efc07c 	uxtb	r12, r12
fffd3b98:	f5d8f000 	pld	[r8]
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3b9c:	e1832403 	orr	r2, r3, r3, lsl #8
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3ba0:	e0213000 	eor	r3, r1, r0
fffd3ba4:	e6ef3073 	uxtb	r3, r3
fffd3ba8:	e154000c 	cmp	r4, r12
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3bac:	e6ef0070 	uxtb	r0, r0
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3bb0:	e6ef1071 	uxtb	r1, r1
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3bb4:	e1833403 	orr	r3, r3, r3, lsl #8
fffd3bb8:	f5d6f000 	pld	[r6]
				result_16 |= temp_result_16;
fffd3bbc:	e18a2002 	orr	r2, r10, r2
fffd3bc0:	01a0200a 	moveq	r2, r10
fffd3bc4:	e1500001 	cmp	r0, r1
fffd3bc8:	e1823003 	orr	r3, r2, r3
fffd3bcc:	01a09002 	moveq	r9, r2
fffd3bd0:	11a09003 	movne	r9, r3
fffd3bd4:	e35e0078 	cmp	lr, #120	; 0x78
fffd3bd8:	e2888020 	add	r8, r8, #32
fffd3bdc:	e2866020 	add	r6, r6, #32
fffd3be0:	1affffa1 	bne	fffd3a6c <MemStressTest+0x990>
fffd3be4:	e1a03005 	mov	r3, r5
fffd3be8:	e59d4040 	ldr	r4, [sp, #64]	; 0x40
fffd3bec:	e283e101 	add	lr, r3, #1073741824	; 0x40000000
fffd3bf0:	e59d3004 	ldr	r3, [sp, #4]
fffd3bf4:	e28ee077 	add	lr, lr, #119	; 0x77
fffd3bf8:	e59d5044 	ldr	r5, [sp, #68]	; 0x44
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);
			HW_BYTE(g_AddrBuff[index]) = (UINT8)(~g_DataReadBuff[index]);
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3bfc:	e59dc028 	ldr	r12, [sp, #40]	; 0x28
fffd3c00:	e59d0014 	ldr	r0, [sp, #20]
fffd3c04:	e083e10e 	add	lr, r3, lr, lsl #2
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3c08:	e5b03004 	ldr	r3, [r0, #4]!
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3c0c:	e5bc1004 	ldr	r1, [r12, #4]!
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3c10:	e0212003 	eor	r2, r1, r3
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
fffd3c14:	e6ef6073 	uxtb	r6, r3
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3c18:	e6ef3072 	uxtb	r3, r2

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(g_DataWrite1Buff[index]);
			UINT32 l_actual = (UINT8)g_DataReadBuff[index];
fffd3c1c:	e6ef1071 	uxtb	r1, r1
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3c20:	e1832403 	orr	r2, r3, r3, lsl #8
fffd3c24:	e1560001 	cmp	r6, r1
fffd3c28:	01a03009 	moveq	r3, r9
				result_16 |= temp_result_16;
fffd3c2c:	e1892002 	orr	r2, r9, r2
fffd3c30:	11a03002 	movne	r3, r2
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);
			HW_BYTE(g_AddrBuff[index]) = (UINT8)(~g_DataReadBuff[index]);
		}

		// verify pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3c34:	e150000e 	cmp	r0, lr
fffd3c38:	e6ff9073 	uxth	r9, r3
fffd3c3c:	1afffff1 	bne	fffd3c08 <MemStressTest+0xb2c>
				}
			}
		}

	
		CPU1_Cmd = 100; 
fffd3c40:	e59d2010 	ldr	r2, [sp, #16]
fffd3c44:	e3a03064 	mov	r3, #100	; 0x64
fffd3c48:	e5823000 	str	r3, [r2]
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
fffd3c4c:	e320f004 	sev
fffd3c50:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
fffd3c54:	e59d300c 	ldr	r3, [sp, #12]
		// read anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);
fffd3c58:	e5b31004 	ldr	r1, [r3, #4]!
fffd3c5c:	e5d11000 	ldrb	r1, [r1]

	
		CPU1_Cmd = 100; 
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3c60:	e1530007 	cmp	r3, r7
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);
fffd3c64:	e5a21004 	str	r1, [r2, #4]!

	
		CPU1_Cmd = 100; 
		__asm__ ("SEV"); // causes an event to be signaled to all cores within a multiprocessor system	
		// read anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3c68:	1afffffa 	bne	fffd3c58 <MemStressTest+0xb7c>
fffd3c6c:	e3a0a000 	mov	r10, #0
fffd3c70:	e58d7040 	str	r7, [sp, #64]	; 0x40
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3c74:	e515103c 	ldr	r1, [r5, #-60]	; 0x3c
fffd3c78:	e26a7078 	rsb	r7, r10, #120	; 0x78
			UINT32 l_actual = g_DataReadBuff[index];
fffd3c7c:	e514e03c 	ldr	lr, [r4, #-60]	; 0x3c
fffd3c80:	e28aa008 	add	r10, r10, #8
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3c84:	e5153038 	ldr	r3, [r5, #-56]	; 0x38
fffd3c88:	e1e01001 	mvn	r1, r1
fffd3c8c:	e515c034 	ldr	r12, [r5, #-52]	; 0x34
fffd3c90:	e6ef1071 	uxtb	r1, r1
fffd3c94:	e5150030 	ldr	r0, [r5, #-48]	; 0x30
fffd3c98:	e1e03003 	mvn	r3, r3
			UINT32 l_actual = g_DataReadBuff[index];
fffd3c9c:	e5148034 	ldr	r8, [r4, #-52]	; 0x34
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3ca0:	e021200e 	eor	r2, r1, lr
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3ca4:	e6ef6073 	uxtb	r6, r3
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3ca8:	e1822822 	orr	r2, r2, r2, lsr #16

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
fffd3cac:	e5143038 	ldr	r3, [r4, #-56]	; 0x38
fffd3cb0:	e151000e 	cmp	r1, lr
fffd3cb4:	f5d5f000 	pld	[r5]
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3cb8:	e1822402 	orr	r2, r2, r2, lsl #8
fffd3cbc:	01a0e009 	moveq	lr, r9
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3cc0:	e1e0c00c 	mvn	r12, r12
fffd3cc4:	f5d4f000 	pld	[r4]
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3cc8:	e6ff2072 	uxth	r2, r2
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3ccc:	e6efc07c 	uxtb	r12, r12
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3cd0:	e1892002 	orr	r2, r9, r2
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3cd4:	e0269003 	eor	r9, r6, r3
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3cd8:	e1899829 	orr	r9, r9, r9, lsr #16
fffd3cdc:	11a0e002 	movne	lr, r2
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3ce0:	e515202c 	ldr	r2, [r5, #-44]	; 0x2c
fffd3ce4:	e6ffe07e 	uxth	lr, lr
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3ce8:	e1899409 	orr	r9, r9, r9, lsl #8
fffd3cec:	e1530006 	cmp	r3, r6
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3cf0:	e1e00000 	mvn	r0, r0
			UINT32 l_actual = g_DataReadBuff[index];
fffd3cf4:	e514602c 	ldr	r6, [r4, #-44]	; 0x2c
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3cf8:	e6ff9079 	uxth	r9, r9
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3cfc:	e1e02002 	mvn	r2, r2
fffd3d00:	e6ef1072 	uxtb	r1, r2
			UINT32 l_actual = g_DataReadBuff[index];
fffd3d04:	e5142030 	ldr	r2, [r4, #-48]	; 0x30
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3d08:	e18e9009 	orr	r9, lr, r9
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3d0c:	e6ef0070 	uxtb	r0, r0
fffd3d10:	11a03009 	movne	r3, r9
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3d14:	e02c9008 	eor	r9, r12, r8
fffd3d18:	01a0300e 	moveq	r3, lr
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3d1c:	e1899829 	orr	r9, r9, r9, lsr #16
fffd3d20:	e158000c 	cmp	r8, r12
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3d24:	e0208002 	eor	r8, r0, r2
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3d28:	e515e028 	ldr	lr, [r5, #-40]	; 0x28
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3d2c:	e1899409 	orr	r9, r9, r9, lsl #8
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3d30:	e1888828 	orr	r8, r8, r8, lsr #16
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3d34:	e515c024 	ldr	r12, [r5, #-36]	; 0x24
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3d38:	e6ff9079 	uxth	r9, r9
fffd3d3c:	e1888408 	orr	r8, r8, r8, lsl #8
				result_16 |= temp_result_16;
fffd3d40:	e1839009 	orr	r9, r3, r9
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3d44:	e6ff8078 	uxth	r8, r8
fffd3d48:	11a03009 	movne	r3, r9

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
fffd3d4c:	e5149028 	ldr	r9, [r4, #-40]	; 0x28
fffd3d50:	e1520000 	cmp	r2, r0
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3d54:	e1838008 	orr	r8, r3, r8
fffd3d58:	01a02003 	moveq	r2, r3
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3d5c:	e0213006 	eor	r3, r1, r6
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3d60:	e1833823 	orr	r3, r3, r3, lsr #16
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3d64:	e1e0e00e 	mvn	lr, lr
fffd3d68:	11a02008 	movne	r2, r8
fffd3d6c:	e6efe07e 	uxtb	lr, lr
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3d70:	e1833403 	orr	r3, r3, r3, lsl #8
fffd3d74:	e1510006 	cmp	r1, r6
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3d78:	e5150020 	ldr	r0, [r5, #-32]
fffd3d7c:	e1e0c00c 	mvn	r12, r12
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3d80:	e6ff3073 	uxth	r3, r3

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
fffd3d84:	e5148024 	ldr	r8, [r4, #-36]	; 0x24
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3d88:	e6efc07c 	uxtb	r12, r12
			UINT32 l_actual = g_DataReadBuff[index];
fffd3d8c:	e5146020 	ldr	r6, [r4, #-32]
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
				result_16 |= temp_result_16;
fffd3d90:	e1823003 	orr	r3, r2, r3
fffd3d94:	11a02003 	movne	r2, r3
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3d98:	e02e3009 	eor	r3, lr, r9
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3d9c:	e1833823 	orr	r3, r3, r3, lsr #16
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3da0:	e1e00000 	mvn	r0, r0
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3da4:	e02c1008 	eor	r1, r12, r8
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3da8:	e6ef0070 	uxtb	r0, r0
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3dac:	e1833403 	orr	r3, r3, r3, lsl #8
fffd3db0:	e15e0009 	cmp	lr, r9
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3db4:	e1811821 	orr	r1, r1, r1, lsr #16
fffd3db8:	e2855020 	add	r5, r5, #32
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3dbc:	e6ff3073 	uxth	r3, r3
fffd3dc0:	e2844020 	add	r4, r4, #32
fffd3dc4:	e1811401 	orr	r1, r1, r1, lsl #8
				result_16 |= temp_result_16;
fffd3dc8:	e1823003 	orr	r3, r2, r3
fffd3dcc:	11a02003 	movne	r2, r3
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3dd0:	e0203006 	eor	r3, r0, r6
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3dd4:	e1833823 	orr	r3, r3, r3, lsr #16
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3dd8:	e6ff1071 	uxth	r1, r1
fffd3ddc:	e1833403 	orr	r3, r3, r3, lsl #8
fffd3de0:	e15c0008 	cmp	r12, r8
				result_16 |= temp_result_16;
fffd3de4:	e1821001 	orr	r1, r2, r1
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3de8:	e6ff3073 	uxth	r3, r3
fffd3dec:	01a0c002 	moveq	r12, r2
fffd3df0:	11a0c001 	movne	r12, r1
				result_16 |= temp_result_16;
fffd3df4:	e18c3003 	orr	r3, r12, r3
fffd3df8:	e1500006 	cmp	r0, r6
fffd3dfc:	01a0900c 	moveq	r9, r12
fffd3e00:	11a09003 	movne	r9, r3
fffd3e04:	e35a0078 	cmp	r10, #120	; 0x78
fffd3e08:	1affff99 	bne	fffd3c74 <MemStressTest+0xb98>
fffd3e0c:	e1a03007 	mov	r3, r7
		// read anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3e10:	e59de028 	ldr	lr, [sp, #40]	; 0x28
fffd3e14:	e2834101 	add	r4, r3, #1073741824	; 0x40000000
fffd3e18:	e59d3004 	ldr	r3, [sp, #4]
fffd3e1c:	e2844077 	add	r4, r4, #119	; 0x77
fffd3e20:	e59d7040 	ldr	r7, [sp, #64]	; 0x40
fffd3e24:	e59d0014 	ldr	r0, [sp, #20]
fffd3e28:	e1a01009 	mov	r1, r9
fffd3e2c:	e0834104 	add	r4, r3, r4, lsl #2
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3e30:	e5b02004 	ldr	r2, [r0, #4]!
			UINT32 l_actual = g_DataReadBuff[index];
fffd3e34:	e5bec004 	ldr	r12, [lr, #4]!
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
		{
			UINT32 l_expected = (UINT8)(~g_DataWrite1Buff[index]);
fffd3e38:	e1e02002 	mvn	r2, r2
fffd3e3c:	e6ef2072 	uxtb	r2, r2
			UINT32 l_actual = g_DataReadBuff[index];
			if (l_actual!=l_expected)
			{
				temp_result_32 = l_actual ^ l_expected;
fffd3e40:	e022300c 	eor	r3, r2, r12
fffd3e44:	e152000c 	cmp	r2, r12
				temp_result_16 = (UINT16)(temp_result_32) | (UINT16)((temp_result_32>>16));
fffd3e48:	e1833823 	orr	r3, r3, r3, lsr #16
				temp_result_16 |= temp_result_16<<8; // copy the LSB status into MSB since we display 16 bit but test 8 bit data
fffd3e4c:	e1833403 	orr	r3, r3, r3, lsl #8
fffd3e50:	e6ff3073 	uxth	r3, r3
				result_16 |= temp_result_16;
fffd3e54:	e1813003 	orr	r3, r1, r3
fffd3e58:	11a01003 	movne	r1, r3
		// read anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3e5c:	e1500004 	cmp	r0, r4
fffd3e60:	1afffff2 	bne	fffd3e30 <MemStressTest+0xd54>
						LogPass  (" Retry read:0x%08lX; \n",l_actual);
				}
			}
		}

		l_NumOfLoops++;
fffd3e64:	e59d301c 	ldr	r3, [sp, #28]
		// read anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			g_DataReadBuff[index] = HW_BYTE(g_AddrBuff[index]);

		// verify anti-pattern
		for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3e68:	e1a09001 	mov	r9, r1
						LogPass  (" Retry read:0x%08lX; \n",l_actual);
				}
			}
		}

		l_NumOfLoops++;
fffd3e6c:	e2833001 	add	r3, r3, #1
	UINT32 temp_result_32;
	UINT32 Temp_addr;

	while (1)
	{
		if (l_NumOfLoops>=NumOfLoops)
fffd3e70:	e3530f4b 	cmp	r3, #300	; 0x12c
						LogPass  (" Retry read:0x%08lX; \n",l_actual);
				}
			}
		}

		l_NumOfLoops++;
fffd3e74:	e58d301c 	str	r3, [sp, #28]
	UINT32 temp_result_32;
	UINT32 Temp_addr;

	while (1)
	{
		if (l_NumOfLoops>=NumOfLoops)
fffd3e78:	0a000077 	beq	fffd405c <MemStressTest+0xf80>
			break;

		// stop the test in scan mode (Silent mode) when all bits are with errors 
		if ((IsSilent==TRUE) && ((result_16==0xFFFF)))
fffd3e7c:	e30f3fff 	movw	r3, #65535	; 0xffff
fffd3e80:	e1590003 	cmp	r9, r3
fffd3e84:	0afffe0b 	beq	fffd36b8 <MemStressTest+0x5dc>
		}
		*/

		//---------------------------------------------------------
		// fill a buffer data/address pairs 
		if ((l_NumOfLoops&3) == 0)
fffd3e88:	e59d301c 	ldr	r3, [sp, #28]
fffd3e8c:	e213a003 	ands	r10, r3, #3
fffd3e90:	0afffe8c 	beq	fffd38c8 <MemStressTest+0x7ec>
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
			}
		}
		else if ((l_NumOfLoops&3) == 1)
fffd3e94:	e35a0001 	cmp	r10, #1
fffd3e98:	0a000050 	beq	fffd3fe0 <MemStressTest+0xf04>
fffd3e9c:	e59d6004 	ldr	r6, [sp, #4]
fffd3ea0:	e3a05000 	mov	r5, #0
fffd3ea4:	e59d4020 	ldr	r4, [sp, #32]
fffd3ea8:	e1a08005 	mov	r8, r5
fffd3eac:	e1a0a00b 	mov	r10, r11
fffd3eb0:	e58d9040 	str	r9, [sp, #64]	; 0x40
fffd3eb4:	e58d7044 	str	r7, [sp, #68]	; 0x44
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3eb8:	eb00032c 	bl	fffd4b70 <rand_8bit>
fffd3ebc:	e59d2004 	ldr	r2, [sp, #4]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3ec0:	e2853601 	add	r3, r5, #1048576	; 0x100000
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3ec4:	e7d40100 	ldrb	r0, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3ec8:	e2833001 	add	r3, r3, #1
fffd3ecc:	f5d6f028 	pld	[r6, #40]	; 0x28
fffd3ed0:	e2857501 	add	r7, r5, #4194304	; 0x400000
fffd3ed4:	f5daf028 	pld	[r10, #40]	; 0x28
fffd3ed8:	e2689078 	rsb	r9, r8, #120	; 0x78
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3edc:	e7820108 	str	r0, [r2, r8, lsl #2]
fffd3ee0:	e28aa020 	add	r10, r10, #32
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3ee4:	e78b3108 	str	r3, [r11, r8, lsl #2]
fffd3ee8:	e2888008 	add	r8, r8, #8
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3eec:	eb00031f 	bl	fffd4b70 <rand_8bit>
fffd3ef0:	e7d40100 	ldrb	r0, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3ef4:	e2853706 	add	r3, r5, #1572864	; 0x180000
fffd3ef8:	e2833001 	add	r3, r3, #1
fffd3efc:	e2866020 	add	r6, r6, #32
fffd3f00:	e50a301c 	str	r3, [r10, #-28]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3f04:	e506001c 	str	r0, [r6, #-28]
fffd3f08:	eb000318 	bl	fffd4b70 <rand_8bit>
fffd3f0c:	e7d40100 	ldrb	r0, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3f10:	e2853602 	add	r3, r5, #2097152	; 0x200000
fffd3f14:	e2833001 	add	r3, r3, #1
fffd3f18:	e50a3018 	str	r3, [r10, #-24]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3f1c:	e5060018 	str	r0, [r6, #-24]
fffd3f20:	eb000312 	bl	fffd4b70 <rand_8bit>
fffd3f24:	e7d40100 	ldrb	r0, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3f28:	e285370a 	add	r3, r5, #2621440	; 0x280000
fffd3f2c:	e2833001 	add	r3, r3, #1
fffd3f30:	e50a3014 	str	r3, [r10, #-20]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3f34:	e5060014 	str	r0, [r6, #-20]
fffd3f38:	eb00030c 	bl	fffd4b70 <rand_8bit>
fffd3f3c:	e7d40100 	ldrb	r0, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3f40:	e2853603 	add	r3, r5, #3145728	; 0x300000
fffd3f44:	e2833001 	add	r3, r3, #1
fffd3f48:	e50a3010 	str	r3, [r10, #-16]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3f4c:	e5060010 	str	r0, [r6, #-16]
fffd3f50:	eb000306 	bl	fffd4b70 <rand_8bit>
fffd3f54:	e7d40100 	ldrb	r0, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3f58:	e285370e 	add	r3, r5, #3670016	; 0x380000
fffd3f5c:	e2833001 	add	r3, r3, #1
fffd3f60:	e2855712 	add	r5, r5, #4718592	; 0x480000
fffd3f64:	e50a300c 	str	r3, [r10, #-12]
fffd3f68:	e2855001 	add	r5, r5, #1
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3f6c:	e506000c 	str	r0, [r6, #-12]
fffd3f70:	eb0002fe 	bl	fffd4b70 <rand_8bit>
fffd3f74:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3f78:	e2870001 	add	r0, r7, #1
fffd3f7c:	e50a0008 	str	r0, [r10, #-8]
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3f80:	e5063008 	str	r3, [r6, #-8]
fffd3f84:	eb0002f9 	bl	fffd4b70 <rand_8bit>
fffd3f88:	e7d43100 	ldrb	r3, [r4, r0, lsl #2]
fffd3f8c:	e3580078 	cmp	r8, #120	; 0x78
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3f90:	e50a5004 	str	r5, [r10, #-4]
fffd3f94:	e1a05007 	mov	r5, r7
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3f98:	e5063004 	str	r3, [r6, #-4]
fffd3f9c:	1affffc5 	bne	fffd3eb8 <MemStressTest+0xddc>
fffd3fa0:	e1a04009 	mov	r4, r9
fffd3fa4:	e59d7044 	ldr	r7, [sp, #68]	; 0x44
fffd3fa8:	e59d9040 	ldr	r9, [sp, #64]	; 0x40
			}
		}
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3fac:	e3a05001 	mov	r5, #1
fffd3fb0:	e59d6014 	ldr	r6, [sp, #20]
fffd3fb4:	e28b8f77 	add	r8, r11, #476	; 0x1dc
fffd3fb8:	e59da02c 	ldr	r10, [sp, #44]	; 0x2c
fffd3fbc:	e34053d0 	movt	r5, #976	; 0x3d0
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3fc0:	eb0002ea 	bl	fffd4b70 <rand_8bit>
fffd3fc4:	e7da3100 	ldrb	r3, [r10, r0, lsl #2]
			}
		}
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3fc8:	e2544001 	subs	r4, r4, #1
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + (L2_CACHE_SIZE_IN_BYTE * index) + 1;
fffd3fcc:	e5a85004 	str	r5, [r8, #4]!
fffd3fd0:	e2855702 	add	r5, r5, #524288	; 0x80000
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3fd4:	e5a63004 	str	r3, [r6, #4]!
			}
		}
		else
		{
			// option 3: jump in L2 cache size (good when d-cache is on but not for DM testing since it read/write to a line address)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd3fd8:	1afffff8 	bne	fffd3fc0 <MemStressTest+0xee4>
fffd3fdc:	eafffe7d 	b	fffd39d8 <MemStressTest+0x8fc>
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				g_AddrBuff[index] = DDR_ADDR_BASE + index;
			}
		}
		else if ((l_NumOfLoops&3) == 1)
fffd3fe0:	e59d600c 	ldr	r6, [sp, #12]
fffd3fe4:	e3a04000 	mov	r4, #0
fffd3fe8:	e59d5030 	ldr	r5, [sp, #48]	; 0x30
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
			{
				g_DataWrite1Buff[index] = (UINT8) Golden_Numbers[rand_8bit()]; 
fffd3fec:	eb0002df 	bl	fffd4b70 <rand_8bit>
fffd3ff0:	e59d3008 	ldr	r3, [sp, #8]
fffd3ff4:	e7d33100 	ldrb	r3, [r3, r0, lsl #2]
fffd3ff8:	e5a53004 	str	r3, [r5, #4]!
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				// get random address and verify it does not exist in the buffer. 
				UINT32 index2 = (-1);
				while (index2 == (-1))
				{
					Temp_addr = ((rand_32bit()&DDR_ADDR_MASK) + DDR_ADDR_BASE) | 1/*aline to BYTE*/;
fffd3ffc:	eb0002e6 	bl	fffd4b9c <rand_32bit>
					// make sure this new address is not in the list
					for (index2=0; index2<index; index2++)
fffd4000:	e3540000 	cmp	r4, #0
				//g_DataWrite2Buff[index] = (UINT8) ~g_DataWrite1Buff[index];
				// get random address and verify it does not exist in the buffer. 
				UINT32 index2 = (-1);
				while (index2 == (-1))
				{
					Temp_addr = ((rand_32bit()&DDR_ADDR_MASK) + DDR_ADDR_BASE) | 1/*aline to BYTE*/;
fffd4004:	e3c0033f 	bic	r0, r0, #-67108864	; 0xfc000000
fffd4008:	e2801601 	add	r1, r0, #1048576	; 0x100000
fffd400c:	e3811001 	orr	r1, r1, #1
					// make sure this new address is not in the list
					for (index2=0; index2<index; index2++)
fffd4010:	0a00000e 	beq	fffd4050 <MemStressTest+0xf74>
					{
						if (g_AddrBuff[index2]==Temp_addr)
fffd4014:	e59b3000 	ldr	r3, [r11]
fffd4018:	e1510003 	cmp	r1, r3
fffd401c:	0afffff6 	beq	fffd3ffc <MemStressTest+0xf20>
fffd4020:	e1a0300b 	mov	r3, r11
fffd4024:	ea000002 	b	fffd4034 <MemStressTest+0xf58>
fffd4028:	e5b32004 	ldr	r2, [r3, #4]!
fffd402c:	e1510002 	cmp	r1, r2
fffd4030:	0afffff1 	beq	fffd3ffc <MemStressTest+0xf20>
				UINT32 index2 = (-1);
				while (index2 == (-1))
				{
					Temp_addr = ((rand_32bit()&DDR_ADDR_MASK) + DDR_ADDR_BASE) | 1/*aline to BYTE*/;
					// make sure this new address is not in the list
					for (index2=0; index2<index; index2++)
fffd4034:	e1530006 	cmp	r3, r6
fffd4038:	1afffffa 	bne	fffd4028 <MemStressTest+0xf4c>
			}
		}
		else if ((l_NumOfLoops&3) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd403c:	e2844001 	add	r4, r4, #1
							index2 = (-1);
							break;
						}
					}
				}
				g_AddrBuff[index] = Temp_addr;  // add this random address to the list
fffd4040:	e5a61004 	str	r1, [r6, #4]!
			}
		}
		else if ((l_NumOfLoops&3) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd4044:	e3540080 	cmp	r4, #128	; 0x80
fffd4048:	1affffe7 	bne	fffd3fec <MemStressTest+0xf10>
fffd404c:	eafffe61 	b	fffd39d8 <MemStressTest+0x8fc>
							index2 = (-1);
							break;
						}
					}
				}
				g_AddrBuff[index] = Temp_addr;  // add this random address to the list
fffd4050:	e5a61004 	str	r1, [r6, #4]!
			}
		}
		else if ((l_NumOfLoops&3) == 1)
		{
			// option 2: random address (good when d-cache is off)
			for (index=0; index<TEST_BLOCK_SIZE_IN_DWORD; index++)
fffd4054:	e3a04001 	mov	r4, #1
fffd4058:	eaffffe3 	b	fffd3fec <MemStressTest+0xf10>
fffd405c:	e59da03c 	ldr	r10, [sp, #60]	; 0x3c
	}
	//------------------------------------------------------

	//------------------------------------------------------
	status |= Run_MemTest_Type5_byte (300, TRUE);
	if (status==0xFFFF)
fffd4060:	e30f3fff 	movw	r3, #65535	; 0xffff
		return (status);
	}
	//------------------------------------------------------

	//------------------------------------------------------
	status |= Run_MemTest_Type5_byte (300, TRUE);
fffd4064:	e181000a 	orr	r0, r1, r10
fffd4068:	e6ff0070 	uxth	r0, r0
	if (status==0xFFFF)
fffd406c:	e1500003 	cmp	r0, r3
fffd4070:	0afffd90 	beq	fffd36b8 <MemStressTest+0x5dc>
		g_SkipDataAbort = FALSE;
		return (status);
	}
	//------------------------------------------------------

	g_SkipDataAbort = FALSE;
fffd4074:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
fffd4078:	e3a03000 	mov	r3, #0
fffd407c:	e5823000 	str	r3, [r2]
	return (status);
}
fffd4080:	e28dd04c 	add	sp, sp, #76	; 0x4c
fffd4084:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
fffd4088:	00003bb0 	.word	0x00003bb0
fffd408c:	00004178 	.word	0x00004178
fffd4090:	00003b98 	.word	0x00003b98
fffd4094:	00003b90 	.word	0x00003b90
fffd4098:	00000034 	.word	0x00000034
fffd409c:	00003b70 	.word	0x00003b70
fffd40a0:	00000028 	.word	0x00000028
fffd40a4:	00000050 	.word	0x00000050
fffd40a8:	00000054 	.word	0x00000054
fffd40ac:	00000058 	.word	0x00000058
fffd40b0:	00003a30 	.word	0x00003a30
fffd40b4:	00003414 	.word	0x00003414
fffd40b8:	00003408 	.word	0x00003408
fffd40bc:	000033fc 	.word	0x000033fc
fffd40c0:	000033f0 	.word	0x000033f0
fffd40c4:	000032f0 	.word	0x000032f0

fffd40c8 <PutUnsignedInt>:

    /* Take current digit into account when calculating width */
    width--;

    /* Recursively write upper digits */
    if ((value / 10) > 0)
fffd40c8:	e3530009 	cmp	r3, #9
 * @param  fill  Fill character.
 * @param  width  Minimum integer width.
 * @param  value  Integer value.
 */
static signed int PutUnsignedInt(char *pStr, char fill, signed int width, unsigned long int value)
{
fffd40cc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    signed int num = 0;

    /* Take current digit into account when calculating width */
    width--;
fffd40d0:	e2422001 	sub	r2, r2, #1
 * @param  fill  Fill character.
 * @param  width  Minimum integer width.
 * @param  value  Integer value.
 */
static signed int PutUnsignedInt(char *pStr, char fill, signed int width, unsigned long int value)
{
fffd40d4:	e1a04003 	mov	r4, r3
fffd40d8:	e1a05000 	mov	r5, r0
fffd40dc:	91a0c001 	movls	r12, r1

    /* Take current digit into account when calculating width */
    width--;

    /* Recursively write upper digits */
    if ((value / 10) > 0)
fffd40e0:	91a03000 	movls	r3, r0
fffd40e4:	9a000005 	bls	fffd4100 <PutUnsignedInt+0x38>
    {
        num = PutUnsignedInt (pStr, fill, width, value / 10);
fffd40e8:	e59f604c 	ldr	r6, [pc, #76]	; fffd413c <PutUnsignedInt+0x74>
fffd40ec:	e0876694 	umull	r6, r7, r4, r6
fffd40f0:	e1a031a7 	lsr	r3, r7, #3
fffd40f4:	ebfffff3 	bl	fffd40c8 <PutUnsignedInt>
        pStr += num;
fffd40f8:	e0851000 	add	r1, r5, r0
fffd40fc:	ea000005 	b	fffd4118 <PutUnsignedInt+0x50>
    }

    /* Write filler characters */
    else
    {
        while (width > 0)
fffd4100:	e3520000 	cmp	r2, #0
fffd4104:	e0650003 	rsb	r0, r5, r3
fffd4108:	e1a01003 	mov	r1, r3
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
static signed int PutChar(char *pStr, char c)
{
    *pStr = c;
fffd410c:	c4c3c001 	strbgt	r12, [r3], #1
        while (width > 0)
        {
            PutChar(pStr, fill);
            pStr++;
            num++;
            width--;
fffd4110:	c2422001 	subgt	r2, r2, #1
fffd4114:	cafffff9 	bgt	fffd4100 <PutUnsignedInt+0x38>
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (value % 10) + '0');
fffd4118:	e59f201c 	ldr	r2, [pc, #28]	; fffd413c <PutUnsignedInt+0x74>

    return num;
}
fffd411c:	e2800001 	add	r0, r0, #1
            width--;
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (value % 10) + '0');
fffd4120:	e0832294 	umull	r2, r3, r4, r2
fffd4124:	e3a0200a 	mov	r2, #10
fffd4128:	e1a031a3 	lsr	r3, r3, #3
fffd412c:	e0634392 	mls	r3, r2, r3, r4
fffd4130:	e2833030 	add	r3, r3, #48	; 0x30
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
static signed int PutChar(char *pStr, char c)
{
    *pStr = c;
fffd4134:	e5c13000 	strb	r3, [r1]

    /* Write lower digit */
    num += PutChar(pStr, (value % 10) + '0');

    return num;
}
fffd4138:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
fffd413c:	cccccccd 	.word	0xcccccccd

fffd4140 <PutSignedInt>:
 * @param fill   Fill character.
 * @param width  Minimum integer width.
 * @param value  Signed integer value.
 */
static signed int PutSignedInt(char *pStr, char fill, signed int width, signed long int value)
{
fffd4140:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    signed int num = 0;
    unsigned long int absolute;

    /* Compute absolute value */
    if (value < 0)
        absolute = -value;
fffd4144:	e0236fc3 	eor	r6, r3, r3, asr #31
 * @param fill   Fill character.
 * @param width  Minimum integer width.
 * @param value  Signed integer value.
 */
static signed int PutSignedInt(char *pStr, char fill, signed int width, signed long int value)
{
fffd4148:	e1a0c002 	mov	r12, r2
    signed int num = 0;
    unsigned long int absolute;

    /* Compute absolute value */
    if (value < 0)
        absolute = -value;
fffd414c:	e0466fc3 	sub	r6, r6, r3, asr #31
 * @param fill   Fill character.
 * @param width  Minimum integer width.
 * @param value  Signed integer value.
 */
static signed int PutSignedInt(char *pStr, char fill, signed int width, signed long int value)
{
fffd4150:	e1a07000 	mov	r7, r0
        absolute = -value;
    else
        absolute = value;

    /* Take current digit into account when calculating width */
    width--;
fffd4154:	e2422001 	sub	r2, r2, #1

    /* Recursively write upper digits */
    if ((absolute / 10) > 0)
fffd4158:	e3560009 	cmp	r6, #9
fffd415c:	9a000007 	bls	fffd4180 <PutSignedInt+0x40>
fffd4160:	e59f4080 	ldr	r4, [pc, #128]	; fffd41e8 <PutSignedInt+0xa8>
    {
        if (value < 0)
fffd4164:	e3530000 	cmp	r3, #0
        {
            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
fffd4168:	e0854496 	umull	r4, r5, r6, r4
fffd416c:	e1a031a5 	lsr	r3, r5, #3
fffd4170:	b2633000 	rsblt	r3, r3, #0
        }
        else
        {
            num = PutSignedInt(pStr, fill, width, absolute / 10);
fffd4174:	ebfffff1 	bl	fffd4140 <PutSignedInt>
        }
        pStr += num;
fffd4178:	e0872000 	add	r2, r7, r0
fffd417c:	ea000010 	b	fffd41c4 <PutSignedInt+0x84>
    }
    else
    {

        /* Reserve space for sign */
        if (value < 0)
fffd4180:	e3530000 	cmp	r3, #0
fffd4184:	e1a0e001 	mov	lr, r1
        {
            width--;
fffd4188:	b24c2002 	sublt	r2, r12, #2
fffd418c:	e2400001 	sub	r0, r0, #1
fffd4190:	e2421001 	sub	r1, r2, #1
fffd4194:	e0601001 	rsb	r1, r0, r1
fffd4198:	e0871001 	add	r1, r7, r1
        }

        /* Write filler characters */
        while (width > 0)
fffd419c:	e3510000 	cmp	r1, #0
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
static signed int PutChar(char *pStr, char c)
{
    *pStr = c;
fffd41a0:	c5e0e001 	strbgt	lr, [r0, #1]!
fffd41a4:	cafffff9 	bgt	fffd4190 <PutSignedInt+0x50>
fffd41a8:	e1c20fc2 	bic	r0, r2, r2, asr #31
            num++;
            width--;
        }

        /* Write sign */
        if (value < 0)
fffd41ac:	e3530000 	cmp	r3, #0
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
static signed int PutChar(char *pStr, char c)
{
    *pStr = c;
fffd41b0:	b3a0302d 	movlt	r3, #45	; 0x2d
fffd41b4:	e0872000 	add	r2, r7, r0
fffd41b8:	b7c73000 	strblt	r3, [r7, r0]

        /* Write sign */
        if (value < 0)
        {
            num += PutChar(pStr, '-');
            pStr++;
fffd41bc:	b2822001 	addlt	r2, r2, #1
        }

        /* Write sign */
        if (value < 0)
        {
            num += PutChar(pStr, '-');
fffd41c0:	b2800001 	addlt	r0, r0, #1
            pStr++;
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (absolute % 10) + '0');
fffd41c4:	e59f401c 	ldr	r4, [pc, #28]	; fffd41e8 <PutSignedInt+0xa8>
fffd41c8:	e3a0100a 	mov	r1, #10

    return num;
}
fffd41cc:	e2800001 	add	r0, r0, #1
            pStr++;
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (absolute % 10) + '0');
fffd41d0:	e0854496 	umull	r4, r5, r6, r4
fffd41d4:	e1a031a5 	lsr	r3, r5, #3
fffd41d8:	e0636391 	mls	r3, r1, r3, r6
fffd41dc:	e2833030 	add	r3, r3, #48	; 0x30
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
static signed int PutChar(char *pStr, char c)
{
    *pStr = c;
fffd41e0:	e5c23000 	strb	r3, [r2]

    /* Write lower digit */
    num += PutChar(pStr, (absolute % 10) + '0');

    return num;
}
fffd41e4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
fffd41e8:	cccccccd 	.word	0xcccccccd

fffd41ec <PutHexa>:
 * @param value  Hexadecimal value.
 *
 * @return  The number of char written
 */
static signed int PutHexa (char *pStr, char fill, signed int width, unsigned char maj, unsigned long int value)
{
fffd41ec:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
    signed int num = 0;

    /* Decrement width */
    width--;
fffd41f0:	e2422001 	sub	r2, r2, #1
 * @param value  Hexadecimal value.
 *
 * @return  The number of char written
 */
static signed int PutHexa (char *pStr, char fill, signed int width, unsigned char maj, unsigned long int value)
{
fffd41f4:	e59d4018 	ldr	r4, [sp, #24]
fffd41f8:	e1a06003 	mov	r6, r3
fffd41fc:	e1a05000 	mov	r5, r0

    /* Decrement width */
    width--;

    /* Recursively output upper digits */
    if ((value >> 4) > 0)
fffd4200:	e1b0e224 	lsrs	lr, r4, #4
fffd4204:	01a0c001 	moveq	r12, r1
fffd4208:	01a03000 	moveq	r3, r0
fffd420c:	0a000003 	beq	fffd4220 <PutHexa+0x34>
    {

        num += PutHexa(pStr, fill, width, maj, value >> 4);
fffd4210:	e58de000 	str	lr, [sp]
fffd4214:	ebfffff4 	bl	fffd41ec <PutHexa>
        pStr += num;
fffd4218:	e0851000 	add	r1, r5, r0
fffd421c:	ea000005 	b	fffd4238 <PutHexa+0x4c>
    }
    /* Write filler chars */
    else
    {

        while (width > 0)
fffd4220:	e3520000 	cmp	r2, #0
fffd4224:	e0650003 	rsb	r0, r5, r3
fffd4228:	e1a01003 	mov	r1, r3
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
static signed int PutChar(char *pStr, char c)
{
    *pStr = c;
fffd422c:	c4c3c001 	strbgt	r12, [r3], #1
        while (width > 0)
        {
            PutChar(pStr, fill);
            pStr++;
            num++;
            width--;
fffd4230:	c2422001 	subgt	r2, r2, #1
fffd4234:	cafffff9 	bgt	fffd4220 <PutHexa+0x34>
        }
    }

    /* Write current digit */
    if ((value & 0xF) < 10)
fffd4238:	e204300f 	and	r3, r4, #15
fffd423c:	e3530009 	cmp	r3, #9
    {
        PutChar(pStr, (value & 0xF) + '0');
fffd4240:	92833030 	addls	r3, r3, #48	; 0x30
            width--;
        }
    }

    /* Write current digit */
    if ((value & 0xF) < 10)
fffd4244:	9a000002 	bls	fffd4254 <PutHexa+0x68>
    {
        PutChar(pStr, (value & 0xF) + '0');
    }
    else if (maj)
fffd4248:	e3560000 	cmp	r6, #0
    {
        PutChar(pStr, (value & 0xF) - 10 + 'A');
fffd424c:	12833037 	addne	r3, r3, #55	; 0x37
    }
    else
    {
        PutChar(pStr, (value & 0xF) - 10 + 'a');
fffd4250:	02833057 	addeq	r3, r3, #87	; 0x57
    }
    num++;

    return num;
}
fffd4254:	e2800001 	add	r0, r0, #1
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
static signed int PutChar(char *pStr, char c)
{
    *pStr = c;
fffd4258:	e5c13000 	strb	r3, [r1]
        PutChar(pStr, (value & 0xF) - 10 + 'a');
    }
    num++;

    return num;
}
fffd425c:	e28dd008 	add	sp, sp, #8
fffd4260:	e8bd8070 	pop	{r4, r5, r6, pc}

fffd4264 <vsnprintf>:
 * @param ap      Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsnprintf (char *pStr, size_t length, const char *pFormat, va_list ap)
{
fffd4264:	e92d43f7 	push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    unsigned char width;
    signed int    num = 0;
    signed int    size = 0;
    unsigned char Size_Prefixes = 0;

    if (pStr==NULL)
fffd4268:	e2504000 	subs	r4, r0, #0
fffd426c:	e3a07000 	mov	r7, #0
fffd4270:	11a08001 	movne	r8, r1
signed int vsnprintf (char *pStr, size_t length, const char *pFormat, va_list ap)
{
    char          fill;
    unsigned char width;
    signed int    num = 0;
    signed int    size = 0;
fffd4274:	11a06007 	movne	r6, r7

    if (pStr==NULL)
    	return 0;

    /* Clear the string */
    *pStr = 0;
fffd4278:	15c47000 	strbne	r7, [r4]
    unsigned char width;
    signed int    num = 0;
    signed int    size = 0;
    unsigned char Size_Prefixes = 0;

    if (pStr==NULL)
fffd427c:	0a00006a 	beq	fffd442c <vsnprintf+0x1c8>

    /* Clear the string */
    *pStr = 0;

    /* Phase string */
    while (*pFormat != 0 && size < length)
fffd4280:	e5d21000 	ldrb	r1, [r2]
fffd4284:	e3510000 	cmp	r1, #0
fffd4288:	1a000006 	bne	fffd42a8 <vsnprintf+0x44>
            size += num;
        }
    }

    /* NULL-terminated (final \0 is not counted) */
    if (size < length)
fffd428c:	e1560008 	cmp	r6, r8
fffd4290:	e3a03000 	mov	r3, #0
    {
        *pStr = 0;
fffd4294:	35c43000 	strbcc	r3, [r4]
fffd4298:	31a00006 	movcc	r0, r6
    }
    else
    {
        *(--pStr) = 0;
fffd429c:	25443001 	strbcs	r3, [r4, #-1]
        size--;
fffd42a0:	22460001 	subcs	r0, r6, #1
fffd42a4:	ea000063 	b	fffd4438 <vsnprintf+0x1d4>

    /* Clear the string */
    *pStr = 0;

    /* Phase string */
    while (*pFormat != 0 && size < length)
fffd42a8:	e1560008 	cmp	r6, r8
fffd42ac:	2afffff6 	bcs	fffd428c <vsnprintf+0x28>
    {
        /* Normal character */
        if (*pFormat != '%')
fffd42b0:	e3510025 	cmp	r1, #37	; 0x25
        {
            *pStr++ = *pFormat++;
fffd42b4:	12822001 	addne	r2, r2, #1
fffd42b8:	15c41000 	strbne	r1, [r4]

    /* Phase string */
    while (*pFormat != 0 && size < length)
    {
        /* Normal character */
        if (*pFormat != '%')
fffd42bc:	1a000004 	bne	fffd42d4 <vsnprintf+0x70>
        {
            *pStr++ = *pFormat++;
            size++;
        }
        /* Escaped '%' */
        else if (*(pFormat+1) == '%')
fffd42c0:	e5d21001 	ldrb	r1, [r2, #1]
fffd42c4:	e3510025 	cmp	r1, #37	; 0x25
fffd42c8:	1a000004 	bne	fffd42e0 <vsnprintf+0x7c>
        {
            *pStr++ = '%';
            pFormat += 2;
fffd42cc:	e2822002 	add	r2, r2, #2
            size++;
        }
        /* Escaped '%' */
        else if (*(pFormat+1) == '%')
        {
            *pStr++ = '%';
fffd42d0:	e5c41000 	strb	r1, [r4]
            pFormat += 2;
            size++;
fffd42d4:	e2866001 	add	r6, r6, #1
            size++;
        }
        /* Escaped '%' */
        else if (*(pFormat+1) == '%')
        {
            *pStr++ = '%';
fffd42d8:	e2844001 	add	r4, r4, #1
fffd42dc:	eaffffe7 	b	fffd4280 <vsnprintf+0x1c>
            fill = ' ';
            width = 0;
            pFormat++;

            /* Parse filler */
            if (*pFormat == '0')
fffd42e0:	e3510030 	cmp	r1, #48	; 0x30
        /* Token delimiter */
        else
        {
            fill = ' ';
            width = 0;
            pFormat++;
fffd42e4:	12820001 	addne	r0, r2, #1

            /* Parse filler */
            if (*pFormat == '0')
            {
                fill = '0';
                pFormat++;
fffd42e8:	02820002 	addeq	r0, r2, #2
            size++;
        }
        /* Token delimiter */
        else
        {
            fill = ' ';
fffd42ec:	13a01020 	movne	r1, #32
fffd42f0:	e3a02000 	mov	r2, #0
                fill = '0';
                pFormat++;
            }

            /* Parse width */
            while ((*pFormat >= '0') && (*pFormat <= '9'))
fffd42f4:	e5d0c000 	ldrb	r12, [r0]
fffd42f8:	e1a09000 	mov	r9, r0
fffd42fc:	e2800001 	add	r0, r0, #1
fffd4300:	e24ce030 	sub	lr, r12, #48	; 0x30
fffd4304:	e35e0009 	cmp	lr, #9
            {

                width = (width*10) + *pFormat-'0';
fffd4308:	90822102 	addls	r2, r2, r2, lsl #2
fffd430c:	908c2082 	addls	r2, r12, r2, lsl #1
fffd4310:	92422030 	subls	r2, r2, #48	; 0x30
fffd4314:	920220ff 	andls	r2, r2, #255	; 0xff
fffd4318:	9afffff5 	bls	fffd42f4 <vsnprintf+0x90>
                pFormat++;
            }

            /* Check if there is enough space */
            if (size + width > length)
fffd431c:	e0860002 	add	r0, r6, r2
fffd4320:	e1500008 	cmp	r0, r8
            {
                width = length - size;
fffd4324:	80662008 	rsbhi	r2, r6, r8
fffd4328:	86ef2072 	uxtbhi	r2, r2
            }

            // check Size Prefixes (long int) (goes with d, i,u,x and X type)
            if (*pFormat == 'l')
fffd432c:	e35c006c 	cmp	r12, #108	; 0x6c
            {
            	Size_Prefixes = 1;
            	pFormat++;
fffd4330:	02899001 	addeq	r9, r9, #1
            }


            /* Parse type */
            switch (*pFormat)
fffd4334:	e5d90000 	ldrb	r0, [r9]
            }

            // check Size Prefixes (long int) (goes with d, i,u,x and X type)
            if (*pFormat == 'l')
            {
            	Size_Prefixes = 1;
fffd4338:	03a07001 	moveq	r7, #1
            	pFormat++;
            }


            /* Parse type */
            switch (*pFormat)
fffd433c:	e3500069 	cmp	r0, #105	; 0x69
fffd4340:	0a000019 	beq	fffd43ac <vsnprintf+0x148>
fffd4344:	8a00000d 	bhi	fffd4380 <vsnprintf+0x11c>
fffd4348:	e3500063 	cmp	r0, #99	; 0x63
fffd434c:	0a00002d 	beq	fffd4408 <vsnprintf+0x1a4>
fffd4350:	e3500064 	cmp	r0, #100	; 0x64
fffd4354:	0a000014 	beq	fffd43ac <vsnprintf+0x148>
fffd4358:	e3500058 	cmp	r0, #88	; 0x58
fffd435c:	1a000034 	bne	fffd4434 <vsnprintf+0x1d0>
fffd4360:	e2835004 	add	r5, r3, #4
					else
						num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int));
					break;
				case 'X':
					if (Size_Prefixes==1)
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned long int));
fffd4364:	e5933000 	ldr	r3, [r3]
						num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned long int));
					else
						num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int));
					break;
				case 'X':
					if (Size_Prefixes==1)
fffd4368:	e3570001 	cmp	r7, #1
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned long int));
fffd436c:	e1a00004 	mov	r0, r4
fffd4370:	e58d3000 	str	r3, [sp]
					else
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int));
fffd4374:	13a03001 	movne	r3, #1
					else
						num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int));
					break;
				case 'X':
					if (Size_Prefixes==1)
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned long int));
fffd4378:	01a03007 	moveq	r3, r7
fffd437c:	ea000019 	b	fffd43e8 <vsnprintf+0x184>
            	pFormat++;
            }


            /* Parse type */
            switch (*pFormat)
fffd4380:	e3500075 	cmp	r0, #117	; 0x75
fffd4384:	0a00000d 	beq	fffd43c0 <vsnprintf+0x15c>
fffd4388:	e3500078 	cmp	r0, #120	; 0x78
fffd438c:	0a000010 	beq	fffd43d4 <vsnprintf+0x170>
fffd4390:	e3500073 	cmp	r0, #115	; 0x73
fffd4394:	1a000026 	bne	fffd4434 <vsnprintf+0x1d0>
					if (Size_Prefixes==1)
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned long int));
					else
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int));
					break;
				case 's': num = PutString(pStr, va_arg(ap, char *)); break;
fffd4398:	e2835004 	add	r5, r3, #4
fffd439c:	e5933000 	ldr	r3, [r3]
fffd43a0:	e1a02004 	mov	r2, r4
fffd43a4:	e2433001 	sub	r3, r3, #1
fffd43a8:	ea000010 	b	fffd43f0 <vsnprintf+0x18c>
fffd43ac:	e2835004 	add	r5, r3, #4
            switch (*pFormat)
            {
				case 'd':
				case 'i':
						if (Size_Prefixes==1)
							num = PutSignedInt(pStr, fill, width, va_arg(ap, signed long int));
fffd43b0:	e1a00004 	mov	r0, r4
fffd43b4:	e5933000 	ldr	r3, [r3]
						else
							num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int));
fffd43b8:	ebffff60 	bl	fffd4140 <PutSignedInt>
fffd43bc:	ea000015 	b	fffd4418 <vsnprintf+0x1b4>
fffd43c0:	e2835004 	add	r5, r3, #4
						break;
				case 'u':
					if (Size_Prefixes==1)
						num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned long int));
fffd43c4:	e1a00004 	mov	r0, r4
fffd43c8:	e5933000 	ldr	r3, [r3]
					else
						num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned int));
fffd43cc:	ebffff3d 	bl	fffd40c8 <PutUnsignedInt>
fffd43d0:	ea000010 	b	fffd4418 <vsnprintf+0x1b4>
fffd43d4:	e2835004 	add	r5, r3, #4
					break;
				case 'x':
					if (Size_Prefixes==1)
						num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned long int));
fffd43d8:	e5933000 	ldr	r3, [r3]
fffd43dc:	e1a00004 	mov	r0, r4
fffd43e0:	e58d3000 	str	r3, [sp]
fffd43e4:	e3a03000 	mov	r3, #0
					else
						num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int));
					break;
				case 'X':
					if (Size_Prefixes==1)
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned long int));
fffd43e8:	ebffff7f 	bl	fffd41ec <PutHexa>
fffd43ec:	ea000009 	b	fffd4418 <vsnprintf+0x1b4>
 */
static signed int PutString (char *pStr, const char *pSource)
{
    signed int num = 0;

    while (*pSource != 0)
fffd43f0:	e5f31001 	ldrb	r1, [r3, #1]!
fffd43f4:	e0640002 	rsb	r0, r4, r2
fffd43f8:	e3510000 	cmp	r1, #0
fffd43fc:	0a000005 	beq	fffd4418 <vsnprintf+0x1b4>
    {
        *pStr++ = *pSource++;
fffd4400:	e4c21001 	strb	r1, [r2], #1
fffd4404:	eafffff9 	b	fffd43f0 <vsnprintf+0x18c>
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned long int));
					else
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int));
					break;
				case 's': num = PutString(pStr, va_arg(ap, char *)); break;
				case 'c': num = PutChar(pStr, va_arg(ap, unsigned int)); break;
fffd4408:	e2835004 	add	r5, r3, #4
fffd440c:	e5933000 	ldr	r3, [r3]
fffd4410:	e3a00001 	mov	r0, #1
fffd4414:	e5c43000 	strb	r3, [r4]
				default:
					return EOF;
            }

            pFormat++;
fffd4418:	e2892001 	add	r2, r9, #1
            pStr += num;
fffd441c:	e0844000 	add	r4, r4, r0
            size += num;
fffd4420:	e0866000 	add	r6, r6, r0
fffd4424:	e1a03005 	mov	r3, r5
fffd4428:	eaffff94 	b	fffd4280 <vsnprintf+0x1c>
    signed int    num = 0;
    signed int    size = 0;
    unsigned char Size_Prefixes = 0;

    if (pStr==NULL)
    	return 0;
fffd442c:	e1a00004 	mov	r0, r4
fffd4430:	ea000000 	b	fffd4438 <vsnprintf+0x1d4>
						num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int));
					break;
				case 's': num = PutString(pStr, va_arg(ap, char *)); break;
				case 'c': num = PutChar(pStr, va_arg(ap, unsigned int)); break;
				default:
					return EOF;
fffd4434:	e3e00000 	mvn	r0, #0
        *(--pStr) = 0;
        size--;
    }

    return size;
}
fffd4438:	e28dd00c 	add	sp, sp, #12
fffd443c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

fffd4440 <snprintf>:
 * @param ...     Other arguments
 *
 * @return  The number of characters written.
 */
signed int snprintf (char *pString, size_t length, const char *pFormat, ...)
{
fffd4440:	e92d000c 	push	{r2, r3}
fffd4444:	e92d4007 	push	{r0, r1, r2, lr}
    va_list    ap;
    signed int rc;

    va_start(ap, pFormat);
fffd4448:	e28d3014 	add	r3, sp, #20
    rc = vsnprintf(pString, length, pFormat, ap);
fffd444c:	e59d2010 	ldr	r2, [sp, #16]
signed int snprintf (char *pString, size_t length, const char *pFormat, ...)
{
    va_list    ap;
    signed int rc;

    va_start(ap, pFormat);
fffd4450:	e58d3004 	str	r3, [sp, #4]
    rc = vsnprintf(pString, length, pFormat, ap);
fffd4454:	ebffff82 	bl	fffd4264 <vsnprintf>
    va_end(ap);

    return rc;
}
fffd4458:	e28dd00c 	add	sp, sp, #12
fffd445c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
fffd4460:	e28dd008 	add	sp, sp, #8
fffd4464:	e12fff1e 	bx	lr

fffd4468 <exit>:

__attribute__ ((used))
void exit (int status)
{
  /* Abort called */
	if (status!=0)
fffd4468:	e2504000 	subs	r4, r0, #0
	while(1);
}

__attribute__ ((used))
void exit (int status)
{
fffd446c:	e92d4008 	push	{r3, lr}
  /* Abort called */
	if (status!=0)
fffd4470:	0a00000d 	beq	fffd44ac <exit+0x44>
	{
		LogMessage ("\n\n");
fffd4474:	e59f0068 	ldr	r0, [pc, #104]	; fffd44e4 <exit+0x7c>
		LogError ("**********************************\n");
fffd4478:	e59f5068 	ldr	r5, [pc, #104]	; fffd44e8 <exit+0x80>
void exit (int status)
{
  /* Abort called */
	if (status!=0)
	{
		LogMessage ("\n\n");
fffd447c:	e08f0000 	add	r0, pc, r0
		LogError ("**********************************\n");
fffd4480:	e08f5005 	add	r5, pc, r5
void exit (int status)
{
  /* Abort called */
	if (status!=0)
	{
		LogMessage ("\n\n");
fffd4484:	eb00009c 	bl	fffd46fc <LogMessage>
		LogError ("**********************************\n");
fffd4488:	e1a00005 	mov	r0, r5
fffd448c:	eb0000c6 	bl	fffd47ac <LogError>
		LogError ("   Test exit with error num %d     \n",status);
fffd4490:	e59f0054 	ldr	r0, [pc, #84]	; fffd44ec <exit+0x84>
fffd4494:	e1a01004 	mov	r1, r4
fffd4498:	e08f0000 	add	r0, pc, r0
fffd449c:	eb0000c2 	bl	fffd47ac <LogError>
		LogError ("**********************************\n");
fffd44a0:	e1a00005 	mov	r0, r5
fffd44a4:	eb0000c0 	bl	fffd47ac <LogError>
fffd44a8:	ea00000b 	b	fffd44dc <exit+0x74>
	}
	else
	{
		 LogMessage ("\n\n");
fffd44ac:	e59f003c 	ldr	r0, [pc, #60]	; fffd44f0 <exit+0x88>
		 LogPass ("**********************************\n");
fffd44b0:	e59f503c 	ldr	r5, [pc, #60]	; fffd44f4 <exit+0x8c>
		LogError ("   Test exit with error num %d     \n",status);
		LogError ("**********************************\n");
	}
	else
	{
		 LogMessage ("\n\n");
fffd44b4:	e08f0000 	add	r0, pc, r0
		 LogPass ("**********************************\n");
fffd44b8:	e08f5005 	add	r5, pc, r5
		LogError ("   Test exit with error num %d     \n",status);
		LogError ("**********************************\n");
	}
	else
	{
		 LogMessage ("\n\n");
fffd44bc:	eb00008e 	bl	fffd46fc <LogMessage>
		 LogPass ("**********************************\n");
fffd44c0:	e1a00005 	mov	r0, r5
fffd44c4:	eb0000d8 	bl	fffd482c <LogPass>
		 LogPass ("  Test exit with no errors        \n");
fffd44c8:	e59f0028 	ldr	r0, [pc, #40]	; fffd44f8 <exit+0x90>
fffd44cc:	e08f0000 	add	r0, pc, r0
fffd44d0:	eb0000d5 	bl	fffd482c <LogPass>
		 LogPass ("**********************************\n"); 
fffd44d4:	e1a00005 	mov	r0, r5
fffd44d8:	eb0000d3 	bl	fffd482c <LogPass>
	}

	//__asm__ ("BKPT 0x0000"); 
	_exit (status);
fffd44dc:	e1a00004 	mov	r0, r4
fffd44e0:	ebffef30 	bl	fffd01a8 <_exit>
fffd44e4:	0000184f 	.word	0x0000184f
fffd44e8:	00002cb4 	.word	0x00002cb4
fffd44ec:	00002c2f 	.word	0x00002c2f
fffd44f0:	00001817 	.word	0x00001817
fffd44f4:	00002c7c 	.word	0x00002c7c
fffd44f8:	00002c20 	.word	0x00002c20

fffd44fc <UartInit>:
	UART_NUM_g = UART_Num;
}

//-------------------------------------------------------------
extern void UartInit (void)
{
fffd44fc:	e59f3104 	ldr	r3, [pc, #260]	; fffd4608 <UartInit+0x10c>
	UINT8 LCR;

	while ((READ_REG(UART_LSR(UART_NUM_g))&0x40) == 0x00); // wait for THRE (Transmitter Holding Register Empty) and TSR (Transmitter Shift Register) to be empty.
fffd4500:	e59f2104 	ldr	r2, [pc, #260]	; fffd460c <UartInit+0x110>
	UART_NUM_g = UART_Num;
}

//-------------------------------------------------------------
extern void UartInit (void)
{
fffd4504:	e92d4010 	push	{r4, lr}
fffd4508:	e08f3003 	add	r3, pc, r3
	UINT8 LCR;

	while ((READ_REG(UART_LSR(UART_NUM_g))&0x40) == 0x00); // wait for THRE (Transmitter Holding Register Empty) and TSR (Transmitter Shift Register) to be empty.
fffd450c:	e7934002 	ldr	r4, [r3, r2]
fffd4510:	e59f30f8 	ldr	r3, [pc, #248]	; fffd4610 <UartInit+0x114>
fffd4514:	e5942000 	ldr	r2, [r4]
fffd4518:	e1a02602 	lsl	r2, r2, #12
fffd451c:	e0823003 	add	r3, r2, r3
fffd4520:	e5d32000 	ldrb	r2, [r3]
fffd4524:	e3120040 	tst	r2, #64	; 0x40
fffd4528:	0afffffc 	beq	fffd4520 <UartInit+0x24>
	Sleep (10000);
fffd452c:	e3020710 	movw	r0, #10000	; 0x2710
fffd4530:	eb000162 	bl	fffd4ac0 <Sleep>

	WRITE_REG (UART_IER(UART_NUM_g),0x00); // disable all interrupts; use polling mode	
fffd4534:	e5943000 	ldr	r3, [r4]
fffd4538:	e3a02000 	mov	r2, #0
	WRITE_REG (UART_FCR(UART_NUM_g),0x07); // reset TX and RX FIFO
fffd453c:	e3a01007 	mov	r1, #7
	UINT8 LCR;

	while ((READ_REG(UART_LSR(UART_NUM_g))&0x40) == 0x00); // wait for THRE (Transmitter Holding Register Empty) and TSR (Transmitter Shift Register) to be empty.
	Sleep (10000);

	WRITE_REG (UART_IER(UART_NUM_g),0x00); // disable all interrupts; use polling mode	
fffd4540:	e1a03603 	lsl	r3, r3, #12
fffd4544:	e2833a01 	add	r3, r3, #4096	; 0x1000
fffd4548:	e283324f 	add	r3, r3, #-268435452	; 0xf0000004
fffd454c:	e5c32000 	strb	r2, [r3]
	WRITE_REG (UART_FCR(UART_NUM_g),0x07); // reset TX and RX FIFO
fffd4550:	e5943000 	ldr	r3, [r4]
fffd4554:	e1a03603 	lsl	r3, r3, #12
fffd4558:	e2833a01 	add	r3, r3, #4096	; 0x1000
fffd455c:	e283328f 	add	r3, r3, #-268435448	; 0xf0000008
fffd4560:	e5c31000 	strb	r1, [r3]
	
	
	LCR = 0x03; // 8N1
	LCR |= 0x80; // Set DLAB bit; Accesses the Divisor Latch Registers (DLL, DLM).
	WRITE_REG (UART_LCR(UART_NUM_g), LCR);
fffd4564:	e3e0107c 	mvn	r1, #124	; 0x7c
fffd4568:	e5943000 	ldr	r3, [r4]
fffd456c:	e1a03603 	lsl	r3, r3, #12
fffd4570:	e2833a01 	add	r3, r3, #4096	; 0x1000
fffd4574:	e28332cf 	add	r3, r3, #-268435444	; 0xf000000c
fffd4578:	e5c31000 	strb	r1, [r3]
	WRITE_REG (UART_DLL(UART_NUM_g), 11); // Baud Rate = UART Clock 24MHz / (16 * (11+2)) = 115384
fffd457c:	e3a0100b 	mov	r1, #11
fffd4580:	e5943000 	ldr	r3, [r4]
fffd4584:	e283380f 	add	r3, r3, #983040	; 0xf0000
fffd4588:	e2833001 	add	r3, r3, #1
fffd458c:	e1a03603 	lsl	r3, r3, #12
fffd4590:	e5c31000 	strb	r1, [r3]
	WRITE_REG (UART_DLM(UART_NUM_g), 0x00); 
fffd4594:	e5943000 	ldr	r3, [r4]
fffd4598:	e1a03603 	lsl	r3, r3, #12
fffd459c:	e2833a01 	add	r3, r3, #4096	; 0x1000
fffd45a0:	e283324f 	add	r3, r3, #-268435452	; 0xf0000004
fffd45a4:	e5c32000 	strb	r2, [r3]
	LCR &= 0x7F; // Clear DLAB bit; Accesses RBR, THR or IER registers.
	WRITE_REG (UART_LCR(UART_NUM_g), LCR);
fffd45a8:	e3a02003 	mov	r2, #3
fffd45ac:	e5943000 	ldr	r3, [r4]
fffd45b0:	e1a03603 	lsl	r3, r3, #12
fffd45b4:	e2833a01 	add	r3, r3, #4096	; 0x1000
fffd45b8:	e28332cf 	add	r3, r3, #-268435444	; 0xf000000c
fffd45bc:	e5c32000 	strb	r2, [r3]
	
	if (UART_NUM_g==3)
fffd45c0:	e5943000 	ldr	r3, [r4]
fffd45c4:	e1530002 	cmp	r3, r2
fffd45c8:	1a000007 	bne	fffd45ec <UartInit+0xf0>
	{
		// connect SI2 to BMC UART3 
		WRITE_REG (SPSWC, (READ_REG(SPSWC)&0xFFFFFFF8) | 0x02); 
fffd45cc:	e59f2040 	ldr	r2, [pc, #64]	; fffd4614 <UartInit+0x118>
fffd45d0:	e5923038 	ldr	r3, [r2, #56]	; 0x38
fffd45d4:	e3c33007 	bic	r3, r3, #7
fffd45d8:	e3833002 	orr	r3, r3, #2
fffd45dc:	e5823038 	str	r3, [r2, #56]	; 0x38

		// Set SI2 Mux pins
		SET_BIT_REG (MFSEL1,11);
fffd45e0:	e592300c 	ldr	r3, [r2, #12]
fffd45e4:	e3833b02 	orr	r3, r3, #2048	; 0x800
fffd45e8:	ea000004 	b	fffd4600 <UartInit+0x104>
	}
	else if (UART_NUM_g==0) // BSP
fffd45ec:	e3530000 	cmp	r3, #0
fffd45f0:	18bd8010 	popne	{r4, pc}
	{
		// Set BSP Mux pins
		SET_BIT_REG (MFSEL1,9);
fffd45f4:	e59f2018 	ldr	r2, [pc, #24]	; fffd4614 <UartInit+0x118>
fffd45f8:	e592300c 	ldr	r3, [r2, #12]
fffd45fc:	e3833c02 	orr	r3, r3, #512	; 0x200
fffd4600:	e582300c 	str	r3, [r2, #12]
fffd4604:	e8bd8010 	pop	{r4, pc}
fffd4608:	00002d70 	.word	0x00002d70
fffd460c:	00000010 	.word	0x00000010
fffd4610:	f0001014 	.word	0xf0001014
fffd4614:	f0800000 	.word	0xf0800000

fffd4618 <UartSendStr>:
// Output to Console
//----------------------------------

//-------------------------------------
extern void UartSendStr (const char *Str)
{
fffd4618:	e59fc088 	ldr	r12, [pc, #136]	; fffd46a8 <UartSendStr+0x90>
fffd461c:	e2400001 	sub	r0, r0, #1
fffd4620:	e92d4010 	push	{r4, lr}
fffd4624:	e08fc00c 	add	r12, pc, r12
	while (*Str != 0)
fffd4628:	e5f0e001 	ldrb	lr, [r0, #1]!
fffd462c:	e35e0000 	cmp	lr, #0
fffd4630:	08bd8010 	popeq	{r4, pc}
	{
		while ((READ_REG(UART_LSR(UART_NUM_g))&0x20) == 0x00); // wait for THRE (Transmitter Holding Register Empty) to be set.
fffd4634:	e59f3070 	ldr	r3, [pc, #112]	; fffd46ac <UartSendStr+0x94>
fffd4638:	e59f2070 	ldr	r2, [pc, #112]	; fffd46b0 <UartSendStr+0x98>
fffd463c:	e79c1003 	ldr	r1, [r12, r3]
fffd4640:	e5913000 	ldr	r3, [r1]
fffd4644:	e1a04603 	lsl	r4, r3, #12
fffd4648:	e0842002 	add	r2, r4, r2
fffd464c:	e5d24000 	ldrb	r4, [r2]
fffd4650:	e3140020 	tst	r4, #32
fffd4654:	0afffffc 	beq	fffd464c <UartSendStr+0x34>
		WRITE_REG (UART_THR(UART_NUM_g), *Str);
fffd4658:	e283380f 	add	r3, r3, #983040	; 0xf0000
fffd465c:	e2833001 	add	r3, r3, #1
fffd4660:	e1a03603 	lsl	r3, r3, #12
fffd4664:	e5c3e000 	strb	lr, [r3]
		if (*Str == 0x0A)
fffd4668:	e5d03000 	ldrb	r3, [r0]
fffd466c:	e353000a 	cmp	r3, #10
fffd4670:	1affffec 	bne	fffd4628 <UartSendStr+0x10>
		{
			while ((READ_REG(UART_LSR(UART_NUM_g))&0x20) == 0x00); // wait for THRE (Transmitter Holding Register Empty) to be set.
fffd4674:	e5913000 	ldr	r3, [r1]
fffd4678:	e59f2030 	ldr	r2, [pc, #48]	; fffd46b0 <UartSendStr+0x98>
fffd467c:	e1a01603 	lsl	r1, r3, #12
fffd4680:	e0812002 	add	r2, r1, r2
fffd4684:	e5d21000 	ldrb	r1, [r2]
fffd4688:	e3110020 	tst	r1, #32
fffd468c:	0afffffc 	beq	fffd4684 <UartSendStr+0x6c>
			WRITE_REG (UART_THR(UART_NUM_g), 0x0D);  // add CR and LF
fffd4690:	e283380f 	add	r3, r3, #983040	; 0xf0000
fffd4694:	e3a0200d 	mov	r2, #13
fffd4698:	e2833001 	add	r3, r3, #1
fffd469c:	e1a03603 	lsl	r3, r3, #12
fffd46a0:	e5c32000 	strb	r2, [r3]
fffd46a4:	eaffffdf 	b	fffd4628 <UartSendStr+0x10>
fffd46a8:	00002c54 	.word	0x00002c54
fffd46ac:	00000010 	.word	0x00000010
fffd46b0:	f0001014 	.word	0xf0001014

fffd46b4 <__log_message>:
}


//-----------------------------------------
static void __log_message (_in const char *pFormat, va_list ap)
{
fffd46b4:	e92d4010 	push	{r4, lr}
fffd46b8:	e1a03001 	mov	r3, r1
    int len;

	FormattedTextBuffer[0] = 0; // clear the string
fffd46bc:	e59f4030 	ldr	r4, [pc, #48]	; fffd46f4 <__log_message+0x40>
fffd46c0:	e3a01000 	mov	r1, #0
}


//-----------------------------------------
static void __log_message (_in const char *pFormat, va_list ap)
{
fffd46c4:	e1a02000 	mov	r2, r0
    int len;

	FormattedTextBuffer[0] = 0; // clear the string
fffd46c8:	e08f4004 	add	r4, pc, r4
fffd46cc:	e5c41000 	strb	r1, [r4]

	/* Write formatted string in buffer */
	len = vsnprintf((char*)&FormattedTextBuffer[0], sizeof(FormattedTextBuffer)-1, pFormat, ap); // len is not counting the terminating null character.
fffd46d0:	e1a00004 	mov	r0, r4
fffd46d4:	e3a010ff 	mov	r1, #255	; 0xff
fffd46d8:	ebfffee1 	bl	fffd4264 <vsnprintf>
	if (len >= (sizeof(FormattedTextBuffer)-1) )
fffd46dc:	e35000fe 	cmp	r0, #254	; 0xfe
		UartSendStr (pErrorMsg);
	else
		UartSendStr ((char *)&FormattedTextBuffer[0]);
fffd46e0:	91a00004 	movls	r0, r4
	FormattedTextBuffer[0] = 0; // clear the string

	/* Write formatted string in buffer */
	len = vsnprintf((char*)&FormattedTextBuffer[0], sizeof(FormattedTextBuffer)-1, pFormat, ap); // len is not counting the terminating null character.
	if (len >= (sizeof(FormattedTextBuffer)-1) )
		UartSendStr (pErrorMsg);
fffd46e4:	859f000c 	ldrhi	r0, [pc, #12]	; fffd46f8 <__log_message+0x44>
fffd46e8:	808f0000 	addhi	r0, pc, r0
	else
		UartSendStr ((char *)&FormattedTextBuffer[0]);

	return;

}
fffd46ec:	e8bd4010 	pop	{r4, lr}
	/* Write formatted string in buffer */
	len = vsnprintf((char*)&FormattedTextBuffer[0], sizeof(FormattedTextBuffer)-1, pFormat, ap); // len is not counting the terminating null character.
	if (len >= (sizeof(FormattedTextBuffer)-1) )
		UartSendStr (pErrorMsg);
	else
		UartSendStr ((char *)&FormattedTextBuffer[0]);
fffd46f0:	eaffffc8 	b	fffd4618 <UartSendStr>
fffd46f4:	00002c20 	.word	0x00002c20
fffd46f8:	00002b53 	.word	0x00002b53

fffd46fc <LogMessage>:
	return;

}
//-------------------------------------------------------------
void LogMessage (_in const char *pFormat, ...)
{
fffd46fc:	e92d000f 	push	{r0, r1, r2, r3}
fffd4700:	e92d4007 	push	{r0, r1, r2, lr}
    va_list ap;
    va_start(ap, pFormat);
fffd4704:	e28d1014 	add	r1, sp, #20
    __log_message (pFormat, ap);
fffd4708:	e59d0010 	ldr	r0, [sp, #16]
}
//-------------------------------------------------------------
void LogMessage (_in const char *pFormat, ...)
{
    va_list ap;
    va_start(ap, pFormat);
fffd470c:	e58d1004 	str	r1, [sp, #4]
    __log_message (pFormat, ap);
fffd4710:	ebffffe7 	bl	fffd46b4 <__log_message>
    va_end(ap);
}
fffd4714:	e28dd00c 	add	sp, sp, #12
fffd4718:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
fffd471c:	e28dd010 	add	sp, sp, #16
fffd4720:	e12fff1e 	bx	lr

fffd4724 <SetColor>:
    va_end(ap);
}
//-------------------------------------------------------------
// Tested with VT100@ZOC terminal 
void SetColor (UINT8 ForeColor, UINT8 BackColor)
{
fffd4724:	e92d4013 	push	{r0, r1, r4, lr}
		ForeColor = COLOR_BLACK;
	if (BackColor == COLOR_DEFAULT)
		BackColor = COLOR_WHITE;
	*/

	snprintf (FormattedTextBuffer,sizeof(FormattedTextBuffer)-1,"%c[%u;%um",0x1B,ForeColor+COLOR_FOREGROUND,BackColor+COLOR_BACKGROUND);
fffd4728:	e280001e 	add	r0, r0, #30
fffd472c:	e59f4034 	ldr	r4, [pc, #52]	; fffd4768 <SetColor+0x44>
fffd4730:	e2811028 	add	r1, r1, #40	; 0x28
fffd4734:	e3a0301b 	mov	r3, #27
fffd4738:	e59f202c 	ldr	r2, [pc, #44]	; fffd476c <SetColor+0x48>
fffd473c:	e08f4004 	add	r4, pc, r4
fffd4740:	e58d0000 	str	r0, [sp]
fffd4744:	e58d1004 	str	r1, [sp, #4]
fffd4748:	e1a00004 	mov	r0, r4
fffd474c:	e3a010ff 	mov	r1, #255	; 0xff
fffd4750:	e08f2002 	add	r2, pc, r2
fffd4754:	ebffff39 	bl	fffd4440 <snprintf>
	UartSendStr (FormattedTextBuffer);
fffd4758:	e1a00004 	mov	r0, r4
}
fffd475c:	e28dd008 	add	sp, sp, #8
fffd4760:	e8bd4010 	pop	{r4, lr}
	if (BackColor == COLOR_DEFAULT)
		BackColor = COLOR_WHITE;
	*/

	snprintf (FormattedTextBuffer,sizeof(FormattedTextBuffer)-1,"%c[%u;%um",0x1B,ForeColor+COLOR_FOREGROUND,BackColor+COLOR_BACKGROUND);
	UartSendStr (FormattedTextBuffer);
fffd4764:	eaffffab 	b	fffd4618 <UartSendStr>
fffd4768:	00002bac 	.word	0x00002bac
fffd476c:	000029c0 	.word	0x000029c0

fffd4770 <LogMessageColor>:
    __log_message (pFormat, ap);
    va_end(ap);
}
//------------------------------------------------------------
void LogMessageColor (UINT8 ForeColor, _in const char *pFormat, ...)
{
fffd4770:	e92d000e 	push	{r1, r2, r3}
fffd4774:	e92d4003 	push	{r0, r1, lr}
	va_list ap;
	SetColor (ForeColor, COLOR_DEFAULT);
fffd4778:	e3a01009 	mov	r1, #9
fffd477c:	ebffffe8 	bl	fffd4724 <SetColor>
	va_start(ap, pFormat);
fffd4780:	e28d1010 	add	r1, sp, #16
	__log_message (pFormat, ap);
fffd4784:	e59d000c 	ldr	r0, [sp, #12]
//------------------------------------------------------------
void LogMessageColor (UINT8 ForeColor, _in const char *pFormat, ...)
{
	va_list ap;
	SetColor (ForeColor, COLOR_DEFAULT);
	va_start(ap, pFormat);
fffd4788:	e58d1004 	str	r1, [sp, #4]
	__log_message (pFormat, ap);
fffd478c:	ebffffc8 	bl	fffd46b4 <__log_message>
	SetColor (COLOR_DEFAULT, COLOR_DEFAULT);
fffd4790:	e3a00009 	mov	r0, #9
fffd4794:	e1a01000 	mov	r1, r0
fffd4798:	ebffffe1 	bl	fffd4724 <SetColor>
	va_end(ap);
}
fffd479c:	e28dd008 	add	sp, sp, #8
fffd47a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
fffd47a4:	e28dd00c 	add	sp, sp, #12
fffd47a8:	e12fff1e 	bx	lr

fffd47ac <LogError>:
//-------------------------------------------------------------
void LogError (_in const char *pFormat, ...)
{
fffd47ac:	e92d000f 	push	{r0, r1, r2, r3}
fffd47b0:	e92d4007 	push	{r0, r1, r2, lr}
    va_list ap;
	SetColor (COLOR_RED, COLOR_DEFAULT);
fffd47b4:	e3a00001 	mov	r0, #1
fffd47b8:	e3a01009 	mov	r1, #9
fffd47bc:	ebffffd8 	bl	fffd4724 <SetColor>
    va_start(ap, pFormat);
fffd47c0:	e28d1014 	add	r1, sp, #20
    __log_message (pFormat, ap);
fffd47c4:	e59d0010 	ldr	r0, [sp, #16]
//-------------------------------------------------------------
void LogError (_in const char *pFormat, ...)
{
    va_list ap;
	SetColor (COLOR_RED, COLOR_DEFAULT);
    va_start(ap, pFormat);
fffd47c8:	e58d1004 	str	r1, [sp, #4]
    __log_message (pFormat, ap);
fffd47cc:	ebffffb8 	bl	fffd46b4 <__log_message>
    va_end(ap);
	SetColor (COLOR_DEFAULT, COLOR_DEFAULT);
fffd47d0:	e3a00009 	mov	r0, #9
fffd47d4:	e1a01000 	mov	r1, r0
fffd47d8:	ebffffd1 	bl	fffd4724 <SetColor>
}
fffd47dc:	e28dd00c 	add	sp, sp, #12
fffd47e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
fffd47e4:	e28dd010 	add	sp, sp, #16
fffd47e8:	e12fff1e 	bx	lr

fffd47ec <LogWarning>:
//-------------------------------------------------------------
void LogWarning (_in const char *pFormat, ...)
{
fffd47ec:	e92d000f 	push	{r0, r1, r2, r3}
fffd47f0:	e92d4007 	push	{r0, r1, r2, lr}
	va_list ap;
	SetColor (COLOR_MAGENTA,COLOR_DEFAULT );
fffd47f4:	e3a00005 	mov	r0, #5
fffd47f8:	e3a01009 	mov	r1, #9
fffd47fc:	ebffffc8 	bl	fffd4724 <SetColor>
	va_start(ap, pFormat);
fffd4800:	e28d1014 	add	r1, sp, #20
	__log_message (pFormat, ap);
fffd4804:	e59d0010 	ldr	r0, [sp, #16]
//-------------------------------------------------------------
void LogWarning (_in const char *pFormat, ...)
{
	va_list ap;
	SetColor (COLOR_MAGENTA,COLOR_DEFAULT );
	va_start(ap, pFormat);
fffd4808:	e58d1004 	str	r1, [sp, #4]
	__log_message (pFormat, ap);
fffd480c:	ebffffa8 	bl	fffd46b4 <__log_message>
	va_end(ap);
	SetColor (COLOR_DEFAULT, COLOR_DEFAULT);
fffd4810:	e3a00009 	mov	r0, #9
fffd4814:	e1a01000 	mov	r1, r0
fffd4818:	ebffffc1 	bl	fffd4724 <SetColor>
}
fffd481c:	e28dd00c 	add	sp, sp, #12
fffd4820:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
fffd4824:	e28dd010 	add	sp, sp, #16
fffd4828:	e12fff1e 	bx	lr

fffd482c <LogPass>:
	UartSendStr ("\n***************************************************\n");
	SetColor (COLOR_DEFAULT, COLOR_DEFAULT);
}
//-------------------------------------------------------------
void LogPass (_in const char *pFormat, ...)
{
fffd482c:	e92d000f 	push	{r0, r1, r2, r3}
fffd4830:	e92d4007 	push	{r0, r1, r2, lr}
    va_list ap;
	SetColor (COLOR_GREEN, COLOR_DEFAULT);
fffd4834:	e3a00002 	mov	r0, #2
fffd4838:	e3a01009 	mov	r1, #9
fffd483c:	ebffffb8 	bl	fffd4724 <SetColor>
    va_start(ap, pFormat);
fffd4840:	e28d1014 	add	r1, sp, #20
    __log_message (pFormat, ap);
fffd4844:	e59d0010 	ldr	r0, [sp, #16]
//-------------------------------------------------------------
void LogPass (_in const char *pFormat, ...)
{
    va_list ap;
	SetColor (COLOR_GREEN, COLOR_DEFAULT);
    va_start(ap, pFormat);
fffd4848:	e58d1004 	str	r1, [sp, #4]
    __log_message (pFormat, ap);
fffd484c:	ebffff98 	bl	fffd46b4 <__log_message>
	SetColor (COLOR_DEFAULT, COLOR_DEFAULT);
fffd4850:	e3a00009 	mov	r0, #9
fffd4854:	e1a01000 	mov	r1, r0
fffd4858:	ebffffb1 	bl	fffd4724 <SetColor>
    va_end(ap);
}
fffd485c:	e28dd00c 	add	sp, sp, #12
fffd4860:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
fffd4864:	e28dd010 	add	sp, sp, #16
fffd4868:	e12fff1e 	bx	lr

fffd486c <LogHeader>:
	SetColor (COLOR_DEFAULT, COLOR_DEFAULT);

}
//-------------------------------------------------------------
void LogHeader (_in const char *pFormat, ...)
{
fffd486c:	e92d000f 	push	{r0, r1, r2, r3}
fffd4870:	e92d4007 	push	{r0, r1, r2, lr}
    va_list ap;
	SetColor (COLOR_CYAN, COLOR_DEFAULT);
fffd4874:	e3a01009 	mov	r1, #9
fffd4878:	e3a00006 	mov	r0, #6
fffd487c:	ebffffa8 	bl	fffd4724 <SetColor>
	UartSendStr ("***************************************************\n");
fffd4880:	e59f003c 	ldr	r0, [pc, #60]	; fffd48c4 <LogHeader+0x58>
fffd4884:	e08f0000 	add	r0, pc, r0
fffd4888:	ebffff62 	bl	fffd4618 <UartSendStr>
    va_start(ap, pFormat);
fffd488c:	e28d1014 	add	r1, sp, #20
    __log_message (pFormat, ap);
fffd4890:	e59d0010 	ldr	r0, [sp, #16]
void LogHeader (_in const char *pFormat, ...)
{
    va_list ap;
	SetColor (COLOR_CYAN, COLOR_DEFAULT);
	UartSendStr ("***************************************************\n");
    va_start(ap, pFormat);
fffd4894:	e58d1004 	str	r1, [sp, #4]
    __log_message (pFormat, ap);
fffd4898:	ebffff85 	bl	fffd46b4 <__log_message>
    va_end(ap);
	UartSendStr ("\n***************************************************\n");
fffd489c:	e59f0024 	ldr	r0, [pc, #36]	; fffd48c8 <LogHeader+0x5c>
fffd48a0:	e08f0000 	add	r0, pc, r0
fffd48a4:	ebffff5b 	bl	fffd4618 <UartSendStr>
	SetColor (COLOR_DEFAULT, COLOR_DEFAULT);
fffd48a8:	e3a00009 	mov	r0, #9
fffd48ac:	e1a01000 	mov	r1, r0
fffd48b0:	ebffff9b 	bl	fffd4724 <SetColor>
}
fffd48b4:	e28dd00c 	add	sp, sp, #12
fffd48b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
fffd48bc:	e28dd010 	add	sp, sp, #16
fffd48c0:	e12fff1e 	bx	lr
fffd48c4:	0000289f 	.word	0x0000289f
fffd48c8:	00002882 	.word	0x00002882

fffd48cc <UartWaitForEmpty>:
	WRITE_REG (UART_THR(UART_NUM_g), data);
}
//-------------------------------------------------------------
// use this function to wait until UART send all it's buffer before change clock freq
extern void UartWaitForEmpty (void)
{
fffd48cc:	e59f3050 	ldr	r3, [pc, #80]	; fffd4924 <UartWaitForEmpty+0x58>
	while ((READ_REG(UART_LSR(UART_NUM_g))&0x40) == 0x00); // wait for THRE (Transmitter Holding Register Empty) and TSR (Transmitter Shift Register) to be empty.
fffd48d0:	e59f2050 	ldr	r2, [pc, #80]	; fffd4928 <UartWaitForEmpty+0x5c>
	WRITE_REG (UART_THR(UART_NUM_g), data);
}
//-------------------------------------------------------------
// use this function to wait until UART send all it's buffer before change clock freq
extern void UartWaitForEmpty (void)
{
fffd48d4:	e08f3003 	add	r3, pc, r3
	while ((READ_REG(UART_LSR(UART_NUM_g))&0x40) == 0x00); // wait for THRE (Transmitter Holding Register Empty) and TSR (Transmitter Shift Register) to be empty.
fffd48d8:	e7933002 	ldr	r3, [r3, r2]
fffd48dc:	e5932000 	ldr	r2, [r3]
fffd48e0:	e59f3044 	ldr	r3, [pc, #68]	; fffd492c <UartWaitForEmpty+0x60>
fffd48e4:	e1a02602 	lsl	r2, r2, #12
fffd48e8:	e0823003 	add	r3, r2, r3
fffd48ec:	e5d32000 	ldrb	r2, [r3]
fffd48f0:	e3120040 	tst	r2, #64	; 0x40
fffd48f4:	0afffffc 	beq	fffd48ec <UartWaitForEmpty+0x20>
	WRITE_REG (UART_THR(UART_NUM_g), data);
}
//-------------------------------------------------------------
// use this function to wait until UART send all it's buffer before change clock freq
extern void UartWaitForEmpty (void)
{
fffd48f8:	e24dd008 	sub	sp, sp, #8
	while ((READ_REG(UART_LSR(UART_NUM_g))&0x40) == 0x00); // wait for THRE (Transmitter Holding Register Empty) and TSR (Transmitter Shift Register) to be empty.
	// some delay. notice needed some delay so UartUpdateTool will pass w/o error log
	volatile unsigned int delay;
	for (delay=0;delay<10000;delay++);
fffd48fc:	e3a03000 	mov	r3, #0
fffd4900:	e58d3004 	str	r3, [sp, #4]
fffd4904:	e302370f 	movw	r3, #9999	; 0x270f
fffd4908:	e59d2004 	ldr	r2, [sp, #4]
fffd490c:	e1520003 	cmp	r2, r3
fffd4910:	959d3004 	ldrls	r3, [sp, #4]
fffd4914:	92833001 	addls	r3, r3, #1
fffd4918:	9afffff8 	bls	fffd4900 <UartWaitForEmpty+0x34>
}
fffd491c:	e28dd008 	add	sp, sp, #8
fffd4920:	e12fff1e 	bx	lr
fffd4924:	000029a4 	.word	0x000029a4
fffd4928:	00000010 	.word	0x00000010
fffd492c:	f0001014 	.word	0xf0001014

fffd4930 <KbHit>:
// Input from Console
//----------------------------------

//-----------------------------------
extern int KbHit (void)
{
fffd4930:	e59f301c 	ldr	r3, [pc, #28]	; fffd4954 <KbHit+0x24>

	if ( (READ_REG(UART_LSR(UART_NUM_g))&0x01) == 0x01) // check RFDR; RxFIFO contains at least one received data word
fffd4934:	e59f201c 	ldr	r2, [pc, #28]	; fffd4958 <KbHit+0x28>
// Input from Console
//----------------------------------

//-----------------------------------
extern int KbHit (void)
{
fffd4938:	e08f3003 	add	r3, pc, r3

	if ( (READ_REG(UART_LSR(UART_NUM_g))&0x01) == 0x01) // check RFDR; RxFIFO contains at least one received data word
fffd493c:	e7933002 	ldr	r3, [r3, r2]
fffd4940:	e5932000 	ldr	r2, [r3]
fffd4944:	e59f3010 	ldr	r3, [pc, #16]	; fffd495c <KbHit+0x2c>
fffd4948:	e7d30602 	ldrb	r0, [r3, r2, lsl #12]
		return (TRUE); // key was received.
	else
		return (FALSE); // no key is waiting.
}
fffd494c:	e2000001 	and	r0, r0, #1
fffd4950:	e12fff1e 	bx	lr
fffd4954:	00002940 	.word	0x00002940
fffd4958:	00000010 	.word	0x00000010
fffd495c:	f0001014 	.word	0xf0001014

fffd4960 <GetChar>:
//------------------------------------
extern char GetChar (void)
{
fffd4960:	e59f3020 	ldr	r3, [pc, #32]	; fffd4988 <GetChar+0x28>
	char data;

	data = READ_REG (UART_THR(UART_NUM_g));
fffd4964:	e59f2020 	ldr	r2, [pc, #32]	; fffd498c <GetChar+0x2c>
	else
		return (FALSE); // no key is waiting.
}
//------------------------------------
extern char GetChar (void)
{
fffd4968:	e08f3003 	add	r3, pc, r3
	char data;

	data = READ_REG (UART_THR(UART_NUM_g));
fffd496c:	e7933002 	ldr	r3, [r3, r2]
fffd4970:	e5933000 	ldr	r3, [r3]
fffd4974:	e283380f 	add	r3, r3, #983040	; 0xf0000
fffd4978:	e2833001 	add	r3, r3, #1
fffd497c:	e1a03603 	lsl	r3, r3, #12
fffd4980:	e5d30000 	ldrb	r0, [r3]

	return (data);
}
fffd4984:	e12fff1e 	bx	lr
fffd4988:	00002910 	.word	0x00002910
fffd498c:	00000010 	.word	0x00000010

fffd4990 <Uart_AutoDetect>:
	return (0);
}
//---------------------------------------------------------------------

extern void Uart_AutoDetect (void)
{
fffd4990:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	UINT32 uart_num,WLS_filed;
	UINT32 TimeOut, loop_countdown;
	//---------------------------------
	loop_countdown = 10;
fffd4994:	e3a0500a 	mov	r5, #10
	return (0);
}
//---------------------------------------------------------------------

extern void Uart_AutoDetect (void)
{
fffd4998:	e59f6104 	ldr	r6, [pc, #260]	; fffd4aa4 <Uart_AutoDetect+0x114>
fffd499c:	e08f6006 	add	r6, pc, r6
	loop_countdown = 10;
	while (1)
	{
		//-------------------------------
		// Send message to all UARTs ports (0...3)
		for (uart_num=0; uart_num<4; uart_num++)
fffd49a0:	e3a04000 	mov	r4, #0
fffd49a4:	e1a03604 	lsl	r3, r4, #12
fffd49a8:	e2833a01 	add	r3, r3, #4096	; 0x1000
fffd49ac:	e28332cf 	add	r3, r3, #-268435444	; 0xf000000c
		{
			WLS_filed = READ_REG(UART_LCR(uart_num)) & 0x03; // Word Length Select
fffd49b0:	e5d33000 	ldrb	r3, [r3]
fffd49b4:	e2033003 	and	r3, r3, #3
			if (WLS_filed==0x03/*8 bits*/ || WLS_filed==0x02/*7 bits*/)
fffd49b8:	e2433002 	sub	r3, r3, #2
fffd49bc:	e3530001 	cmp	r3, #1
fffd49c0:	8a000006 	bhi	fffd49e0 <Uart_AutoDetect+0x50>
// It /*update baud rate to 115384bps and*/ disable interrupts. 

UINT32 UART_NUM_g;
extern void UartSetNum (int UART_Num)
{
	UART_NUM_g = UART_Num;
fffd49c4:	e59f30dc 	ldr	r3, [pc, #220]	; fffd4aa8 <Uart_AutoDetect+0x118>
		{
			WLS_filed = READ_REG(UART_LCR(uart_num)) & 0x03; // Word Length Select
			if (WLS_filed==0x03/*8 bits*/ || WLS_filed==0x02/*7 bits*/)
			{ // if this UART channel is configure to 5 or 6 bits, we assume it is not init. Support only 6 or 7 bits.
				UartSetNum(uart_num);
				LogMessage ("\n Press 'ENTER' to start ... ");
fffd49c8:	e59f00dc 	ldr	r0, [pc, #220]	; fffd4aac <Uart_AutoDetect+0x11c>
// It /*update baud rate to 115384bps and*/ disable interrupts. 

UINT32 UART_NUM_g;
extern void UartSetNum (int UART_Num)
{
	UART_NUM_g = UART_Num;
fffd49cc:	e7963003 	ldr	r3, [r6, r3]
		{
			WLS_filed = READ_REG(UART_LCR(uart_num)) & 0x03; // Word Length Select
			if (WLS_filed==0x03/*8 bits*/ || WLS_filed==0x02/*7 bits*/)
			{ // if this UART channel is configure to 5 or 6 bits, we assume it is not init. Support only 6 or 7 bits.
				UartSetNum(uart_num);
				LogMessage ("\n Press 'ENTER' to start ... ");
fffd49d0:	e08f0000 	add	r0, pc, r0
// It /*update baud rate to 115384bps and*/ disable interrupts. 

UINT32 UART_NUM_g;
extern void UartSetNum (int UART_Num)
{
	UART_NUM_g = UART_Num;
fffd49d4:	e5834000 	str	r4, [r3]
		{
			WLS_filed = READ_REG(UART_LCR(uart_num)) & 0x03; // Word Length Select
			if (WLS_filed==0x03/*8 bits*/ || WLS_filed==0x02/*7 bits*/)
			{ // if this UART channel is configure to 5 or 6 bits, we assume it is not init. Support only 6 or 7 bits.
				UartSetNum(uart_num);
				LogMessage ("\n Press 'ENTER' to start ... ");
fffd49d8:	ebffff47 	bl	fffd46fc <LogMessage>
				UartWaitForEmpty ();
fffd49dc:	ebffffba 	bl	fffd48cc <UartWaitForEmpty>
	loop_countdown = 10;
	while (1)
	{
		//-------------------------------
		// Send message to all UARTs ports (0...3)
		for (uart_num=0; uart_num<4; uart_num++)
fffd49e0:	e2844001 	add	r4, r4, #1
fffd49e4:	e3540004 	cmp	r4, #4
fffd49e8:	1affffed 	bne	fffd49a4 <Uart_AutoDetect+0x14>
fffd49ec:	e59f70bc 	ldr	r7, [pc, #188]	; fffd4ab0 <Uart_AutoDetect+0x120>
fffd49f0:	e3a04000 	mov	r4, #0
fffd49f4:	e1a03604 	lsl	r3, r4, #12
fffd49f8:	e2833a01 	add	r3, r3, #4096	; 0x1000
fffd49fc:	e28332cf 	add	r3, r3, #-268435444	; 0xf000000c
		TimeOut = 500000;
		while (TimeOut!=0)
		{
			for (uart_num=0; uart_num<4; uart_num++)
			{
				WLS_filed = READ_REG(UART_LCR(uart_num)) & 0x03; // Word Length Select
fffd4a00:	e5d33000 	ldrb	r3, [r3]
fffd4a04:	e2033003 	and	r3, r3, #3
				if (WLS_filed==0x03/*8 bits*/ || WLS_filed==0x02/*7 bits*/)
fffd4a08:	e2433002 	sub	r3, r3, #2
fffd4a0c:	e3530001 	cmp	r3, #1
fffd4a10:	8a00000d 	bhi	fffd4a4c <Uart_AutoDetect+0xbc>
// It /*update baud rate to 115384bps and*/ disable interrupts. 

UINT32 UART_NUM_g;
extern void UartSetNum (int UART_Num)
{
	UART_NUM_g = UART_Num;
fffd4a14:	e59f308c 	ldr	r3, [pc, #140]	; fffd4aa8 <Uart_AutoDetect+0x118>
fffd4a18:	e7963003 	ldr	r3, [r6, r3]
fffd4a1c:	e5834000 	str	r4, [r3]
			{
				WLS_filed = READ_REG(UART_LCR(uart_num)) & 0x03; // Word Length Select
				if (WLS_filed==0x03/*8 bits*/ || WLS_filed==0x02/*7 bits*/)
				{ // if this UART channel is configure to 5 or 6 bits, we assume it is not init. Support only 6 or 7 bits.
					UartSetNum(uart_num);
					if ((KbHit()==TRUE) && (GetChar()==0x0D))
fffd4a20:	ebffffc2 	bl	fffd4930 <KbHit>
fffd4a24:	e3500001 	cmp	r0, #1
fffd4a28:	1a000007 	bne	fffd4a4c <Uart_AutoDetect+0xbc>
fffd4a2c:	ebffffcb 	bl	fffd4960 <GetChar>
fffd4a30:	e350000d 	cmp	r0, #13
fffd4a34:	1a000004 	bne	fffd4a4c <Uart_AutoDetect+0xbc>
					{
						LogMessage ("Use UART%d ",uart_num);
fffd4a38:	e59f0074 	ldr	r0, [pc, #116]	; fffd4ab4 <Uart_AutoDetect+0x124>
fffd4a3c:	e1a01004 	mov	r1, r4
			LogMessage ("Configure UART0<-->BSP; Init USRT0 to 8N1 @ 115Kb/s.\n");
		}
		loop_countdown--;
		//-------------------------------
	}
}
fffd4a40:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}
				if (WLS_filed==0x03/*8 bits*/ || WLS_filed==0x02/*7 bits*/)
				{ // if this UART channel is configure to 5 or 6 bits, we assume it is not init. Support only 6 or 7 bits.
					UartSetNum(uart_num);
					if ((KbHit()==TRUE) && (GetChar()==0x0D))
					{
						LogMessage ("Use UART%d ",uart_num);
fffd4a44:	e08f0000 	add	r0, pc, r0
fffd4a48:	eaffff2b 	b	fffd46fc <LogMessage>
		//-------------------------------
		// check for 'ENTER' key from all UARTs ports  
		TimeOut = 500000;
		while (TimeOut!=0)
		{
			for (uart_num=0; uart_num<4; uart_num++)
fffd4a4c:	e2844001 	add	r4, r4, #1
fffd4a50:	e3540004 	cmp	r4, #4
fffd4a54:	1affffe6 	bne	fffd49f4 <Uart_AutoDetect+0x64>
			}
		}
		//-------------------------------
		// check for 'ENTER' key from all UARTs ports  
		TimeOut = 500000;
		while (TimeOut!=0)
fffd4a58:	e2577001 	subs	r7, r7, #1
fffd4a5c:	1affffe3 	bne	fffd49f0 <Uart_AutoDetect+0x60>
			}
			TimeOut--;
		}
		//-------------------------------
		// after ~3 second, configure UART3<-->SI2 and UART0<-->BSP @ 8N1, 115Kb/s; 
		if (loop_countdown==0)
fffd4a60:	e3550000 	cmp	r5, #0
fffd4a64:	1a00000c 	bne	fffd4a9c <Uart_AutoDetect+0x10c>
// It /*update baud rate to 115384bps and*/ disable interrupts. 

UINT32 UART_NUM_g;
extern void UartSetNum (int UART_Num)
{
	UART_NUM_g = UART_Num;
fffd4a68:	e59f3038 	ldr	r3, [pc, #56]	; fffd4aa8 <Uart_AutoDetect+0x118>
fffd4a6c:	e7964003 	ldr	r4, [r6, r3]
fffd4a70:	e3a03003 	mov	r3, #3
fffd4a74:	e5843000 	str	r3, [r4]
static char FormattedTextBuffer [0x100] __attribute__ ((aligned (4)));  

//-------------------------------------------------------------------
void TestMsgInit (void)
{
	UartInit ();
fffd4a78:	ebfffe9f 	bl	fffd44fc <UartInit>
		// after ~3 second, configure UART3<-->SI2 and UART0<-->BSP @ 8N1, 115Kb/s; 
		if (loop_countdown==0)
		{
			UartSetNum(3);
			TestMsgInit(); // Init UART3<-->SI2 
			LogMessage ("Configure UART3<-->SI2; Init USRT3 to 8N1 @ 115Kb/s.\n");
fffd4a7c:	e59f0034 	ldr	r0, [pc, #52]	; fffd4ab8 <Uart_AutoDetect+0x128>
fffd4a80:	e08f0000 	add	r0, pc, r0
fffd4a84:	ebffff1c 	bl	fffd46fc <LogMessage>
// It /*update baud rate to 115384bps and*/ disable interrupts. 

UINT32 UART_NUM_g;
extern void UartSetNum (int UART_Num)
{
	UART_NUM_g = UART_Num;
fffd4a88:	e5845000 	str	r5, [r4]
static char FormattedTextBuffer [0x100] __attribute__ ((aligned (4)));  

//-------------------------------------------------------------------
void TestMsgInit (void)
{
	UartInit ();
fffd4a8c:	ebfffe9a 	bl	fffd44fc <UartInit>
			TestMsgInit(); // Init UART3<-->SI2 
			LogMessage ("Configure UART3<-->SI2; Init USRT3 to 8N1 @ 115Kb/s.\n");

			UartSetNum(0); // 17/NOV/2016: added support for UART0 configuration
			TestMsgInit(); // Init UART0<-->BSP 
			LogMessage ("Configure UART0<-->BSP; Init USRT0 to 8N1 @ 115Kb/s.\n");
fffd4a90:	e59f0024 	ldr	r0, [pc, #36]	; fffd4abc <Uart_AutoDetect+0x12c>
fffd4a94:	e08f0000 	add	r0, pc, r0
fffd4a98:	ebffff17 	bl	fffd46fc <LogMessage>
		}
		loop_countdown--;
fffd4a9c:	e2455001 	sub	r5, r5, #1
		//-------------------------------
	}
fffd4aa0:	eaffffbe 	b	fffd49a0 <Uart_AutoDetect+0x10>
fffd4aa4:	000028dc 	.word	0x000028dc
fffd4aa8:	00000010 	.word	0x00000010
fffd4aac:	00002788 	.word	0x00002788
fffd4ab0:	0007a120 	.word	0x0007a120
fffd4ab4:	00002732 	.word	0x00002732
fffd4ab8:	00002702 	.word	0x00002702
fffd4abc:	00002724 	.word	0x00002724

fffd4ac0 <Sleep>:
#include "CoreRegisters.h"
#include "TestMsgCore.h"
#include "Utility.h"

void Sleep (DWORD Cycles)
{
fffd4ac0:	e24dd008 	sub	sp, sp, #8
    volatile DWORD delay;

    while (Cycles!=0)
fffd4ac4:	e3500000 	cmp	r0, #0
fffd4ac8:	0a000008 	beq	fffd4af0 <Sleep+0x30>
    {
         for  (delay=0;delay<0x10;delay++);
fffd4acc:	e3a03000 	mov	r3, #0
fffd4ad0:	e58d3004 	str	r3, [sp, #4]
fffd4ad4:	e59d3004 	ldr	r3, [sp, #4]
fffd4ad8:	e353000f 	cmp	r3, #15
fffd4adc:	959d3004 	ldrls	r3, [sp, #4]
fffd4ae0:	92833001 	addls	r3, r3, #1
fffd4ae4:	9afffff9 	bls	fffd4ad0 <Sleep+0x10>
         Cycles--;
fffd4ae8:	e2400001 	sub	r0, r0, #1
fffd4aec:	eafffff4 	b	fffd4ac4 <Sleep+0x4>
    }
    return;

} // *End of Delay*
fffd4af0:	e28dd008 	add	sp, sp, #8
fffd4af4:	e12fff1e 	bx	lr

fffd4af8 <InvalidateCache>:
extern void InvalidateCache (void)
{
	UINT32 reg32;
	// Invalidate Instruction cache.
	reg32 = 0;
	CP15_WRITE (reg32,0,c7,c5,0); // ICIALLU: Invalidate all instruction caches to PoU. Also flushes branch target cache.
fffd4af8:	e3a03000 	mov	r3, #0
fffd4afc:	ee073f15 	mcr	15, 0, r3, cr7, cr5, {0}
	reg32 = 0;
	CP15_WRITE (reg32,0,c7,c5,6); // BPIALL: Invalidate entire branch predictor array.
fffd4b00:	ee073fd5 	mcr	15, 0, r3, cr7, cr5, {6}
fffd4b04:	e12fff1e 	bx	lr

fffd4b08 <MemCmp>:
//--------------------------------------------
extern int MemCmp (const void *ptr1, const void *ptr2, UINT32 SizeInByte)
{
	UINT32 Offset;

	Offset = 0;
fffd4b08:	e3a03000 	mov	r3, #0
// return:
// (-1) indicates that the contents of both memory blocks are equal
// other value for error offset.
//--------------------------------------------
extern int MemCmp (const void *ptr1, const void *ptr2, UINT32 SizeInByte)
{
fffd4b0c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	UINT32 Offset;

	Offset = 0;
	while (SizeInByte!=0)
fffd4b10:	e1530002 	cmp	r3, r2
fffd4b14:	0a000007 	beq	fffd4b38 <MemCmp+0x30>
	{
		if ( *((UINT8*)ptr1) != *((UINT8*)ptr2) )
fffd4b18:	e7d0e003 	ldrb	lr, [r0, r3]
fffd4b1c:	e7d1c003 	ldrb	r12, [r1, r3]
fffd4b20:	e15e000c 	cmp	lr, r12
fffd4b24:	0a000001 	beq	fffd4b30 <MemCmp+0x28>
			return (Offset);	
fffd4b28:	e1a00003 	mov	r0, r3
fffd4b2c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

		ptr1 = (UINT8*)ptr1 + 1;
		ptr2 = (UINT8*)ptr2 + 1;
		Offset++;
fffd4b30:	e2833001 	add	r3, r3, #1
fffd4b34:	eafffff5 	b	fffd4b10 <MemCmp+0x8>
		SizeInByte--;	
	}
	return (-1); // pass
fffd4b38:	e3e00000 	mvn	r0, #0
}
fffd4b3c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

fffd4b40 <MemCpy>:
//--------------------------------------------
// Same as memcpy but use 8bit burst only. 
//--------------------------------------------
extern void MemCpy (void *dst, const void *src, UINT32 SizeInByte)
{
fffd4b40:	e2400001 	sub	r0, r0, #1
fffd4b44:	e0812002 	add	r2, r1, r2
	UINT8 *pDst = (UINT8 *)dst;
	UINT8 const *pSrc = (UINT8 const *)src;

	while (SizeInByte--)
fffd4b48:	e1510002 	cmp	r1, r2
	{
		*pDst++ = *pSrc++;
fffd4b4c:	14d13001 	ldrbne	r3, [r1], #1
fffd4b50:	15e03001 	strbne	r3, [r0, #1]!
fffd4b54:	1afffffb 	bne	fffd4b48 <MemCpy+0x8>
	}
}
fffd4b58:	e12fff1e 	bx	lr

fffd4b5c <MemSet>:
*/
//-----------------------------------------------------------------
// Same as memcpy but use 8bit burst only. 
//-----------------------------------------------------------------
extern void MemSet (void *dst, int val, UINT32 SizeInByte)
{
fffd4b5c:	e0802002 	add	r2, r0, r2
	UINT8 *pDst = (UINT8 *)dst;

	while (SizeInByte--)
fffd4b60:	e1500002 	cmp	r0, r2
	{
		*pDst++ = val;
fffd4b64:	14c01001 	strbne	r1, [r0], #1
fffd4b68:	1afffffc 	bne	fffd4b60 <MemSet+0x4>
	}
}
fffd4b6c:	e12fff1e 	bx	lr

fffd4b70 <rand_8bit>:
	next = next * 1103515245 + 12345;
	return ((unsigned int)(next>>16)) & 0x7FFF ;
}
extern unsigned char rand_8bit (void)
{
	next = next * 1103515245 + 12345;
fffd4b70:	e59f201c 	ldr	r2, [pc, #28]	; fffd4b94 <rand_8bit+0x24>
fffd4b74:	e3031039 	movw	r1, #12345	; 0x3039
fffd4b78:	e59f0018 	ldr	r0, [pc, #24]	; fffd4b98 <rand_8bit+0x28>
fffd4b7c:	e08f2002 	add	r2, pc, r2
fffd4b80:	e5923000 	ldr	r3, [r2]
fffd4b84:	e0201390 	mla	r0, r0, r3, r1
fffd4b88:	e5820000 	str	r0, [r2]
	return (unsigned char)(next);
}
fffd4b8c:	e6ef0070 	uxtb	r0, r0
fffd4b90:	e12fff1e 	bx	lr
fffd4b94:	00002764 	.word	0x00002764
fffd4b98:	41c64e6d 	.word	0x41c64e6d

fffd4b9c <rand_32bit>:
extern unsigned long int rand_32bit (void)
{
	next = next * 1103515245 + 12345;
fffd4b9c:	e59f2018 	ldr	r2, [pc, #24]	; fffd4bbc <rand_32bit+0x20>
fffd4ba0:	e3031039 	movw	r1, #12345	; 0x3039
fffd4ba4:	e59f0014 	ldr	r0, [pc, #20]	; fffd4bc0 <rand_32bit+0x24>
fffd4ba8:	e08f2002 	add	r2, pc, r2
fffd4bac:	e5923000 	ldr	r3, [r2]
fffd4bb0:	e0201390 	mla	r0, r0, r3, r1
fffd4bb4:	e5820000 	str	r0, [r2]
	return (next);
}
fffd4bb8:	e12fff1e 	bx	lr
fffd4bbc:	00002738 	.word	0x00002738
fffd4bc0:	41c64e6d 	.word	0x41c64e6d

fffd4bc4 <srand>:
	next = seed;
}

extern void srand (unsigned int seed)
{
	next = seed;
fffd4bc4:	e59f3008 	ldr	r3, [pc, #8]	; fffd4bd4 <srand+0x10>
fffd4bc8:	e08f3003 	add	r3, pc, r3
fffd4bcc:	e5830000 	str	r0, [r3]
fffd4bd0:	e12fff1e 	bx	lr
fffd4bd4:	00002718 	.word	0x00002718

fffd4bd8 <CPU1_Toggle>:
CPU1_Toggle:

CPU1_OFF:  

		// update revision register to indicate test in running 
		ldr r0, =0x12345678
fffd4bd8:	e59f00d0 	ldr	r0, [pc, #208]	; fffd4cb0 <CPU1_Rev+0x4>
		ldr r1, =CPU1_Rev
fffd4bdc:	e59f10d0 	ldr	r1, [pc, #208]	; fffd4cb4 <CPU1_Rev+0x8>
		str r0, [r1]
fffd4be0:	e5810000 	str	r0, [r1]
		// Set GPIO00 Low
		//ldr r1, =#0xF001000C  // GP0DOUT
		//ldr r0, =#0x00000000  // bit0 - low
		//str r0, [r1]

		WFE
fffd4be4:	e320f002 	wfe
		// Set GPIO00 High
		//ldr r1, =#0xF001000C  // GP0DOUT 
		//ldr r0, =#0x00000001  // bit0 - high 
		//str r0, [r1] 
		
		ldr r0, CPU1_Cmd 
fffd4be8:	e59f00b8 	ldr	r0, [pc, #184]	; fffd4ca8 <CPU1_Cmd>
		cmp r0,#0
fffd4bec:	e3500000 	cmp	r0, #0
		beq CPU1_OFF
fffd4bf0:	0afffff8 	beq	fffd4bd8 <CPU1_Toggle>
		
		ldr r1,  =0x00100000
fffd4bf4:	e3a01601 	mov	r1, #1048576	; 0x100000
		ldr r2,  =0x00200000
fffd4bf8:	e3a02602 	mov	r2, #2097152	; 0x200000
		ldr r3,  =0x33333333
fffd4bfc:	e59f30b4 	ldr	r3, [pc, #180]	; fffd4cb8 <CPU1_Rev+0xc>
		ldr r4,  =0x44444444
fffd4c00:	e59f40b4 	ldr	r4, [pc, #180]	; fffd4cbc <CPU1_Rev+0x10>
		ldr r5,  =0x55555555
fffd4c04:	e59f50b4 	ldr	r5, [pc, #180]	; fffd4cc0 <CPU1_Rev+0x14>
		ldr r6,  =0x66666666
fffd4c08:	e59f60b4 	ldr	r6, [pc, #180]	; fffd4cc4 <CPU1_Rev+0x18>
		ldr r7,  =0x77777777
fffd4c0c:	e59f70b4 	ldr	r7, [pc, #180]	; fffd4cc8 <CPU1_Rev+0x1c>
		ldr r8,  =0x88888888
fffd4c10:	e59f80b4 	ldr	r8, [pc, #180]	; fffd4ccc <CPU1_Rev+0x20>
		ldr r9,  =0x99999999
fffd4c14:	e59f90b4 	ldr	r9, [pc, #180]	; fffd4cd0 <CPU1_Rev+0x24>
		ldr r10, =0xaaaaaaaa
fffd4c18:	e59fa0b4 	ldr	r10, [pc, #180]	; fffd4cd4 <CPU1_Rev+0x28>
		ldr r11, =0xbbbbbbbb
fffd4c1c:	e59fb0b4 	ldr	r11, [pc, #180]	; fffd4cd8 <CPU1_Rev+0x2c>
		ldr r12, =0xcccccccc
fffd4c20:	e59fc0b4 	ldr	r12, [pc, #180]	; fffd4cdc <CPU1_Rev+0x30>
		ldr r12, =0xcccccccc
fffd4c24:	e59fc0b0 	ldr	r12, [pc, #176]	; fffd4cdc <CPU1_Rev+0x30>
		ldr lr,  =0x03000000
fffd4c28:	e3a0e403 	mov	lr, #50331648	; 0x3000000
		ldr ip,  =0x00000001
fffd4c2c:	e3a0c001 	mov	r12, #1

fffd4c30 <CPU1_ON>:
			
CPU1_ON:

		ldrne   r3, [lr, r1, lsl #2]
fffd4c30:	179e3101 	ldrne	r3, [lr, r1, lsl #2]
		SMLAL   r8,r7,r6,r5 
fffd4c34:	e0e78596 	smlal	r8, r7, r6, r5
		subs    ip, ip, #0
fffd4c38:	e25cc000 	subs	r12, r12, #0
		ldr     r4, [lr, r2, lsl #2]
fffd4c3c:	e79e4102 	ldr	r4, [lr, r2, lsl #2]
		SMLALD  r12,r11,r10,r9 
fffd4c40:	e74bc91a 	smlald	r12, r11, r10, r9
		
		ldrne   r3, [lr, r1, lsl #2]
fffd4c44:	179e3101 	ldrne	r3, [lr, r1, lsl #2]
		SMLAL   r8,r7,r6,r5 
fffd4c48:	e0e78596 	smlal	r8, r7, r6, r5
		subs    ip, ip, #0
fffd4c4c:	e25cc000 	subs	r12, r12, #0
		ldr     r4, [lr, r2, lsl #2]
fffd4c50:	e79e4102 	ldr	r4, [lr, r2, lsl #2]
		SMLALD  r12,r11,r10,r9 
fffd4c54:	e74bc91a 	smlald	r12, r11, r10, r9
		
		ldrne   r3, [lr, r1, lsl #2]
fffd4c58:	179e3101 	ldrne	r3, [lr, r1, lsl #2]
		SMLAL   r8,r7,r6,r5 
fffd4c5c:	e0e78596 	smlal	r8, r7, r6, r5
		subs    ip, ip, #0
fffd4c60:	e25cc000 	subs	r12, r12, #0
		ldr     r4, [lr, r2, lsl #2]
fffd4c64:	e79e4102 	ldr	r4, [lr, r2, lsl #2]
		SMLALD  r12,r11,r10,r9 
fffd4c68:	e74bc91a 	smlald	r12, r11, r10, r9
		
		ldrne   r3, [lr, r1, lsl #2]
fffd4c6c:	179e3101 	ldrne	r3, [lr, r1, lsl #2]
		SMLAL   r8,r7,r6,r5 
fffd4c70:	e0e78596 	smlal	r8, r7, r6, r5
		subs    ip, ip, #0
fffd4c74:	e25cc000 	subs	r12, r12, #0
		ldr     r4, [lr, r2, lsl #2]
fffd4c78:	e79e4102 	ldr	r4, [lr, r2, lsl #2]
		SMLALD  r12,r11,r10,r9 
fffd4c7c:	e74bc91a 	smlald	r12, r11, r10, r9
		
		ldrne   r3, [lr, r1, lsl #2]
fffd4c80:	179e3101 	ldrne	r3, [lr, r1, lsl #2]
		SMLAL   r8,r7,r6,r5 
fffd4c84:	e0e78596 	smlal	r8, r7, r6, r5
		subs    ip, ip, #0
fffd4c88:	e25cc000 	subs	r12, r12, #0
		ldr     r4, [lr, r2, lsl #2]
fffd4c8c:	e79e4102 	ldr	r4, [lr, r2, lsl #2]
		SMLALD  r12,r11,r10,r9 
fffd4c90:	e74bc91a 	smlald	r12, r11, r10, r9
		//UMAAL   r4,r3,r2,r1     // Unsigned Multiply Accumulate Accumulate Long //  64-bit(r12,r11) = [32-bit(r0) * 32-bit(r2)] +  32-bit(r11) + 32-bit(r12) // UMAAL<c> <RdLo>,<RdHi>,<Rn>,<Rm>  
		//SUBS    r10,r9,#1
		//SMLAL   r8,r7,r6,r5     // Signed Multiply Accumulate Long // 64 = 64 + 32 x 32
		//SMLALD  r12,r11,r10,r9  // Signed Multiply Accumulate Long Dual // 64 = 64 + 16 x 16 + 16 x 16
		
		SUBS   r0,r0,#1
fffd4c94:	e2500001 	subs	r0, r0, #1
		BNE    CPU1_ON
fffd4c98:	1affffe4 	bne	fffd4c30 <CPU1_ON>
	
		ldr r1, =CPU1_Cmd
fffd4c9c:	e59f103c 	ldr	r1, [pc, #60]	; fffd4ce0 <CPU1_Rev+0x34>
		str r0, [r1] 
fffd4ca0:	e5810000 	str	r0, [r1]
		
		B     CPU1_OFF   
fffd4ca4:	eaffffcb 	b	fffd4bd8 <CPU1_Toggle>

fffd4ca8 <CPU1_Cmd>:
fffd4ca8:	00000000 	.word	0x00000000

fffd4cac <CPU1_Rev>:
fffd4cac:	00000000 	.word	0x00000000
CPU1_Toggle:

CPU1_OFF:  

		// update revision register to indicate test in running 
		ldr r0, =0x12345678
fffd4cb0:	12345678 	.word	0x12345678
		ldr r1, =CPU1_Rev
fffd4cb4:	fffd4cac 	.word	0xfffd4cac
		cmp r0,#0
		beq CPU1_OFF
		
		ldr r1,  =0x00100000
		ldr r2,  =0x00200000
		ldr r3,  =0x33333333
fffd4cb8:	33333333 	.word	0x33333333
		ldr r4,  =0x44444444
fffd4cbc:	44444444 	.word	0x44444444
		ldr r5,  =0x55555555
fffd4cc0:	55555555 	.word	0x55555555
		ldr r6,  =0x66666666
fffd4cc4:	66666666 	.word	0x66666666
		ldr r7,  =0x77777777
fffd4cc8:	77777777 	.word	0x77777777
		ldr r8,  =0x88888888
fffd4ccc:	88888888 	.word	0x88888888
		ldr r9,  =0x99999999
fffd4cd0:	99999999 	.word	0x99999999
		ldr r10, =0xaaaaaaaa
fffd4cd4:	aaaaaaaa 	.word	0xaaaaaaaa
		ldr r11, =0xbbbbbbbb
fffd4cd8:	bbbbbbbb 	.word	0xbbbbbbbb
		ldr r12, =0xcccccccc
fffd4cdc:	cccccccc 	.word	0xcccccccc
		//SMLALD  r12,r11,r10,r9  // Signed Multiply Accumulate Long Dual // 64 = 64 + 16 x 16 + 16 x 16
		
		SUBS   r0,r0,#1
		BNE    CPU1_ON
	
		ldr r1, =CPU1_Cmd
fffd4ce0:	fffd4ca8 	.word	0xfffd4ca8
fffd4ce4:	00000000 	.word	0x00000000

fffd4ce8 <__aeabi_uidiv>:
fffd4ce8:	1e4a      	subs	r2, r1, #1
fffd4cea:	bf08      	it	eq
fffd4cec:	4770      	bxeq	lr
fffd4cee:	f0c0 8124 	bcc.w	fffd4f3a <__aeabi_uidiv+0x252>
fffd4cf2:	4288      	cmp	r0, r1
fffd4cf4:	f240 8116 	bls.w	fffd4f24 <__aeabi_uidiv+0x23c>
fffd4cf8:	4211      	tst	r1, r2
fffd4cfa:	f000 8117 	beq.w	fffd4f2c <__aeabi_uidiv+0x244>
fffd4cfe:	fab0 f380 	clz	r3, r0
fffd4d02:	fab1 f281 	clz	r2, r1
fffd4d06:	eba2 0303 	sub.w	r3, r2, r3
fffd4d0a:	f1c3 031f 	rsb	r3, r3, #31
fffd4d0e:	a204      	add	r2, pc, #16	; (adr r2, fffd4d20 <__aeabi_uidiv+0x38>)
fffd4d10:	eb02 1303 	add.w	r3, r2, r3, lsl #4
fffd4d14:	f04f 0200 	mov.w	r2, #0
fffd4d18:	469f      	mov	pc, r3
fffd4d1a:	bf00      	nop
fffd4d1c:	f3af 8000 	nop.w
fffd4d20:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
fffd4d24:	bf00      	nop
fffd4d26:	eb42 0202 	adc.w	r2, r2, r2
fffd4d2a:	bf28      	it	cs
fffd4d2c:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
fffd4d30:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
fffd4d34:	bf00      	nop
fffd4d36:	eb42 0202 	adc.w	r2, r2, r2
fffd4d3a:	bf28      	it	cs
fffd4d3c:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
fffd4d40:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
fffd4d44:	bf00      	nop
fffd4d46:	eb42 0202 	adc.w	r2, r2, r2
fffd4d4a:	bf28      	it	cs
fffd4d4c:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
fffd4d50:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
fffd4d54:	bf00      	nop
fffd4d56:	eb42 0202 	adc.w	r2, r2, r2
fffd4d5a:	bf28      	it	cs
fffd4d5c:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
fffd4d60:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
fffd4d64:	bf00      	nop
fffd4d66:	eb42 0202 	adc.w	r2, r2, r2
fffd4d6a:	bf28      	it	cs
fffd4d6c:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
fffd4d70:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
fffd4d74:	bf00      	nop
fffd4d76:	eb42 0202 	adc.w	r2, r2, r2
fffd4d7a:	bf28      	it	cs
fffd4d7c:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
fffd4d80:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
fffd4d84:	bf00      	nop
fffd4d86:	eb42 0202 	adc.w	r2, r2, r2
fffd4d8a:	bf28      	it	cs
fffd4d8c:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
fffd4d90:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
fffd4d94:	bf00      	nop
fffd4d96:	eb42 0202 	adc.w	r2, r2, r2
fffd4d9a:	bf28      	it	cs
fffd4d9c:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
fffd4da0:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
fffd4da4:	bf00      	nop
fffd4da6:	eb42 0202 	adc.w	r2, r2, r2
fffd4daa:	bf28      	it	cs
fffd4dac:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
fffd4db0:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
fffd4db4:	bf00      	nop
fffd4db6:	eb42 0202 	adc.w	r2, r2, r2
fffd4dba:	bf28      	it	cs
fffd4dbc:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
fffd4dc0:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
fffd4dc4:	bf00      	nop
fffd4dc6:	eb42 0202 	adc.w	r2, r2, r2
fffd4dca:	bf28      	it	cs
fffd4dcc:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
fffd4dd0:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
fffd4dd4:	bf00      	nop
fffd4dd6:	eb42 0202 	adc.w	r2, r2, r2
fffd4dda:	bf28      	it	cs
fffd4ddc:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
fffd4de0:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
fffd4de4:	bf00      	nop
fffd4de6:	eb42 0202 	adc.w	r2, r2, r2
fffd4dea:	bf28      	it	cs
fffd4dec:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
fffd4df0:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
fffd4df4:	bf00      	nop
fffd4df6:	eb42 0202 	adc.w	r2, r2, r2
fffd4dfa:	bf28      	it	cs
fffd4dfc:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
fffd4e00:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
fffd4e04:	bf00      	nop
fffd4e06:	eb42 0202 	adc.w	r2, r2, r2
fffd4e0a:	bf28      	it	cs
fffd4e0c:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
fffd4e10:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
fffd4e14:	bf00      	nop
fffd4e16:	eb42 0202 	adc.w	r2, r2, r2
fffd4e1a:	bf28      	it	cs
fffd4e1c:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
fffd4e20:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
fffd4e24:	bf00      	nop
fffd4e26:	eb42 0202 	adc.w	r2, r2, r2
fffd4e2a:	bf28      	it	cs
fffd4e2c:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
fffd4e30:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
fffd4e34:	bf00      	nop
fffd4e36:	eb42 0202 	adc.w	r2, r2, r2
fffd4e3a:	bf28      	it	cs
fffd4e3c:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
fffd4e40:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
fffd4e44:	bf00      	nop
fffd4e46:	eb42 0202 	adc.w	r2, r2, r2
fffd4e4a:	bf28      	it	cs
fffd4e4c:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
fffd4e50:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
fffd4e54:	bf00      	nop
fffd4e56:	eb42 0202 	adc.w	r2, r2, r2
fffd4e5a:	bf28      	it	cs
fffd4e5c:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
fffd4e60:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
fffd4e64:	bf00      	nop
fffd4e66:	eb42 0202 	adc.w	r2, r2, r2
fffd4e6a:	bf28      	it	cs
fffd4e6c:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
fffd4e70:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
fffd4e74:	bf00      	nop
fffd4e76:	eb42 0202 	adc.w	r2, r2, r2
fffd4e7a:	bf28      	it	cs
fffd4e7c:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
fffd4e80:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
fffd4e84:	bf00      	nop
fffd4e86:	eb42 0202 	adc.w	r2, r2, r2
fffd4e8a:	bf28      	it	cs
fffd4e8c:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
fffd4e90:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
fffd4e94:	bf00      	nop
fffd4e96:	eb42 0202 	adc.w	r2, r2, r2
fffd4e9a:	bf28      	it	cs
fffd4e9c:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
fffd4ea0:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
fffd4ea4:	bf00      	nop
fffd4ea6:	eb42 0202 	adc.w	r2, r2, r2
fffd4eaa:	bf28      	it	cs
fffd4eac:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
fffd4eb0:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
fffd4eb4:	bf00      	nop
fffd4eb6:	eb42 0202 	adc.w	r2, r2, r2
fffd4eba:	bf28      	it	cs
fffd4ebc:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
fffd4ec0:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
fffd4ec4:	bf00      	nop
fffd4ec6:	eb42 0202 	adc.w	r2, r2, r2
fffd4eca:	bf28      	it	cs
fffd4ecc:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
fffd4ed0:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
fffd4ed4:	bf00      	nop
fffd4ed6:	eb42 0202 	adc.w	r2, r2, r2
fffd4eda:	bf28      	it	cs
fffd4edc:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
fffd4ee0:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
fffd4ee4:	bf00      	nop
fffd4ee6:	eb42 0202 	adc.w	r2, r2, r2
fffd4eea:	bf28      	it	cs
fffd4eec:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
fffd4ef0:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
fffd4ef4:	bf00      	nop
fffd4ef6:	eb42 0202 	adc.w	r2, r2, r2
fffd4efa:	bf28      	it	cs
fffd4efc:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
fffd4f00:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
fffd4f04:	bf00      	nop
fffd4f06:	eb42 0202 	adc.w	r2, r2, r2
fffd4f0a:	bf28      	it	cs
fffd4f0c:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
fffd4f10:	ebb0 0f01 	cmp.w	r0, r1
fffd4f14:	bf00      	nop
fffd4f16:	eb42 0202 	adc.w	r2, r2, r2
fffd4f1a:	bf28      	it	cs
fffd4f1c:	eba0 0001 	subcs.w	r0, r0, r1
fffd4f20:	4610      	mov	r0, r2
fffd4f22:	4770      	bx	lr
fffd4f24:	bf0c      	ite	eq
fffd4f26:	2001      	moveq	r0, #1
fffd4f28:	2000      	movne	r0, #0
fffd4f2a:	4770      	bx	lr
fffd4f2c:	fab1 f281 	clz	r2, r1
fffd4f30:	f1c2 021f 	rsb	r2, r2, #31
fffd4f34:	fa20 f002 	lsr.w	r0, r0, r2
fffd4f38:	4770      	bx	lr
fffd4f3a:	b108      	cbz	r0, fffd4f40 <__aeabi_uidiv+0x258>
fffd4f3c:	f04f 30ff 	mov.w	r0, #4294967295
fffd4f40:	f000 b966 	b.w	fffd5210 <__aeabi_idiv0>

fffd4f44 <__aeabi_uidivmod>:
fffd4f44:	2900      	cmp	r1, #0
fffd4f46:	d0f8      	beq.n	fffd4f3a <__aeabi_uidiv+0x252>
fffd4f48:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
fffd4f4c:	f7ff fecc 	bl	fffd4ce8 <__aeabi_uidiv>
fffd4f50:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
fffd4f54:	fb02 f300 	mul.w	r3, r2, r0
fffd4f58:	eba1 0103 	sub.w	r1, r1, r3
fffd4f5c:	4770      	bx	lr
fffd4f5e:	bf00      	nop

fffd4f60 <__aeabi_idiv>:
fffd4f60:	2900      	cmp	r1, #0
fffd4f62:	f000 813e 	beq.w	fffd51e2 <.divsi3_skip_div0_test+0x27c>

fffd4f66 <.divsi3_skip_div0_test>:
fffd4f66:	ea80 0c01 	eor.w	r12, r0, r1
fffd4f6a:	bf48      	it	mi
fffd4f6c:	4249      	negmi	r1, r1
fffd4f6e:	1e4a      	subs	r2, r1, #1
fffd4f70:	f000 811f 	beq.w	fffd51b2 <.divsi3_skip_div0_test+0x24c>
fffd4f74:	0003      	movs	r3, r0
fffd4f76:	bf48      	it	mi
fffd4f78:	4243      	negmi	r3, r0
fffd4f7a:	428b      	cmp	r3, r1
fffd4f7c:	f240 811e 	bls.w	fffd51bc <.divsi3_skip_div0_test+0x256>
fffd4f80:	4211      	tst	r1, r2
fffd4f82:	f000 8123 	beq.w	fffd51cc <.divsi3_skip_div0_test+0x266>
fffd4f86:	fab3 f283 	clz	r2, r3
fffd4f8a:	fab1 f081 	clz	r0, r1
fffd4f8e:	eba0 0202 	sub.w	r2, r0, r2
fffd4f92:	f1c2 021f 	rsb	r2, r2, #31
fffd4f96:	a004      	add	r0, pc, #16	; (adr r0, fffd4fa8 <.divsi3_skip_div0_test+0x42>)
fffd4f98:	eb00 1202 	add.w	r2, r0, r2, lsl #4
fffd4f9c:	f04f 0000 	mov.w	r0, #0
fffd4fa0:	4697      	mov	pc, r2
fffd4fa2:	bf00      	nop
fffd4fa4:	f3af 8000 	nop.w
fffd4fa8:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
fffd4fac:	bf00      	nop
fffd4fae:	eb40 0000 	adc.w	r0, r0, r0
fffd4fb2:	bf28      	it	cs
fffd4fb4:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
fffd4fb8:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
fffd4fbc:	bf00      	nop
fffd4fbe:	eb40 0000 	adc.w	r0, r0, r0
fffd4fc2:	bf28      	it	cs
fffd4fc4:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
fffd4fc8:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
fffd4fcc:	bf00      	nop
fffd4fce:	eb40 0000 	adc.w	r0, r0, r0
fffd4fd2:	bf28      	it	cs
fffd4fd4:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
fffd4fd8:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
fffd4fdc:	bf00      	nop
fffd4fde:	eb40 0000 	adc.w	r0, r0, r0
fffd4fe2:	bf28      	it	cs
fffd4fe4:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
fffd4fe8:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
fffd4fec:	bf00      	nop
fffd4fee:	eb40 0000 	adc.w	r0, r0, r0
fffd4ff2:	bf28      	it	cs
fffd4ff4:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
fffd4ff8:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
fffd4ffc:	bf00      	nop
fffd4ffe:	eb40 0000 	adc.w	r0, r0, r0
fffd5002:	bf28      	it	cs
fffd5004:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
fffd5008:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
fffd500c:	bf00      	nop
fffd500e:	eb40 0000 	adc.w	r0, r0, r0
fffd5012:	bf28      	it	cs
fffd5014:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
fffd5018:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
fffd501c:	bf00      	nop
fffd501e:	eb40 0000 	adc.w	r0, r0, r0
fffd5022:	bf28      	it	cs
fffd5024:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
fffd5028:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
fffd502c:	bf00      	nop
fffd502e:	eb40 0000 	adc.w	r0, r0, r0
fffd5032:	bf28      	it	cs
fffd5034:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
fffd5038:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
fffd503c:	bf00      	nop
fffd503e:	eb40 0000 	adc.w	r0, r0, r0
fffd5042:	bf28      	it	cs
fffd5044:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
fffd5048:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
fffd504c:	bf00      	nop
fffd504e:	eb40 0000 	adc.w	r0, r0, r0
fffd5052:	bf28      	it	cs
fffd5054:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
fffd5058:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
fffd505c:	bf00      	nop
fffd505e:	eb40 0000 	adc.w	r0, r0, r0
fffd5062:	bf28      	it	cs
fffd5064:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
fffd5068:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
fffd506c:	bf00      	nop
fffd506e:	eb40 0000 	adc.w	r0, r0, r0
fffd5072:	bf28      	it	cs
fffd5074:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
fffd5078:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
fffd507c:	bf00      	nop
fffd507e:	eb40 0000 	adc.w	r0, r0, r0
fffd5082:	bf28      	it	cs
fffd5084:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
fffd5088:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
fffd508c:	bf00      	nop
fffd508e:	eb40 0000 	adc.w	r0, r0, r0
fffd5092:	bf28      	it	cs
fffd5094:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
fffd5098:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
fffd509c:	bf00      	nop
fffd509e:	eb40 0000 	adc.w	r0, r0, r0
fffd50a2:	bf28      	it	cs
fffd50a4:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
fffd50a8:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
fffd50ac:	bf00      	nop
fffd50ae:	eb40 0000 	adc.w	r0, r0, r0
fffd50b2:	bf28      	it	cs
fffd50b4:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
fffd50b8:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
fffd50bc:	bf00      	nop
fffd50be:	eb40 0000 	adc.w	r0, r0, r0
fffd50c2:	bf28      	it	cs
fffd50c4:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
fffd50c8:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
fffd50cc:	bf00      	nop
fffd50ce:	eb40 0000 	adc.w	r0, r0, r0
fffd50d2:	bf28      	it	cs
fffd50d4:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
fffd50d8:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
fffd50dc:	bf00      	nop
fffd50de:	eb40 0000 	adc.w	r0, r0, r0
fffd50e2:	bf28      	it	cs
fffd50e4:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
fffd50e8:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
fffd50ec:	bf00      	nop
fffd50ee:	eb40 0000 	adc.w	r0, r0, r0
fffd50f2:	bf28      	it	cs
fffd50f4:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
fffd50f8:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
fffd50fc:	bf00      	nop
fffd50fe:	eb40 0000 	adc.w	r0, r0, r0
fffd5102:	bf28      	it	cs
fffd5104:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
fffd5108:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
fffd510c:	bf00      	nop
fffd510e:	eb40 0000 	adc.w	r0, r0, r0
fffd5112:	bf28      	it	cs
fffd5114:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
fffd5118:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
fffd511c:	bf00      	nop
fffd511e:	eb40 0000 	adc.w	r0, r0, r0
fffd5122:	bf28      	it	cs
fffd5124:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
fffd5128:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
fffd512c:	bf00      	nop
fffd512e:	eb40 0000 	adc.w	r0, r0, r0
fffd5132:	bf28      	it	cs
fffd5134:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
fffd5138:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
fffd513c:	bf00      	nop
fffd513e:	eb40 0000 	adc.w	r0, r0, r0
fffd5142:	bf28      	it	cs
fffd5144:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
fffd5148:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
fffd514c:	bf00      	nop
fffd514e:	eb40 0000 	adc.w	r0, r0, r0
fffd5152:	bf28      	it	cs
fffd5154:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
fffd5158:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
fffd515c:	bf00      	nop
fffd515e:	eb40 0000 	adc.w	r0, r0, r0
fffd5162:	bf28      	it	cs
fffd5164:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
fffd5168:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
fffd516c:	bf00      	nop
fffd516e:	eb40 0000 	adc.w	r0, r0, r0
fffd5172:	bf28      	it	cs
fffd5174:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
fffd5178:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
fffd517c:	bf00      	nop
fffd517e:	eb40 0000 	adc.w	r0, r0, r0
fffd5182:	bf28      	it	cs
fffd5184:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
fffd5188:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
fffd518c:	bf00      	nop
fffd518e:	eb40 0000 	adc.w	r0, r0, r0
fffd5192:	bf28      	it	cs
fffd5194:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
fffd5198:	ebb3 0f01 	cmp.w	r3, r1
fffd519c:	bf00      	nop
fffd519e:	eb40 0000 	adc.w	r0, r0, r0
fffd51a2:	bf28      	it	cs
fffd51a4:	eba3 0301 	subcs.w	r3, r3, r1
fffd51a8:	f1bc 0f00 	cmp.w	r12, #0
fffd51ac:	bf48      	it	mi
fffd51ae:	4240      	negmi	r0, r0
fffd51b0:	4770      	bx	lr
fffd51b2:	ea9c 0f00 	teq	r12, r0
fffd51b6:	bf48      	it	mi
fffd51b8:	4240      	negmi	r0, r0
fffd51ba:	4770      	bx	lr
fffd51bc:	bf38      	it	cc
fffd51be:	2000      	movcc	r0, #0
fffd51c0:	bf04      	itt	eq
fffd51c2:	ea4f 70ec 	moveq.w	r0, r12, asr #31
fffd51c6:	f040 0001 	orreq.w	r0, r0, #1
fffd51ca:	4770      	bx	lr
fffd51cc:	fab1 f281 	clz	r2, r1
fffd51d0:	f1c2 021f 	rsb	r2, r2, #31
fffd51d4:	f1bc 0f00 	cmp.w	r12, #0
fffd51d8:	fa23 f002 	lsr.w	r0, r3, r2
fffd51dc:	bf48      	it	mi
fffd51de:	4240      	negmi	r0, r0
fffd51e0:	4770      	bx	lr
fffd51e2:	2800      	cmp	r0, #0
fffd51e4:	bfc8      	it	gt
fffd51e6:	f06f 4000 	mvngt.w	r0, #2147483648	; 0x80000000
fffd51ea:	bfb8      	it	lt
fffd51ec:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
fffd51f0:	f000 b80e 	b.w	fffd5210 <__aeabi_idiv0>

fffd51f4 <__aeabi_idivmod>:
fffd51f4:	2900      	cmp	r1, #0
fffd51f6:	d0f4      	beq.n	fffd51e2 <.divsi3_skip_div0_test+0x27c>
fffd51f8:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
fffd51fc:	f7ff feb3 	bl	fffd4f66 <.divsi3_skip_div0_test>
fffd5200:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
fffd5204:	fb02 f300 	mul.w	r3, r2, r0
fffd5208:	eba1 0103 	sub.w	r1, r1, r3
fffd520c:	4770      	bx	lr
fffd520e:	bf00      	nop

fffd5210 <__aeabi_idiv0>:
fffd5210:	4770      	bx	lr
fffd5212:	bf00      	nop

Disassembly of section rodata:

fffd5214 <__FUNCTION__.5796>:
fffd5214:	6144 6174 6241 726f 5274 756f 6974 656e     DataAbortRoutine
	...

fffd5225 <__FUNCTION__.5800>:
fffd5225:	6e55 6564 6966 656e 4964 736e 7274 6375     UndefinedInstruc
fffd5235:	6974 6e6f 6f52 7475 6e69 0065               tionRoutine.

fffd5241 <__FUNCTION__.5804>:
fffd5241:	7250 6665 7465 6863 6241 726f 5274 756f     PrefetchAbortRou
fffd5251:	6974 656e 0a00 2a2a 2a2a 202a 4146 4c49     tine..***** FAIL
fffd5261:	5255 2045 2a2a 2a2a 202a 7461 0a3a 7325     URE ***** at:.%s
fffd5271:	2528 2964 2528 2973 0a3a 6d00 6961 2e6e     (%d)(%s):..main.
fffd5281:	0063 4927 5152 2027 7665 6e65 2074 6168     c.'IRQ' event ha
fffd5291:	2073 6562 6e65 7420 6972 6767 7265 6465     s been triggered
fffd52a1:	6120 2074 6461 7264 7365 2073 7830 3025      at address 0x%0
fffd52b1:	6c38 2e58 0a20 2700 4946 2751 6520 6576     8lX. ..'FIQ' eve
fffd52c1:	746e 6820 7361 6220 6565 206e 7274 6769     nt has been trig
fffd52d1:	6567 6572 2064 7461 6120 6464 6572 7373     gered at address
fffd52e1:	3020 2578 3830 586c 202e 000a 5527 646e      0x%08lX. ..'Und
fffd52f1:	6665 6e69 6465 4920 736e 7274 6375 6974     efined Instructi
fffd5301:	6e6f 2027 7665 6e65 2074 6168 2073 6562     on' event has be
fffd5311:	6e65 7420 6972 6767 7265 6465 6120 2074     en triggered at 
fffd5321:	6461 7264 7365 2073 7830 3025 6c38 2058     address 0x%08lX 
fffd5331:	6e69 4120 4d52 7320 6174 6574 6f20 2072     in ARM state or 
fffd5341:	7830 3025 6c38 2058 6e69 5420 7568 626d     0x%08lX in Thumb
fffd5351:	7320 6174 6574 202e 000a 5027 6572 662d      state. ..'Pre-f
fffd5361:	7465 6863 4120 6f62 7472 2027 7665 6e65     etch Abort' even
fffd5371:	2074 6168 2073 6562 6e65 7420 6972 6767     t has been trigg
fffd5381:	7265 6465 6120 2074 6461 7264 7365 2073     ered at address 
fffd5391:	7830 3025 6c38 2e58 0a20 2700 5653 2743     0x%08lX. ..'SVC'
fffd53a1:	6520 6576 746e 6820 7361 6220 6565 206e      event has been 
fffd53b1:	7274 6769 6567 6572 2064 7266 6d6f 6120     triggered from a
fffd53c1:	6464 6572 7373 3020 2578 3830 586c 202e     ddress 0x%08lX. 
fffd53d1:	000a 4427 7461 2061 6241 726f 2774 6520     ..'Data Abort' e
fffd53e1:	6576 746e 6820 7361 6220 6565 206e 7274     vent has been tr
fffd53f1:	6769 6567 6572 2064 7461 6120 6464 6572     iggered at addre
fffd5401:	7373 3020 2578 3830 586c 202e 000a 2020     ss 0x%08lX. ..  
fffd5411:	202a 4c50 434c 4e4f 7525 3d20 3020 2578     * PLLCON%u = 0x%
fffd5421:	3830 586c 202e 2000 5028 4c4c 6920 2073     08lX. . (PLL is 
fffd5431:	6e69 5020 776f 7265 442d 776f 296e 0a2e     in Power-Down)..
fffd5441:	2000 2528 756c 4d20 7a48 203b 5000 4c4c     . (%lu MHz; .PLL
fffd5451:	6920 2073 6f6e 2074 6f6c 6b63 6465 3e00      is not locked.>
fffd5461:	5020 4c4c 2073 6e61 2064 6c43 636f 736b      PLLs and Clocks
fffd5471:	203a 000a 2020 202a 4c43 534b 4c45 3d20     : ..  * CLKSEL =
fffd5481:	3020 2578 3830 586c 0a20 2000 2020 2d20      0x%08lX ..    -
fffd5491:	4320 5550 4320 6f6c 6b63 5320 756f 6372      CPU Clock Sourc
fffd54a1:	2065 4328 5550 4b43 4553 294c 3d20 203e     e (CPUCKSEL) => 
fffd54b1:	5000 4c4c 3020 202e 000a 4c50 204c 2e31     .PLL 0. ..PLL 1.
fffd54c1:	0a20 4300 4b4c 4552 2046 6c63 636f 206b      ..CLKREF clock 
fffd54d1:	6428 6265 6775 2e29 0a20 4200 7079 7361     (debug). ..Bypas
fffd54e1:	2073 6c63 636f 206b 7266 6d6f 7020 6e69     s clock from pin
fffd54f1:	5320 5359 5042 4b43 2820 6564 7562 2967      SYSBPCK (debug)
fffd5501:	202e 000a 2020 2020 202d 654d 6f6d 7972     . ..    - Memory
fffd5511:	4320 6e6f 7274 6c6f 656c 2072 6c43 636f      Controller Cloc
fffd5521:	206b 6f53 7275 6563 2820 434d 4b43 4553     k Source (MCCKSE
fffd5531:	294c 3d20 203e 4300 4b4c 4552 2046 6c43     L) => .CLKREF Cl
fffd5541:	636f 206b 6428 6265 6775 2e29 0a20 4d00     ock (debug). ..M
fffd5551:	4243 4350 204b 6c43 636f 206b 6428 6265     CBPCK Clock (deb
fffd5561:	6775 2e29 0a20 4900 766e 6c61 6469 7320     ug). ..Invalid s
fffd5571:	756f 6372 2e65 2000 2a20 4320 4b4c 4944     ource..  * CLKDI
fffd5581:	3156 3d20 3020 2578 3830 586c 0a20 2000     V1 = 0x%08lX .. 
fffd5591:	2020 2d20 4320 4b4c 2832 5841 3149 2936        - CLK2(AXI16)
fffd55a1:	3d20 4320 5550 6320 6f6c 6b63 202e 000a      = CPU clock. ..
fffd55b1:	2020 2020 202d 4c43 324b 4128 4958 3631         - CLK2(AXI16
fffd55c1:	2029 203d 5043 2055 6c63 636f 206b 322f     ) = CPU clock /2
fffd55d1:	202e 0a20 2000 2020 2d20 4320 4b4c 2034     .  ..    - CLK4 
fffd55e1:	203d 4c43 324b 2029 000a 2020 2020 202d     = CLK2) ..    - 
fffd55f1:	4c43 344b 3d20 4320 4b4c 2f32 2932 0a20     CLK4 = CLK2/2) .
fffd5601:	2000 2020 2d20 4320 4b4c 2034 203d 4c43     .    - CLK4 = CL
fffd5611:	324b 332f 2029 000a 2020 2020 202d 4c43     K2/3) ..    - CL
fffd5621:	344b 3d20 4320 4b4c 2f32 2934 0a20 2000     K4 = CLK2/4) .. 
fffd5631:	2a20 4320 4b4c 4944 3256 3d20 3020 2578      * CLKDIV2 = 0x%
fffd5641:	3830 586c 0a20 2000 2a20 4320 4b4c 4944     08lX ..  * CLKDI
fffd5651:	3356 3d20 3020 2578 3830 586c 0a20 2000     V3 = 0x%08lX .. 
fffd5661:	7542 6c69 2064 6144 6574 203a 7325 252c     Build Date: %s,%
fffd5671:	2073 6977 6874 4720 4343 2520 2e75 7525     s with GCC %u.%u
fffd5681:	252e 2075 4a00 6c75 2020 2031 3032 3032     .%u .Jul  1 2020
fffd5691:	3000 3a39 3831 303a 0037 203e 764f 7265     .09:18:07.> Over
fffd56a1:	6972 6564 7620 6365 6f74 2072 6174 6c62     ride vector tabl
fffd56b1:	2e65 000a 2020 3e3e 5320 7465 4320 5550     e...  >> Set CPU
fffd56c1:	7620 6365 6f74 2072 6174 6c62 2065 6f74      vector table to
fffd56d1:	6120 6464 6572 7373 3020 3078 3030 5f30      address 0x0000_
fffd56e1:	3030 3030 202e 000a 2020 3e3e 4d20 7061     0000. ..  >> Map
fffd56f1:	6570 2064 6966 7372 2074 3532 2036 7962     ped first 256 by
fffd5701:	6574 2073 666f 6120 6464 6572 7373 3020     tes of address 0
fffd5711:	4678 4646 5f46 3030 3030 7420 206f 6461     xFFFF_0000 to ad
fffd5721:	7264 7365 2073 7830 4646 4446 305f 3030     dress 0xFFFD_000
fffd5731:	2e30 0a20 2000 3e20 203e 6553 2074 5043     0. ..  >> Set CP
fffd5741:	2055 6576 7463 726f 7420 6261 656c 7420     U vector table t
fffd5751:	206f 6461 7264 7365 2073 7830 4646 4646     o address 0xFFFF
fffd5761:	305f 3030 2e30 0a20 3e00 4320 646f 2065     _0000. ..> Code 
fffd5771:	7473 7261 2d74 7075 6120 2074 6461 7264     start-up at addr
fffd5781:	7365 2073 7830 3025 6c38 2e58 0a20 2000     ess 0x%08lX. .. 
fffd5791:	4320 646f 2065 6177 2073 6f6e 2074 6f63      Code was not co
fffd57a1:	706d 6c69 6465 7420 206f 6461 7264 7365     mpiled to addres
fffd57b1:	2073 7830 3030 3030 3030 3030 6f20 2072     s 0x00000000 or 
fffd57c1:	7830 4646 4446 3030 3030 203b 6e69 6574     0xFFFD0000; inte
fffd57d1:	7272 7075 7374 7720 6c69 206c 6f6e 2074     rrupts will not 
fffd57e1:	6f77 6b72 7520 6c6e 7365 2073 6f63 6564     work unless code
fffd57f1:	7620 6365 6f74 2072 6174 6c62 2065 7261      vector table ar
fffd5801:	2065 6f63 6970 6465 2120 0a20 2000 4d42     e copied ! .. BM
fffd5811:	2043 6e49 6f66 6d72 7461 6f69 206e 3e00     C Information .>
fffd5821:	4520 7272 726f 203a 6f46 6e75 2064 504e      Error: Found NP
fffd5831:	4d43 6d37 786e 4220 434d 6320 6968 2070     CM7mnx BMC chip 
fffd5841:	6576 7372 6f69 206e 315a 0a2e 3e00 4620     version Z1...> F
fffd5851:	756f 646e 4e20 4350 374d 6e6d 2078 4d42     ound NPCM7mnx BM
fffd5861:	2043 6863 7069 7620 7265 6973 6e6f 4120     C chip version A
fffd5871:	2e31 000a 203e 5043 2055 5043 3531 5320     1...> CPU CP15 S
fffd5881:	5443 524c 203a 7830 3025 6c38 2058 000a     CTLR: 0x%08lX ..
fffd5891:	7245 6f72 3a72 5520 6b6e 6f6e 6e77 4e20     Error: Unknown N
fffd58a1:	4350 374d 6e6d 2078 4d42 2043 6863 7069     PCM7mnx BMC chip
fffd58b1:	7620 7265 6973 6e6f 202e 6f46 6e75 2064      version. Found 
fffd58c1:	4450 4449 303d 2578 3830 586c 000a 2020     PDID=0x%08lX..  
fffd58d1:	3e20 203e 4d4d 2055 7369 6520 616e 6c62      >> MMU is enabl
fffd58e1:	2e65 000a 2020 3e20 203e 4d4d 2055 7369     e...   >> MMU is
fffd58f1:	6420 7369 6261 656c 0a2e 2000 2020 3e3e      disable...   >>
fffd5901:	4420 7461 2061 6163 6863 6e69 2067 7369      Data caching is
fffd5911:	6520 616e 6c62 2e65 000a 2020 3e20 203e      enable...   >> 
fffd5921:	6144 6174 6320 6361 6968 676e 6920 2073     Data caching is 
fffd5931:	6964 6173 6c62 2e65 000a 2020 3e20 203e     disable...   >> 
fffd5941:	7250 676f 6172 206d 6c66 776f 7020 6572     Program flow pre
fffd5951:	6964 7463 6f69 206e 7369 6520 616e 6c62     diction is enabl
fffd5961:	2e65 000a 2020 3e20 203e 7250 676f 6172     e...   >> Progra
fffd5971:	206d 6c66 776f 7020 6572 6964 7463 6f69     m flow predictio
fffd5981:	206e 7369 6420 7369 6261 656c 0a2e 2000     n is disable... 
fffd5991:	2020 3e3e 4920 736e 7274 6375 6974 6e6f       >> Instruction
fffd59a1:	6320 6361 6968 676e 6920 2073 6e65 6261      caching is enab
fffd59b1:	656c 0a2e 2000 2020 3e3e 4920 736e 7274     le...   >> Instr
fffd59c1:	6375 6974 6e6f 6320 6361 6968 676e 6920     uction caching i
fffd59d1:	2073 6964 6173 6c62 2e65 000a 2020 3e20     s disable...   >
fffd59e1:	203e 6948 6867 6520 6378 7065 6974 6e6f     > High exception
fffd59f1:	7620 6365 6f74 7372 202c 6948 6576 7363      vectors, Hivecs
fffd5a01:	202c 6162 6573 6120 6464 6572 7373 3020     , base address 0
fffd5a11:	4678 4646 3046 3030 2e30 000a 2020 3e20     xFFFF0000...   >
fffd5a21:	203e 6f4e 6d72 6c61 6520 6378 7065 6974     > Normal excepti
fffd5a31:	6e6f 7620 6365 6f74 7372 202c 6162 6573     on vectors, base
fffd5a41:	6120 6464 6572 7373 3020 3078 3030 3030      address 0x00000
fffd5a51:	3030 2e30 000a                              000...

fffd5a57 <__FUNCTION__.5808>:
fffd5a57:	7653 5263 756f 6974 656e 4600                    SvcRoutine.

fffd5a62 <__FUNCTION__.5792>:
fffd5a62:	6946 5271 756f 6974 656e 4900                    FiqRoutine.

fffd5a6d <__FUNCTION__.5788>:
fffd5a6d:	7249 5271 756f 6974 656e 4300                    IrqRoutine.

fffd5a78 <__FUNCTION__.5844>:
fffd5a78:	6843 6365 5f6b 6c43 636f 736b 0900               Check_Clocks.

fffd5a85 <CL>:
fffd5a85:	0a09 0c0b 0e0d 100f 1412 1816 0000 0000     ................

fffd5a95 <__FUNCTION__.6200>:
fffd5a95:	7256 6665 5144 435f 6e6f 6576 7472 6d5f     VrefDQ_Convert_m
fffd5aa5:	5f56 6f74 535f 6574 5f70 6152 676e 0065     V_to_Step_Range.
fffd5ab5:	3e0a 4620 756f 646e 4d20 554d 6920 2073     .> Found MMU is 
fffd5ac5:	6e65 6261 656c 202e 4c54 7342 6d20 7375     enable. TLBs mus
fffd5ad5:	2074 6562 7220 6c65 636f 7461 6465 202e     t be relocated. 
fffd5ae5:	000a 614d 6e69 654d 756e 632e 2000 5454     ..MainMenu.c. TT
fffd5af5:	5242 2e30 204e 7369 6e20 746f 3020 203b     BR0.N is not 0; 
fffd5b05:	6f64 276e 2074 6e6b 776f 6820 776f 7420     don't know how t
fffd5b15:	206f 6572 6f6c 6163 6574 5420 424c 2e73     o relocate TLBs.
fffd5b25:	0020 2020 3e3e 4320 7275 6572 746e 6120      .  >> Current a
fffd5b35:	6464 6572 7373 203a 7830 3025 6c38 3b58     ddress: 0x%08lX;
fffd5b45:	5320 7a69 3a65 3120 4b36 2e42 0a20 2000      Size: 16KB. .. 
fffd5b55:	3e20 203e 6552 6f6c 6163 6574 6120 6464      >> Relocate add
fffd5b65:	6572 7373 203a 7830 3025 6c38 2e58 0a20     ress: 0x%08lX. .
fffd5b75:	2000 6146 6c69 6465 7420 206f 6f63 7970     . Failed to copy
fffd5b85:	5420 424c 2e73 0020 2020 3e3e 4420 6e6f      TLBs. .  >> Don
fffd5b95:	2e65 0a20 0a00 200a 7325 0a20 2000 7753     e. .... %s .. Sw
fffd5ba5:	6565 2070 6e49 7570 2074 5144 4420 6c65     eep Input DQ Del
fffd5bb5:	7961 5220 6c65 7461 7669 2065 6f74 4420     ay Relative to D
fffd5bc5:	5351 2820 7325 0029 203e 664f 7366 7465     QS (%s).> Offset
fffd5bd5:	2520 6433 203a 7830 3025 5834 0a20 2d00      %3d: 0x%04X ..-
fffd5be5:	2d2d 2d2d 2d2d 2d2d 202d 000a 2d2d 202d     --------- ..--- 
fffd5bf5:	7274 6d69 6c20 6d69 7469 2d20 2d2d 2820     trim limit --- (
fffd5c05:	7144 7254 6d69 695f 746e 253a 2c64 6920     DqTrim_int:%d, i
fffd5c15:	616c 656e 253a 2c75 6920 6962 3a74 7525     lane:%u, ibit:%u
fffd5c25:	2029 000a 2d2d 202d 6564 616c 2d79 696c     ) ..--- delay-li
fffd5c35:	656e 6c20 6d69 7469 2d20 2d2d 2820 6544     ne limit --- (De
fffd5c45:	616c 4c79 6e69 3a65 6425 202c 7144 7254     layLine:%d, DqTr
fffd5c55:	6d69 253a 2c64 4420 7371 7254 6d69 253a     im:%d, DqsTrim:%
fffd5c65:	2c64 6920 616c 656e 253a 2c75 6920 6962     d, ilane:%u, ibi
fffd5c75:	3a74 7525 2029 000a 2528 2973 4920 706e     t:%u) ..(%s) Inp
fffd5c85:	7475 5144 4d20 7261 6967 3a6e 4d20 6e69     utDQ Margin: Min
fffd5c95:	7220 7165 6975 6572 3a64 2b20 2d2f 7525      required: +/-%u
fffd5ca5:	203b 4d20 6165 7573 6572 3a64 2d20 7525     ;  Measured: -%u
fffd5cb5:	2b2f 7525 202e 2000 3d3d 203e 4150 5353     /+%u. . ==> PASS
fffd5cc5:	0a20 000a 3d20 3e3d 4620 4941 204c 0a0a      ... ==> FAIL ..
fffd5cd5:	2000 7753 6565 2070 6f52 6e75 2d64 7254     . Sweep Round-Tr
fffd5ce5:	7069 4420 6c65 7961 2820 7325 2029 2d00     ip Delay (%s) .-
fffd5cf5:	2d2d 7420 6972 206d 696c 696d 2074 2d2d     -- trim limit --
fffd5d05:	202d 4428 7371 7254 6d69 253a 2c64 6920     - (DqsTrim:%d, i
fffd5d15:	616c 656e 253a 2c75 6920 6962 3a74 7525     lane:%u, ibit:%u
fffd5d25:	2029 000a 2528 2973 5220 756f 646e 542d     ) ..(%s) Round-T
fffd5d35:	6972 2070 614d 6772 6e69 203a 4d20 6e69     rip Margin:  Min
fffd5d45:	7220 7165 6975 6572 3a64 2b20 2d2f 7525      required: +/-%u
fffd5d55:	203b 4d20 6165 7573 6572 3a64 2d20 7525     ;  Measured: -%u
fffd5d65:	2b2f 7525 202e 2000 7753 6565 2070 754f     /+%u. . Sweep Ou
fffd5d75:	7074 7475 4420 2051 6544 616c 2079 6552     tput DQ Delay Re
fffd5d85:	616c 6974 6576 7420 206f 5144 2053 2528     lative to DQS (%
fffd5d95:	2973 2800 7325 2029 754f 7074 7475 5144     s).(%s) OutputDQ
fffd5da5:	4d20 7261 6967 3a6e 4d20 6e69 7220 7165      Margin: Min req
fffd5db5:	6975 6572 3a64 2b20 2d2f 7525 203b 4d20     uired: +/-%u;  M
fffd5dc5:	6165 7573 6572 3a64 2d20 7525 2b2f 7525     easured: -%u/+%u
fffd5dd5:	202e 5700 6972 6574 6f4d 6564 6552 3a67     . .WriteModeReg:
fffd5de5:	543a 6d69 4f65 7475 000a 4544 414e 494c     :TimeOut..DENALI
fffd5df5:	435f 4c54 315f 3631 3d20 3020 2578 3830     _CTL_116 = 0x%08
fffd5e05:	586c 0a20 4400 4e45 4c41 5f49 5443 5f4c     lX ..DENALI_CTL_
fffd5e15:	3137 3d20 3020 2578 3830 586c 0a20 2000     71 = 0x%08lX .. 
fffd5e25:	4444 3452 5020 5948 4920 666e 726f 616d     DDR4 PHY Informa
fffd5e35:	6974 6e6f 0020 203e 6c43 636f 206b 7266     tion .> Clock fr
fffd5e45:	7165 6575 636e 3a79 0a20 3e00 5020 5948     equency: ..> PHY
fffd5e55:	5220 7665 7369 6f69 3a6e 3020 2578 3830      Revision: 0x%08
fffd5e65:	586c 0a20 3e00 4520 4343 6920 2073 464f     lX ..> ECC is OF
fffd5e75:	2e46 0a20 3e00 4520 4343 6920 2073 4e4f     F. ..> ECC is ON
fffd5e85:	202e 000a 2020 3e3e 5520 636e 726f 6572     . ..  >> Uncorre
fffd5e95:	7463 6261 656c 4520 4343 6520 7272 726f     ctable ECC error
fffd5ea5:	3a73 4120 6464 3a72 7830 3025 6c38 2c58     s: Addr:0x%08lX,
fffd5eb5:	4420 7461 3a61 7830 3025 6c38 2e58 000a      Data:0x%08lX...
fffd5ec5:	2020 3e3e 4320 726f 6572 7463 6261 656c       >> Correctable
fffd5ed5:	4520 4343 6520 7272 726f 3a73 2020 4120      ECC errors:   A
fffd5ee5:	6464 3a72 7830 3025 6c38 2c58 4420 7461     ddr:0x%08lX, Dat
fffd5ef5:	3a61 7830 3025 6c38 2e58 000a 203e 6553     a:0x%08lX...> Se
fffd5f05:	666c 432d 6e6f 6966 7567 6972 676e 4c20     lf-Configuring L
fffd5f15:	676f 6369 2820 4353 294c 202c 7257 7469     ogic (SCL), Writ
fffd5f25:	2d65 654c 6576 696c 676e 6120 646e 5220     e-Leveling and R
fffd5f35:	6165 2f64 7257 7469 2065 6942 2d74 654c     ead/Write Bit-Le
fffd5f45:	6576 696c 676e 7320 6174 7574 3a73 0a20     veling status: .
fffd5f55:	2000 3e20 203e 616c 656e 7525 203a 6146     .  >> lane%u: Fa
fffd5f65:	6c69 6465 0a2e 2000 3e20 203e 616c 656e     iled...  >> lane
fffd5f75:	7525 203a 6150 7373 6465 0a2e 3e00 4420     %u: Passed...> D
fffd5f85:	4353 5f4c 4e43 2054 3028 3678 2937 3d20     SCL_CNT (0x67) =
fffd5f95:	3020 2578 3830 586c 0a20 2000 3e20 203e      0x%08lX ..  >> 
fffd5fa5:	7944 616e 696d 2063 4353 204c 7369 4f20     Dynamic SCL is O
fffd5fb5:	4646 2120 000a 2020 3e3e 4420 6e79 6d61     FF !..  >> Dynam
fffd5fc5:	6369 5320 4c43 6920 2073 4e4f 202e 000a     ic SCL is ON. ..
fffd5fd5:	2020 3e3e 6420 6373 5f6c 7865 5f70 6e63       >> dscl_exp_cn
fffd5fe5:	2074 203d 6c25 2075 2078 3532 2036 4850     t = %lu x 256 PH
fffd5ff5:	2059 6c63 636f 206b 7963 6c63 7365 202e     Y clock cycles. 
fffd6005:	000a 2020 3e3e 6420 6373 5f6c 6173 6576     ..  >> dscl_save
fffd6015:	725f 7365 6f74 6572 6e5f 6565 6564 2064     _restore_needed 
fffd6025:	203d 2e31 0a20 2000 3e20 203e 7364 6c63     = 1. ..  >> dscl
fffd6035:	735f 7661 5f65 6572 7473 726f 5f65 656e     _save_restore_ne
fffd6045:	6465 6465 3d20 3020 202e 5028 5948 535f     eded = 0. (PHY_S
fffd6055:	4c43 535f 4154 5452 415f 4444 2052 203d     CL_START_ADDR = 
fffd6065:	7830 3025 6c38 3b58 4120 7463 6175 206c     0x%08lX; Actual 
fffd6075:	6441 7264 3d20 3020 2578 3830 586c 2e29     Addr = 0x%08lX).
fffd6085:	0a20 2000 3e20 203e 7944 616e 696d 2063      ..  >> Dynamic 
fffd6095:	4353 204c 6977 6874 756f 2074 6942 2d74     SCL without Bit-
fffd60a5:	654c 6576 6c6c 6e69 2e67 0a20 2000 3e20     Levelling. ..  >
fffd60b5:	203e 7944 616e 696d 2063 4353 204c 6977     > Dynamic SCL wi
fffd60c5:	6874 4220 7469 4c2d 7665 6c65 696c 676e     th Bit-Levelling
fffd60d5:	202e 000a 2020 3e3e 4420 6e79 6d61 6369     . ..  >> Dynamic
fffd60e5:	5320 4c43 7720 7469 6f68 7475 5720 6972      SCL without Wri
fffd60f5:	6574 4220 7469 4c2d 7665 6c65 696c 676e     te Bit-Levelling
fffd6105:	202e 000a 2020 3e3e 4420 6e79 6d61 6369     . ..  >> Dynamic
fffd6115:	5320 4c43 7720 7469 2068 7257 7469 2065      SCL with Write 
fffd6125:	6942 2d74 654c 6576 6c6c 6e69 2e67 0a20     Bit-Levelling. .
fffd6135:	3e00 5020 5948 445f 4c4c 415f 5244 5443     .> PHY_DLL_ADRCT
fffd6145:	4c52 2820 7830 4134 2029 203d 7830 3025     RL (0x4A) = 0x%0
fffd6155:	6c38 2058 000a 2020 3e3e 4e20 6d75 6562     8lX ..  >> Numbe
fffd6165:	2072 666f 6420 6c65 7961 6520 656c 656d     r of delay eleme
fffd6175:	746e 2073 6f63 7272 7365 6f70 646e 2073     nts corresponds 
fffd6185:	6f74 6f20 656e 6320 6f6c 6b63 6320 6379     to one clock cyc
fffd6195:	656c 2820 6c64 5f6c 616d 5f73 6c64 2979     le (dll_mas_dly)
fffd61a5:	203a 6c25 2e75 0a20 2000 3e20 203e 754e     : %lu. ..  >> Nu
fffd61b5:	626d 7265 6f20 2066 6564 616c 2079 6c65     mber of delay el
fffd61c5:	6d65 6e65 7374 6320 726f 6572 7073 6e6f     ements correspon
fffd61d5:	7364 7420 206f 2f31 2034 6c63 636f 206b     ds to 1/4 clock 
fffd61e5:	7963 6c63 2065 6428 6c6c 735f 766c 645f     cycle (dll_slv_d
fffd61f5:	796c 775f 7269 2965 203a 6c25 2e75 000a     ly_wire): %lu...
fffd6205:	2020 3e3e 4420 6c65 7961 6f20 2066 6f63       >> Delay of co
fffd6215:	746e 6f72 206c 6973 6e67 6c61 2073 6977     ntrol signals wi
fffd6225:	6874 7220 7365 6570 7463 7420 206f 756f     th respect to ou
fffd6235:	7074 7475 6420 7461 2061 6973 6e67 6c61     tput data signal
fffd6245:	2073 6428 6c6c 5f73 7274 6d69 615f 7264     s (dlls_trim_adr
fffd6255:	7463 296c 203a 2b00 2d00 3e00 5020 5948     ctl): .+.-.> PHY
fffd6265:	445f 4c4c 525f 4345 4c41 4249 2820 7830     _DLL_RECALIB (0x
fffd6275:	3934 2029 203d 7830 3025 6c38 2058 000a     49) = 0x%08lX ..
fffd6285:	2020 3e3e 4420 6c65 7961 6f20 2066 6f72       >> Delay of ro
fffd6295:	2f77 6f63 756c 6e6d 6120 6464 6572 7373     w/column address
fffd62a5:	7320 6769 616e 736c 7720 7469 2068 6572      signals with re
fffd62b5:	7073 6365 2074 6f74 6420 7461 2061 756f     spect to data ou
fffd62c5:	7074 7475 7320 6769 616e 736c 2820 6c64     tput signals (dl
fffd62d5:	736c 745f 6972 5f6d 6461 6372 7274 5f6c     ls_trim_adrctrl_
fffd62e5:	616d 3a29 0020 203e 4850 5f59 4c44 5f4c     ma): .> PHY_DLL_
fffd62f5:	5254 4d49 435f 4b4c 2820 7830 3936 2029     TRIM_CLK (0x69) 
fffd6305:	203d 7830 3025 6c38 2058 000a 2020 3e3e     = 0x%08lX ..  >>
fffd6315:	4420 6c65 7961 6f20 2066 6c63 636f 206b      Delay of clock 
fffd6325:	6973 6e67 6c61 7720 7469 2068 6572 7073     signal with resp
fffd6335:	6365 2074 6f74 6420 7461 2061 756f 7074     ect to data outp
fffd6345:	7475 7320 6769 616e 736c 2820 6c64 736c     ut signals (dlls
fffd6355:	745f 6972 5f6d 6c63 296b 203a 3e00 5320     _trim_clk): .> S
fffd6365:	4c43 4c5f 5441 4e45 5943 2820 7830 3334     CL_LATENCY (0x43
fffd6375:	2029 203d 7830 3025 6c38 2e58 0a20 2000     ) = 0x%08lX. .. 
fffd6385:	3e20 203e 6163 7470 7275 5f65 6c63 5f6b      >> capture_clk_
fffd6395:	6c64 3a79 3d20 2520 756c 0a20 2000 3e20     dly: = %lu ..  >
fffd63a5:	203e 616d 6e69 635f 6b6c 645f 796c 203a     > main_clk_dly: 
fffd63b5:	203d 6c25 2075 000a 203e 6144 6174 4f20     = %lu ..> Data O
fffd63c5:	7475 7570 2074 6544 616c 3a79 0a20 2000     utput Delay: .. 
fffd63d5:	3e20 203e 614c 656e 6c25 3a75 0020 5144      >> Lane%lu: .DQ
fffd63e5:	6c25 3a75 7830 3025 5832 202c 4400 3a4d     %lu:0x%02X, .DM:
fffd63f5:	7830 3025 5832 202c 7400 6972 5f6d 3a31     0x%02X, .trim_1:
fffd6405:	252b 2c75 0020 7274 6d69 315f 2d3a 7525     +%u, .trim_1:-%u
fffd6415:	202c 7000 6168 6573 3a31 7525 362f 2034     , .phase1:%u/64 
fffd6425:	7963 6c63 2c65 0020 7274 6d69 325f 253a     cycle, .trim_2:%
fffd6435:	2c75 0020 616d 5f73 6c64 3a79 7525 202c     u, .mas_dly:%u, 
fffd6445:	3e00 4420 7461 2061 6e49 7570 2074 6544     .> Data Input De
fffd6455:	616c 3a79 0a20 2000 2020 2020 2020 2020     lay: ..         
fffd6465:	6142 6573 303a 2578 3230 2c58 0020 7274     Base:0x%02X, .tr
fffd6475:	6d69 335f 2b3a 7525 202c 7400 6972 5f6d     im_3:+%u, .trim_
fffd6485:	3a33 252d 2c75 0020 6870 7361 3265 253a     3:-%u, .phase2:%
fffd6495:	2f75 3436 6320 6379 656c 202c 6400 7461     u/64 cycle, .dat
fffd64a5:	5f61 6163 7470 7275 5f65 6c63 3a6b 7830     a_capture_clk:0x
fffd64b5:	3025 5832 202c 6d00 6961 5f6e 6c63 5f6b     %02X, .main_clk_
fffd64c5:	6564 746c 5f61 6c64 3a79 7830 3025 5832     delta_dly:0x%02X
fffd64d5:	202c 6300 6379 656c 635f 746e 303a 2578     , .cycle_cnt:0x%
fffd64e5:	3230 2c58 0020 203e 4e55 5149 4955 5946     02X, .> UNIQUIFY
fffd64f5:	495f 5f4f 2031 3028 3578 2943 3d20 3020     _IO_1 (0x5C) = 0
fffd6505:	2578 3830 586c 203a 000a 2020 3e3e 5a20     x%08lX: ..  >> Z
fffd6515:	2051 7561 6f74 6320 6c61 6269 6172 6974     Q auto calibrati
fffd6525:	6e6f 6920 2073 4e4f 202e 6550 6972 646f     on is ON. Period
fffd6535:	203a 7525 7820 3220 3635 5020 5948 6320     : %u x 256 PHY c
fffd6545:	6f6c 6b63 2e73 0a20 2000 3e20 203e 515a     locks. ..  >> ZQ
fffd6555:	6120 7475 206f 6163 696c 7262 7461 6f69      auto calibratio
fffd6565:	206e 7369 4f20 4646 6f20 2072 766f 7265     n is OFF or over
fffd6575:	6972 6564 2e64 0a20 3e00 5520 494e 5551     rided. ..> UNIQU
fffd6585:	4649 5f59 4f49 325f 2820 7830 4435 2029     IFY_IO_2 (0x5D) 
fffd6595:	203d 7830 3025 6c38 3a58 0a20 2000 3e20     = 0x%08lX: ..  >
fffd65a5:	203e 515a 5620 6c61 6575 3a73 2020 666e     > ZQ Values:  nf
fffd65b5:	7465 635f 6c61 303a 2578 586c 202c 6670     et_cal:0x%lX, pf
fffd65c5:	7465 635f 6c61 303a 2578 586c 0a20 3e00     et_cal:0x%lX ..>
fffd65d5:	5020 5948 505f 4441 435f 5254 204c 3028      PHY_PAD_CTRL (0
fffd65e5:	3478 2938 3d20 3020 2578 3830 586c 203a     x48) = 0x%08lX: 
fffd65f5:	000a 2020 3e3e 4420 2f51 5144 2053 6e69     ..  >> DQ/DQS in
fffd6605:	7570 2074 7964 616e 696d 2063 6574 6d72     put dynamic term
fffd6615:	6e69 7461 6f69 206e 4f28 5444 3a29 0020     ination (ODT): .
fffd6625:	6f4e 0a20 3200 3034 2052 000a 3231 5230     No ..240R ..120R
fffd6635:	0a20 3800 5230 0a20 3600 5230 0a20 3400      ..80R ..60R ..4
fffd6645:	5238 0a20 5200 7365 7265 6576 2064 000a     8R ..Reserved ..
fffd6655:	2020 3e3e 4420 2f51 4d44 442f 5351 6f20       >> DQ/DM/DQS o
fffd6665:	7475 7570 2074 7264 7669 2065 7473 6572     utput drive stre
fffd6675:	676e 6874 203a 3300 5234 202e 000a 3834     ngth: .34R. ..48
fffd6685:	2e52 0a20 2000 3e20 203e 6441 7264 7365     R. ..  >> Addres
fffd6695:	2073 6e61 2064 6f63 746e 6f72 206c 756f     s and control ou
fffd66a5:	7074 7475 6420 6972 6576 7320 7274 6e65     tput drive stren
fffd66b5:	7467 3a68 0020 2020 3e3e 4320 6f6c 6b63     gth: .  >> Clock
fffd66c5:	4f20 7475 7570 2074 7264 7669 2065 7473      Output drive st
fffd66d5:	6572 676e 6874 203a 2000 3e20 203e 7270     rength: .  >> pr
fffd66e5:	6165 626d 656c 645f 796c 3d20 0020 2032     eamble_dly = .2 
fffd66f5:	7963 6c63 7365 202e 000a 2e31 2035 7963     cycles. ..1.5 cy
fffd6705:	6c63 7365 202e 000a 2031 7963 6c63 2e65     cles. ..1 cycle.
fffd6715:	0a20 4900 766e 6c61 6469 202e 000a 203e      ..Invalid. ..> 
fffd6725:	4850 2059 5256 4645 203a 000a 6152 676e     PHY VREF: ..Rang
fffd6735:	3a65 7525 203b 7453 7065 303a 2578 3230     e:%u; Step:0x%02
fffd6745:	3b58 2820 7525 6d20 2956 000a 4420 4152     X; (%u mV).. DRA
fffd6755:	204d 6544 6976 6563 4920 666e 726f 616d     M Device Informa
fffd6765:	6974 6e6f 0020 2020 3e3e 5220 6165 6f64     tion .  >> Reado
fffd6775:	7475 4d20 5250 5020 6761 2065 3a30 0a20     ut MPR Page 0: .
fffd6785:	2000 2020 2020 2520 3a75 0020 7830 3025     .      %u: .0x%0
fffd6795:	5834 0020 4520 7272 726f 203a 6156 756c     4X . Error: Valu
fffd67a5:	7365 6120 6572 6e20 746f 6120 2073 7865     es are not as ex
fffd67b5:	6570 7463 6465 202e 000a 2020 3e3e 5220     pected. ..  >> R
fffd67c5:	6165 6f64 7475 4d20 5250 5020 6761 2065     eadout MPR Page 
fffd67d5:	2032 3e3d 3020 203a 7830 3025 5832 202c     2 => 0: 0x%02X, 
fffd67e5:	3a31 3020 2578 3230 2c58 3220 203a 7830     1: 0x%02X, 2: 0x
fffd67f5:	3025 5832 202c 3a33 3020 2578 3230 2e58     %02X, 3: 0x%02X.
fffd6805:	0020 2820 7245 6f72 3a72 7620 6c61 6575      . (Error: value
fffd6815:	2073 616d 2079 6562 6920 766e 6c61 6469     s may be invalid
fffd6825:	2029 000a 2020 3e3e 5620 4552 2046 5144     ) ..  >> VREF DQ
fffd6835:	203a 2000 3e20 203e 754f 7074 7475 6420     : .  >> Output d
fffd6845:	6972 6576 7320 7274 6e65 7467 3a68 0020     rive strength: .
fffd6855:	2020 3e3e 5220 5454 4e5f 4d4f 203a 4f00       >> RTT_NOM: .O
fffd6865:	6666 0a20 3300 5234 0a20 2000 3e20 203e     ff ..34R ..  >> 
fffd6875:	5452 5f54 4150 4b52 203a 2000 3e20 203e     RTT_PARK: .  >> 
fffd6885:	5452 5f54 5257 203a 2000 3e20 203e 4143     RTT_WR: .  >> CA
fffd6895:	2053 614c 6574 636e 2079 4328 294c 203a     S Latency (CL): 
fffd68a5:	7830 7825 2820 7525 2029 000a 2020 3e3e     0x%x (%u) ..  >>
fffd68b5:	4320 5341 5720 6972 6574 4c20 7461 6e65      CAS Write Laten
fffd68c5:	7963 2820 5743 294c 203a 7830 7825 2820     cy (CWL): 0x%x (
fffd68d5:	7525 2029 000a 6146 6c69 6465 7420 206f     %u) ..Failed to 
fffd68e5:	6573 2074 5244 4d41 5620 6572 4466 2e51     set DRAM VrefDQ.
fffd68f5:	4f20 7475 4f2d 2d66 6152 676e 2065 6e6f      Out-Of-Range on
fffd6905:	6220 746f 2068 6172 676e 7365 202e 7256      both ranges. Vr
fffd6915:	6665 5144 6d5f 3d56 7525 2000 5244 4d41     efDQ_mV=%u. DRAM
fffd6925:	5620 6572 4466 3a51 4420 6665 7561 746c      VrefDQ: Default
fffd6935:	5320 7465 6f50 6e69 0074 203e 7525 6d20      SetPoint.> %u m
fffd6945:	2076 7228 6e61 6567 203a 7525 202c 7473     v (range: %u, st
fffd6955:	7065 2520 2975 0a0a 2000 6553 2074 5244     ep %u)... Set DR
fffd6965:	4d41 5620 6572 4466 3a51 5320 7465 6f50     AM VrefDQ: SetPo
fffd6975:	6e69 2b74 7525 566d 3e00 2520 2075 766d     int+%umV.> %u mv
fffd6985:	2820 6172 676e 3a65 2520 2c75 7320 6574      (range: %u, ste
fffd6995:	2070 7525 0a29 4000 7256 6665 5144 2b3a     p %u)..@VrefDQ:+
fffd69a5:	5664 2000 6553 2074 5244 4d41 5620 6572     dV. Set DRAM Vre
fffd69b5:	4466 3a51 5320 7465 6f50 6e69 2d74 7525     fDQ: SetPoint-%u
fffd69c5:	566d 4000 7256 6665 5144 2d3a 5664 2000     mV.@VrefDQ:-dV. 
fffd69d5:	4850 2059 7256 6665 5144 203a 6544 6166     PHY VrefDQ: Defa
fffd69e5:	6c75 2074 6553 5074 696f 746e 3e00 4c20     ult SetPoint.> L
fffd69f5:	6e61 2565 3a75 2520 2075 766d 2820 6172     ane%u: %u mv (ra
fffd6a05:	676e 3a65 2520 2c75 7320 6574 2070 7525     nge: %u, step %u
fffd6a15:	0a29 4000 7256 6665 5144 643a 6665 7561     )..@VrefDQ:defau
fffd6a25:	746c 2000 6553 2074 4850 2059 7256 6665     lt. Set PHY Vref
fffd6a35:	5144 203a 6553 5074 696f 746e 252b 6d75     DQ: SetPoint+%um
fffd6a45:	2056 2000 6553 2074 4850 2059 7256 6665     V . Set PHY Vref
fffd6a55:	5144 203a 6553 5074 696f 746e 252d 6d75     DQ: SetPoint-%um
fffd6a65:	0056 200a 2a2a 2a2a 202a 7245 6f72 3a72     V.. ***** Error:
fffd6a75:	4d20 6d65 726f 2079 6f43 746e 6f72 6c6c      Memory Controll
fffd6a85:	7265 7720 7361 6e20 746f 6920 696e 6974     er was not initi
fffd6a95:	6c61 7a69 6465 2a20 2a2a 2a2a 202a 000a     alized ****** ..
fffd6aa5:	4e0a 544f 3a45 000a 202a 4444 3452 6d20     .NOTE:..* DDR4 m
fffd6ab5:	6d65 726f 2079 7369 6e20 746f 7620 6c61     emory is not val
fffd6ac5:	6469 7720 6968 656c 7320 6577 7065 6e69     id while sweepin
fffd6ad5:	2c67 6920 206e 6163 6573 6820 736f 2074     g, in case host 
fffd6ae5:	7375 2065 4d42 2043 7267 7061 6968 7363     use BMC graphics
fffd6af5:	202c 7469 6d20 7961 7320 7574 6b63 202e     , it may stuck. 
fffd6b05:	000a 202a 7250 7365 2073 4527 4353 2027     ..* Press 'ESC' 
fffd6b15:	6f74 6120 6f62 7472 7420 6568 7320 6577     to abort the swe
fffd6b25:	7065 202e 000a 200a 2a2a 2a2a 202a 7245     ep. ... ***** Er
fffd6b35:	6f72 3a72 4320 5550 2031 616d 2079 6c61     ror: CPU1 may al
fffd6b45:	6572 6461 2079 7572 6e6e 6e69 2e67 4920     ready running. I
fffd6b55:	7373 6575 6820 7261 7764 7261 2065 6572     ssue hardware re
fffd6b65:	6573 2074 6562 6f66 6572 7220 6e75 696e     set before runni
fffd6b75:	676e 7420 6968 2073 6574 7473 2120 2121     ng this test !!!
fffd6b85:	2a20 2a2a 2a2a 0a20 3e00 4420 7369 6261      ***** ..> Disab
fffd6b95:	656c 4420 4353 204c 6562 6f66 6572 7320     le DSCL before s
fffd6ba5:	6577 7065 6e69 2e67 000a 2a20 2a2a 2a2a     weeping... *****
fffd6bb5:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
fffd6bc5:	2a2a 2a2a 2a2a 0a2a 2000 2a2a 202a 6554     *******.. *** Te
fffd6bd5:	7473 4320 6d6f 6c70 7465 6465 203a 4150     st Completed: PA
fffd6be5:	5353 2a20 2a2a 000a 2a20 2a2a 5420 7365     SS ***.. *** Tes
fffd6bf5:	2074 6f43 706d 656c 6574 3a64 4620 4941     t Completed: FAI
fffd6c05:	204c 2a2a 0a2a 2000 4850 2059 7256 6665     L ***.. PHY Vref
fffd6c15:	5144 203a 616c 656e 203a 7525 202c 7525     DQ: lane: %u, %u
fffd6c25:	6d20 2076 7228 6e61 6567 203a 7525 202c      mv (range: %u, 
fffd6c35:	7473 7065 2520 2975 5200                         step %u).

fffd6c3e <__FUNCTION__.5887>:
fffd6c3e:	6552 6f6c 6163 6574 6c54 7362 0900               RelocateTlbs.

fffd6c4b <CWL>:
fffd6c4b:	0a09 0c0b 100e 0012                         ........

fffd6c53 <g_Text_AbortedByUser>:
fffd6c53:	200a 2d2d 202d 6261 726f 6574 2064 7962     . --- aborted by
fffd6c63:	7520 6573 2e72 000a 0000                          user....

fffd6c6c <DDR_MPR2_Expected>:
fffd6c6c:	0000 ffff 0000 ffff 0000 ffff 0000 ffff     ................
fffd6c7c:	0000 0000 ffff ffff 0000 0000 ffff ffff     ................
	...
fffd6c94:	ffff ffff ffff ffff 0000 0000 0000 0000     ................
	...

fffd6cac <Golden_Numbers>:
fffd6cac:	00ff 007f ff00 ff80 00ff 00bf ff00 ff40     ..............@.
fffd6cbc:	00ff 00df ff00 ff20 00ff 00ef ff00 ff10     ...... .........
fffd6ccc:	00ff 00f7 ff00 ff08 00ff 00fb ff00 ff04     ................
fffd6cdc:	00ff 00fd ff00 ff02 00ff 00fe ff00 ff01     ................
fffd6cec:	007f 00ff ff80 ff00 00bf 00ff ff40 ff00     ............@...
fffd6cfc:	00df 00ff ff20 ff00 00ef 00ff ff10 ff00     .... ...........
fffd6d0c:	00f7 00ff ff08 ff00 00fb 00ff ff04 ff00     ................
fffd6d1c:	00fd 00ff ff02 ff00 00fe 00ff ff01 ff00     ................
fffd6d2c:	00ff 00ff ff00 ff00 00ff 7f00 ff00 80ff     ................
fffd6d3c:	00ff bf00 ff00 40ff 00ff df00 ff00 20ff     .......@....... 
fffd6d4c:	00ff ef00 ff00 10ff 00ff f700 ff00 08ff     ................
fffd6d5c:	00ff fb00 ff00 04ff 00ff fd00 ff00 02ff     ................
fffd6d6c:	00ff fe00 ff00 01ff 007f ff00 ff80 00ff     ................
fffd6d7c:	00bf ff00 ff40 00ff 00df ff00 ff20 00ff     ....@....... ...
fffd6d8c:	00ef ff00 ff10 00ff 00f7 ff00 ff08 00ff     ................
fffd6d9c:	00fb ff00 ff04 00ff 00fd ff00 ff02 00ff     ................
fffd6dac:	00fe ff00 ff01 00ff 00ff ff00 ff00 00ff     ................
fffd6dbc:	ff00 007f 00ff ff80 ff00 00bf 00ff ff40     ..............@.
fffd6dcc:	ff00 00df 00ff ff20 ff00 00ef 00ff ff10     ...... .........
fffd6ddc:	ff00 00f7 00ff ff08 ff00 00fb 00ff ff04     ................
fffd6dec:	ff00 00fd 00ff ff02 ff00 00fe 00ff ff01     ................
fffd6dfc:	7f00 00ff 80ff ff00 bf00 00ff 40ff ff00     .............@..
fffd6e0c:	df00 00ff 20ff ff00 ef00 00ff 10ff ff00     ..... ..........
fffd6e1c:	f700 00ff 08ff ff00 fb00 00ff 04ff ff00     ................
fffd6e2c:	fd00 00ff 02ff ff00 fe00 00ff 01ff ff00     ................
fffd6e3c:	ff00 00ff 00ff ff00 ff00 7f00 00ff 80ff     ................
fffd6e4c:	ff00 bf00 00ff 40ff ff00 df00 00ff 20ff     .......@....... 
fffd6e5c:	ff00 ef00 00ff 10ff ff00 f700 00ff 08ff     ................
fffd6e6c:	ff00 fb00 00ff 04ff ff00 fd00 00ff 02ff     ................
fffd6e7c:	ff00 fe00 00ff 01ff 7f00 ff00 80ff 00ff     ................
fffd6e8c:	bf00 ff00 40ff 00ff df00 ff00 20ff 00ff     .....@....... ..
fffd6e9c:	ef00 ff00 10ff 00ff f700 ff00 08ff 00ff     ................
fffd6eac:	fb00 ff00 04ff 00ff fd00 ff00 02ff 00ff     ................
fffd6ebc:	fe00 ff00 01ff 00ff ff00 ff00 00ff 00ff     ................
fffd6ecc:	0000 7fff ffff 8000 0000 bfff ffff 4000     ...............@
fffd6edc:	0000 dfff ffff 2000 0000 efff ffff 1000     ....... ........
fffd6eec:	0000 f7ff ffff 0800 0000 fbff ffff 0400     ................
fffd6efc:	0000 fdff ffff 0200 0000 feff ffff 0100     ................
fffd6f0c:	0000 ff7f ffff 0080 0000 ffbf ffff 0040     ..............@.
fffd6f1c:	0000 ffdf ffff 0020 0000 ffef ffff 0010     ...... .........
fffd6f2c:	0000 fff7 ffff 0008 0000 fffb ffff 0004     ................
fffd6f3c:	0000 fffd ffff 0002 0000 fffe ffff 0001     ................
fffd6f4c:	0000 ffff ffff 0000 aa55 aa55 55aa 55aa     ........U.U..U.U
fffd6f5c:	ffff ffff 0000 0000 00ff 007f ff00 ff80     ................
fffd6f6c:	00ff 00bf ff00 ff40 00ff 00df ff00 ff20     ......@....... .
fffd6f7c:	00ff 00ef ff00 ff10 00ff 00f7 ff00 ff08     ................
fffd6f8c:	00ff 00fb ff00 ff04 00ff 00fd ff00 ff02     ................
fffd6f9c:	00ff 00fe ff00 ff01 007f 00ff ff80 ff00     ................
fffd6fac:	00bf 00ff ff40 ff00 00df 00ff ff20 ff00     ....@....... ...
fffd6fbc:	00ef 00ff ff10 ff00 00f7 00ff ff08 ff00     ................
fffd6fcc:	00fb 00ff ff04 ff00 00fd 00ff ff02 ff00     ................
fffd6fdc:	00fe 00ff ff01 ff00 00ff 00ff ff00 ff00     ................
fffd6fec:	00ff 7f00 ff00 80ff 00ff bf00 ff00 40ff     ...............@
fffd6ffc:	00ff df00 ff00 20ff 00ff ef00 ff00 10ff     ....... ........
fffd700c:	00ff f700 ff00 08ff 00ff fb00 ff00 04ff     ................
fffd701c:	00ff fd00 ff00 02ff 00ff fe00 ff00 01ff     ................
fffd702c:	007f ff00 ff80 00ff 00bf ff00 ff40 00ff     ............@...
fffd703c:	00df ff00 ff20 00ff 00ef ff00 ff10 00ff     .... ...........
fffd704c:	00f7 ff00 ff08 00ff 00fb ff00 ff04 00ff     ................
fffd705c:	00fd ff00 ff02 00ff 00fe ff00 ff01 00ff     ................
fffd706c:	00ff ff00 ff00 00ff ff00 007f 00ff ff80     ................
fffd707c:	ff00 00bf 00ff ff40 ff00 00df 00ff ff20     ......@....... .
fffd708c:	ff00 00ef 00ff ff10 ff00 00f7 00ff ff08     ................
fffd709c:	ff00 00fb 00ff ff04 ff00 00fd 00ff ff02     ................
fffd70ac:	2020 5420 7365 2074 6261 726f 2074 0a20        Test abort  .
fffd70bc:	2a00 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     .***************
fffd70cc:	0a20 2000 2020 6554 7473 6520 6978 2074      ..   Test exit 
fffd70dc:	6977 6874 6520 7272 726f 6e20 6d75 2520     with error num %
fffd70ec:	2064 2020 2020 000a 2020 6554 7473 6520     d     ..  Test e
fffd70fc:	6978 2074 6977 6874 6e20 206f 7265 6f72     xit with no erro
fffd710c:	7372 2020 2020 2020 2020 000a 6325 255b     rs        ..%c[%
fffd711c:	3b75 7525 006d 6954 6c74 3a65 0020 2a0a     u;%um.Title: ..*
fffd712c:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
fffd713c:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
fffd714c:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
fffd715c:	2a2a 000a 200a 7250 7365 2073 4527 544e     **... Press 'ENT
fffd716c:	5245 2027 6f74 7320 6174 7472 2e20 2e2e     ER' to start ...
fffd717c:	0020 7355 2065 4155 5452 6425 0020 6f43      .Use UART%d .Co
fffd718c:	666e 6769 7275 2065 4155 5452 3c33 2d2d     nfigure UART3<--
fffd719c:	533e 3249 203b 6e49 7469 5520 5253 3354     >SI2; Init USRT3
fffd71ac:	7420 206f 4e38 2031 2040 3131 4b35 2f62      to 8N1 @ 115Kb/
fffd71bc:	2e73 000a 6f43 666e 6769 7275 2065 4155     s...Configure UA
fffd71cc:	5452 3c30 2d2d 423e 5053 203b 6e49 7469     RT0<-->BSP; Init
fffd71dc:	5520 5253 3054 7420 206f 4e38 2031 2040      USRT0 to 8N1 @ 
fffd71ec:	3131 4b35 2f62 2e73 000a 2008 0008 7830     115Kb/s.... ..0x
fffd71fc:	3025 5832 2000 202d 6261 726f 6574 2064     %02X. - aborted 
fffd720c:	7962 7520 6573 2e72 000a 7830 6c25 0078     by user...0x%lx.
fffd721c:	2d20 4920 766e 6c61 6469 6620 726f 616d      - Invalid forma
fffd722c:	2c74 6120 6f62 7472 0a2e 3000 2578 3830     t, abort...0x%08
fffd723c:	586c 2500 646c 4500                              lX.%ld.

fffd7243 <pErrorMsg>:
fffd7243:	7245 6f72 3a72 6d20 7365 6173 6567 6c20     Error: message l
fffd7253:	6e65 7467 2068 7865 6563 6465 4620 726f     ength exceed For
fffd7263:	616d 7474 6465 6554 7478 7542 6666 7265     mattedTextBuffer
fffd7273:	7320 7a69 2e65 0a20 000d                     size. ...
